Only in ../swoole-1.8.5-stable/: .git
Only in ../swoole-1.8.5-stable/: .gitignore
Only in ../swoole-1.8.5-stable/: .travis.yml
diff -r ./zan-extension/CMakeLists.txt ../swoole-1.8.5-stable/CMakeLists.txt
3c3
< SET(SWOOLE_VERSION 2.0.0)
---
> SET(SWOOLE_VERSION 1.8.5)
Only in ../swoole-1.8.5-stable/: README.md
Only in ./zan-extension/: c-tests
Only in ./zan-extension/: clean
Only in ./zan-extension/: clean.sh
diff -r ./zan-extension/config.m4 ../swoole-1.8.5-stable/config.m4
25a26,28
> PHP_ARG_ENABLE(async_mysql, enable async_mysql support,
> [  --enable-async-mysql    Do you have mysqli and mysqlnd?], no, no)
> 
28a32,34
> PHP_ARG_ENABLE(async_httpclient, enable async_httpclient support,
> [  --enable-async-httpclient  Enable async httpclient support?], no, no)
> 
47,52d52
< PHP_ARG_WITH(openssl_dir, for OpenSSL support,
< [  --with-openssl-dir[=DIR]    Include OpenSSL support (requires OpenSSL >= 0.9.6)], no, no)
< 
< PHP_ARG_ENABLE(mysqlnd, enable mysqlnd support,
< [  --enable-mysqlnd       Do you have mysqlnd?], no, no)
< 
143a144,151
>     if test "$PHP_MYSQLI" = "yes"; then
> 		AC_DEFINE(HAVE_MYSQLI, 1, [have mysqli extension])
>     fi
> 
>     if test "$PHP_MYSQLND" = "yes"; then
> 		AC_DEFINE(HAVE_MYSQLND, 1, [have mysqlnd extension])
>     fi
> 
151a160,163
> 	if test "$PHP_ASYNC_MYSQL" = "yes"; then
> 		AC_DEFINE(SW_ASYNC_MYSQL, 1, [enable async_mysql support])
>     fi
> 
155a168,171
> 	if test "$PHP_ASYNC_HTTPCLIENT" = "yes"; then
> 		AC_DEFINE(SW_ASYNC_HTTPCLIENT, 1, [enable async_httpclient support])
>     fi
> 
159c175,183
<     CFLAGS="-std=gnu99 -Wall -pthread $CFLAGS -fstack-check  -fbounds-check  -fstack-protector -fstack-protector-all -fno-strict-aliasing"
---
>     SWOOLE_HAVE_PHP_EXT([mysqli], [
>         AC_DEFINE(SW_HAVE_MYSQLI, 1, [have mysqli])
>     ])
> 
>     SWOOLE_HAVE_PHP_EXT([mysqlnd], [
>         AC_DEFINE(SW_HAVE_MYSQLND, 1, [have mysqlnd])
>     ])
> 
>     CFLAGS="-Wall -pthread $CFLAGS"
162,165d185
<     if test "$PHP_MYSQLND" = "yes"; then
<         PHP_ADD_EXTENSION_DEP(mysqli, mysqlnd)
<         AC_DEFINE(SW_USE_MYSQLND, 1, [use mysqlnd])
<     fi
171c191
< 	AC_CHECK_LIB(c, sendfile, AC_DEFINE(HAVE_SENDFILE, 1, [have sendfile]))
---
> 	AC_CHECK_LIB(c, sendfile,PGSQL_INCLUDE AC_DEFINE(HAVE_SENDFILE, 1, [have sendfile]))
196c216
<         if test "$PHP_OPENSSL" != "no" || test "$PHP_OPENSSL_DIR" != "no"; then
---
>         if test "$PHP_OPENSSL" = "yes"; then
198,202d217
< 	    if test "$PHP_OPENSSL_DIR" != "no"; then
<             	PHP_ADD_INCLUDE("${PHP_OPENSSL_DIR}/include")
<             	PHP_ADD_LIBRARY_WITH_PATH(ssl, "${PHP_OPENSSL_DIR}/lib")
< 		PHP_ADD_LIBRARY_WITH_PATH(crypto,"${PHP_OPENSSL_DIR}/lib")
<             fi
204,205c219,220
<             PHP_ADD_LIBRARY_WITH_PATH(crypto, /usr/local/opt/openssl/lib, SWOOLE_SHARED_LIBADD)
<             PHP_ADD_INCLUDE(/usr/local/opt/openssl/include)
---
>             PHP_ADD_LIBRARY(mcrypt, 1, SWOOLE_SHARED_LIBADD)
>             PHP_ADD_LIBRARY(crypto, 1, SWOOLE_SHARED_LIBADD)
212c227
<         if test "$PHP_OPENSSL" != "no" || test "$PHP_OPENSSL_DIR" != "no"; then
---
>         if test "$PHP_OPENSSL" = "yes"; then
214,220d228
< 	    if test "$PHP_OPENSSL_DIR" != "no"; then
<             	PHP_ADD_INCLUDE("${PHP_OPENSSL_DIR}/include")
<             	PHP_ADD_LIBRARY_WITH_PATH(ssl, "${PHP_OPENSSL_DIR}/lib")
< 		PHP_ADD_LIBRARY_WITH_PATH(crypto,"${PHP_OPENSSL_DIR}/lib")
< 		PHP_ADD_LIBRARY_WITH_PATH(crypt,"${PHP_OPENSSL_DIR}/lib")
<             fi
< 	    
226,239c234
<     if test "$PHP_CURL" != "no"; then
<         for i in /usr /usr/local /usr/local/Cellar/curl/7.47.1; do
<             if test -f $i/include/curl/curl.h; then
<                 CURL_DIR=$i
<             fi
<         done
<         
<         if test -z "$CURL_DIR"; then
<             AC_MSG_ERROR([libcurl not installed])
<         fi
<         
<         PHP_ADD_LIBRARY(curl, 1, SWOOLE_SHARED_LIBADD)
<     fi
<     
---
> 
244,252c239
<         os=`uname -s`
<         case $os in
<             Linux)
<                 PHP_ADD_LIBRARY_WITH_PATH(hiredis_linux, ../lib, SWOOLE_SHARED_LIBADD)
<             ;;
<             Darwin)
<                 PHP_ADD_LIBRARY_WITH_PATH(hiredis_mac, ../lib, SWOOLE_SHARED_LIBADD)
<             ;;
<         esac
---
>         PHP_ADD_LIBRARY(hiredis, 1, SWOOLE_SHARED_LIBADD)
254c241
<  
---
> 
268c255,256
<         swoole_connpool.c \
---
>         swoole_atomic.c \
>         swoole_lock.c \
274a263
>         swoole_table.c \
281,282c270,271
<         swoole_nova.c \
<         src/Base.c \
---
>         src/core/base.c \
>         src/core/log.c \
284a274
>         src/core/Channel.c \
286a277
>         src/core/socket.c \
289,290d279
< 		src/core/log.c \
< 		src/core/rbtree.c \
301,302d289
< 		src/factory/ProcessPool.c \
< 		src/factory/ThreadPool.c \
311,312d297
< 		src/pipe/Channel.c \
< 		src/pipe/Msgqueue.c \
318,331c303,315
< 		src/lock/AtomicLock.c \
< 		src/lock/Cond.c \
< 		src/network/Client.c \
< 		src/network/Connection.c \
< 		src/network/Manager.c \
< 		src/network/Port.c \
< 		src/network/ReactorAccept.c \
< 		src/network/ReactorProcess.c \
< 		src/network/ReactorThread.c \
< 		src/network/Server.c \
< 		src/network/Socket.c \
< 		src/network/TaskWorker.c \
< 		src/network/Worker.c \
<         src/os/AsyncIO.c \
---
>         src/network/Server.c \
>         src/network/TaskWorker.c \
>         src/network/Client.c \
>         src/network/Connection.c \
>         src/network/ProcessPool.c \
>         src/network/ThreadPool.c \
>         src/network/ReactorThread.c \
>         src/network/ReactorProcess.c \
>         src/network/Manager.c \
>         src/network/Worker.c \
>         src/network/Timer.c \
>         src/network/Port.c \
>         src/os/base.c \
333a318,321
>         src/os/msg_queue.c \
>         src/os/sendfile.c \
>         src/os/signal.c \
>         src/os/timer.c \
335c323
<         src/protocol/Base64.c \
---
>         src/protocol/SSL.c \
337a326
>         src/protocol/WebSocket.c \
339,350c328
<         src/protocol/Nova.c \
<         src/protocol/Sha1.c \
<         src/protocol/SSL.c \
< 		src/protocol/WebSocket.c \
<         src/util/Baseoperator.c \
<         src/util/BinaryData.c \
<         src/util/DNS.c \
<         src/util/Module.c \
<         src/util/Sendfile.c \
< 		src/util/Signal.c \
< 		src/util/Timer.c"
< 
---
>         src/protocol/Base64.c"
364c342
<     PHP_ADD_BUILD_DIR($ext_builddir/src/util)
---
>     PHP_ADD_BUILD_DIR($ext_builddir/src/queue)
Only in ../swoole-1.8.5-stable/: examples
Only in ../swoole-1.8.5-stable/include: Client.h
Only in ../swoole-1.8.5-stable/include: Connection.h
Only in ../swoole-1.8.5-stable/include: RingQueue.h
Only in ../swoole-1.8.5-stable/include: Server.h
Only in ../swoole-1.8.5-stable/include: array.h
Only in ../swoole-1.8.5-stable/include: async.h
Only in ../swoole-1.8.5-stable/include: atomic.h
Only in ../swoole-1.8.5-stable/include: base64.h
Only in ../swoole-1.8.5-stable/include: buffer.h
Only in ../swoole-1.8.5-stable/include: error.h
Only in ../swoole-1.8.5-stable/include: hash.h
Only in ../swoole-1.8.5-stable/include: hashmap.h
Only in ../swoole-1.8.5-stable/include: heap.h
Only in ./zan-extension/include: hiredis
Only in ../swoole-1.8.5-stable/include: http.h
Only in ../swoole-1.8.5-stable/include: http2.h
Only in ../swoole-1.8.5-stable/include: mqtt.h
Only in ../swoole-1.8.5-stable/include: rbtree.h
Only in ../swoole-1.8.5-stable/include: sha1.h
Only in ./zan-extension/include: swAsyncIO.h
Only in ./zan-extension/include: swAtomic.h
Only in ./zan-extension/include: swBaseData.h
Only in ./zan-extension/include: swBaseOperator.h
Only in ./zan-extension/include: swClient.h
Only in ./zan-extension/include: swConnection.h
Only in ./zan-extension/include: swDNS.h
Only in ./zan-extension/include: swError.h
Only in ./zan-extension/include: swExecutor.h
Only in ./zan-extension/include: swFactory.h
Only in ./zan-extension/include: swGlobalDef.h
Only in ./zan-extension/include: swGlobalVars.h
Only in ./zan-extension/include: swHash.h
Only in ./zan-extension/include: swLock.h
Only in ./zan-extension/include: swLog.h
Only in ./zan-extension/include: swMemory
Only in ./zan-extension/include: swModule.h
Only in ./zan-extension/include: swPipe.h
Only in ./zan-extension/include: swPort.h
Only in ./zan-extension/include: swProtocol
Only in ./zan-extension/include: swReactor.h
Only in ./zan-extension/include: swSendfile.h
Only in ./zan-extension/include: swServer.h
Only in ./zan-extension/include: swSignal.h
Only in ./zan-extension/include: swSocket.h
Only in ./zan-extension/include: swTimer.h
Only in ./zan-extension/include: swUthash.h
Only in ./zan-extension/include: swWork.h
diff -r ./zan-extension/include/swoole.h ../swoole-1.8.5-stable/include/swoole.h
1,237c1,1849
< /*
<   +----------------------------------------------------------------------+
<   | Swoole                                                               |
<   +----------------------------------------------------------------------+
<   | This source file is subject to version 2.0 of the Apache license,    |
<   | that is bundled with this package in the file LICENSE, and is        |
<   | available through the world-wide-web at the following url:           |
<   | http://www.apache.org/licenses/LICENSE-2.0.html                      |
<   | If you did not receive a copy of the Apache2.0 license and are unable|
<   | to obtain it through the world-wide-web, please send a note to       |
<   | license@swoole.com so we can mail you a copy immediately.            |
<   +----------------------------------------------------------------------+
<   | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |
<   +----------------------------------------------------------------------+
< */
< 
< #ifndef SWOOLE_H_
< #define SWOOLE_H_
< 
< 
< #if defined(HAVE_CONFIG_H) && !defined(COMPILE_DL_SWOOLE)
< #include "config.h"
< #endif
< 
< #ifdef __cplusplus
< extern "C" {
< #endif
< 
< #ifndef _GNU_SOURCE
< #define _GNU_SOURCE
< #endif
< 
< #include <stdint.h>
< #include <fcntl.h>
< #include <unistd.h>
< #include <stdlib.h>
< #include <stdio.h>
< #include <errno.h>
< #include <string.h>
< #include <ctype.h>
< #include <signal.h>
< #include <assert.h>
< #include <time.h>
< #include <pthread.h>
< #include <sched.h>
< #include <sys/socket.h>
< #include <sys/mman.h>
< #include <sys/ipc.h>
< #include <sys/wait.h>
< #include <sys/un.h>
< #include <sys/types.h>
< #include <sys/utsname.h>
< 
< #ifdef SW_USE_OPENSSL
< #include <openssl/ssl.h>
< #endif
< 
< /*----------------------------------------------------------------------------*/
< #ifndef ulong
< #define ulong unsigned long
< #endif
< 
< typedef unsigned long ulong_t;
< 
< #if defined(__GNUC__)
< #if __GNUC__ >= 3
< #define sw_inline inline __attribute__((always_inline))
< #else
< #define sw_inline inline
< #endif
< #elif defined(_MSC_VER)
< #define sw_inline __forceinline
< #else
< #define sw_inline inline
< #endif
< 
< #if defined(MAP_ANON) && !defined(MAP_ANONYMOUS)
< #define MAP_ANONYMOUS MAP_ANON
< #endif
< 
< #ifndef SOCK_NONBLOCK
< #define SOCK_NONBLOCK O_NONBLOCK
< #endif
< 
< #ifndef CLOCK_REALTIME
< #define CLOCK_REALTIME 0
< #endif
< 
< #if !defined(__GNUC__) || __GNUC__ < 3
< #define __builtin_expect(x, expected_value) (x)
< #endif
< #ifndef likely
< #define likely(x)        __builtin_expect(!!(x), 1)
< #endif
< #ifndef unlikely
< #define unlikely(x)      __builtin_expect(!!(x), 0)
< #endif
< 
< #define SW_START_LINE  "-------------------------START----------------------------"
< #define SW_END_LINE    "-------------------------END------------------------------"
< #define SW_SPACE       ' '
< #define SW_CRLF        "\r\n"
< /*----------------------------------------------------------------------------*/
< 
< #include "swoole_config.h"
< 
< #define SW_TIMEO_SEC           0
< #define SW_TIMEO_USEC          3000000
< 
< #define SW_MAX_UINT            4294967295
< #define SW_MAX_INT             2147483647
< 
< #ifndef MAX
< #define MAX(a, b)              (a)>(b)?(a):(b);
< #endif
< #ifndef MIN
< #define MIN(a, b)              (a)<(b)?(a):(b);
< #endif
< 
< #define SW_STRL(s)             s, sizeof(s)
< #define SW_START_SLEEP         usleep(100000)  //sleep 1s,wait fork and pthread_create
< 
< #define METHOD_DEF(class,name,...)  class##_##name(class *object, ##__VA_ARGS__)
< #define METHOD(class,name,...)      class##_##name(object, ##__VA_ARGS__)
< 
< //-------------------------------------------------------------------------------
< #define SW_ASYNCERR			   1
< #define SW_OK                  0
< #define SW_ERR                -1
< #define SW_AGAIN              -2
< #define SW_BUSY               -3
< #define SW_DONE               -4
< #define SW_DECLINED           -5
< #define SW_ABORT              -6
< 
< //-------------------------------------------------------------------------------
< enum swReturnType
< {
<     SW_CONTINUE = 1,
<     SW_WAIT     = 2,
<     SW_CLOSE    = 3,
<     SW_ERROR    = 4,
<     SW_READY    = 5,
< };
< 
< //-------------------------------------------------------------------------------
< enum swFd_type
< {
<     SW_FD_TCP             = 0, //tcp socket
<     SW_FD_LISTEN          = 1, //server socket
<     SW_FD_CLOSE           = 2, //socket closed
<     SW_FD_ERROR           = 3, //socket error
<     SW_FD_UDP             = 4, //udp socket
<     SW_FD_PIPE            = 5, //pipe
<     SW_FD_WRITE           = 7, //fd can write
<     SW_FD_TIMER           = 8, //timer fd
<     SW_FD_AIO             = 9, //linux native aio
<     SW_FD_SIGNAL          = 11, //signalfd
<     SW_FD_DNS_RESOLVER    = 12, //dns resolver
<     SW_FD_INOTIFY         = 13, //server socket
<     SW_FD_USER            = 15, //SW_FD_USER or SW_FD_USER+n: for custom event
<     SW_FD_STREAM_CLIENT   = 16, //swClient stream
<     SW_FD_DGRAM_CLIENT    = 17, //swClient dgram
< };
< 
< enum swBool_type
< {
<     SW_TRUE = 1,
<     SW_FALSE = 0,
< };
< 
< //-------------------------------------------------------------------------------
< enum swServer_mode
< {
<     SW_MODE_BASE          =  1,
<     SW_MODE_THREAD        =  2,
<     SW_MODE_PROCESS       =  3,
<     SW_MODE_SINGLE        =  4,
< };
< 
< enum swCloseType
< {
< 	SW_CLOSE_PASSIVE = 32, 			///被动关闭
< 	SW_CLOSE_INITIATIVE,			///主动关闭
< };
< 
< enum swClientTimeoutType
< {
< 	SW_CLIENT_INVAILED_TIMEOUT = 0,
< 	SW_CLIENT_CONNECT_TIMEOUT = 1,
< 	SW_CLIENT_RECV_TIMEOUT = 2,
< };
< 
< 
< #define SW_MODE_PACKET		   0x10
< #define SW_SOCK_SSL            (1u << 9)
< #define SW_MAX_FDTYPE          32 //32 kinds of event
< 
< #define swYield()              sched_yield() //or usleep(1)
< 
< #ifndef uchar
< typedef unsigned char uchar;
< #endif
< 
< typedef struct
< {
<     uint32_t id;
<     uint32_t fd :24;
<     uint32_t reactor_id :8;
< } swSession;
< 
< typedef struct _swDataHead
< {
<     int fd;  //文件描述符
<     uint16_t len;  //长度
<     int16_t from_id;  //Reactor Id
<     uint8_t type;  //类型
<     uint8_t from_fd;
<     uint16_t worker_id;
< } swDataHead;
< 
< typedef struct _swUdpFd
< {
<     struct sockaddr addr;
<     int sock;
< } swUdpFd;
< 
< void swoole_init(void);
< void swoole_clean(void);
< void swoole_update_time(void);
< double swoole_microtime(void);
< 
< 
< #ifdef __cplusplus
< }
< #endif
< #endif /* SWOOLE_H_ */
---
> /*
>   +----------------------------------------------------------------------+
>   | Swoole                                                               |
>   +----------------------------------------------------------------------+
>   | This source file is subject to version 2.0 of the Apache license,    |
>   | that is bundled with this package in the file LICENSE, and is        |
>   | available through the world-wide-web at the following url:           |
>   | http://www.apache.org/licenses/LICENSE-2.0.html                      |
>   | If you did not receive a copy of the Apache2.0 license and are unable|
>   | to obtain it through the world-wide-web, please send a note to       |
>   | license@swoole.com so we can mail you a copy immediately.            |
>   +----------------------------------------------------------------------+
>   | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |
>   +----------------------------------------------------------------------+
> */
> 
> #ifndef SWOOLE_H_
> #define SWOOLE_H_
> 
> #if defined(HAVE_CONFIG_H) && !defined(COMPILE_DL_SWOOLE)
> #include "config.h"
> #endif
> 
> #ifdef __cplusplus
> extern "C" {
> #endif
> 
> #ifndef _GNU_SOURCE
> #define _GNU_SOURCE
> #endif
> 
> #include <fcntl.h>
> #include <unistd.h>
> #include <stdlib.h>
> #include <stdio.h>
> #include <errno.h>
> #include <string.h>
> #include <ctype.h>
> #include <signal.h>
> #include <assert.h>
> #include <time.h>
> #include <pthread.h>
> #include <sched.h>
> 
> #include <arpa/inet.h>
> #include <netinet/in.h>
> #include <netinet/tcp.h>
> #include <netdb.h>
> #include <sys/socket.h>
> #include <sys/time.h>
> #include <sys/select.h>
> #include <sys/mman.h>
> #include <sys/ipc.h>
> #include <sys/wait.h>
> #include <sys/un.h>
> #include <sys/types.h>
> #include <sys/utsname.h>
> 
> #ifdef __MACH__
> #include <mach/clock.h>
> #include <mach/mach_time.h>
> #include <sys/sysctl.h>
> 
> #define ORWL_NANO (+1.0E-9)
> #define ORWL_GIGA UINT64_C(1000000000)
> 
> static double orwl_timebase = 0.0;
> static uint64_t orwl_timestart = 0;
> 
> int clock_gettime(clock_id_t which_clock, struct timespec *t);
> #endif
> 
> #ifndef HAVE_DAEMON
> int daemon(int nochdir, int noclose);
> #endif
> 
> /*----------------------------------------------------------------------------*/
> #ifndef ulong
> #define ulong unsigned long
> #endif
> typedef unsigned long ulong_t;
> 
> #if defined(__GNUC__)
> #if __GNUC__ >= 3
> #define sw_inline inline __attribute__((always_inline))
> #else
> #define sw_inline inline
> #endif
> #elif defined(_MSC_VER)
> #define sw_inline __forceinline
> #else
> #define sw_inline inline
> #endif
> 
> #if defined(MAP_ANON) && !defined(MAP_ANONYMOUS)
> #define MAP_ANONYMOUS MAP_ANON
> #endif
> 
> #ifndef SOCK_NONBLOCK
> #define SOCK_NONBLOCK O_NONBLOCK
> #endif
> 
> #ifndef CLOCK_REALTIME
> #define CLOCK_REALTIME 0
> #endif
> 
> #if !defined(__GNUC__) || __GNUC__ < 3
> #define __builtin_expect(x, expected_value) (x)
> #endif
> #ifndef likely
> #define likely(x)        __builtin_expect(!!(x), 1)
> #endif
> #ifndef unlikely
> #define unlikely(x)      __builtin_expect(!!(x), 0)
> #endif
> 
> #define SW_START_LINE  "-------------------------START----------------------------"
> #define SW_END_LINE    "-------------------------END------------------------------"
> #define SW_SPACE       ' '
> #define SW_CRLF        "\r\n"
> /*----------------------------------------------------------------------------*/
> 
> #include "swoole_config.h"
> #include "atomic.h"
> #include "hashmap.h"
> #include "list.h"
> #include "heap.h"
> #include "RingQueue.h"
> #include "array.h"
> #include "error.h"
> 
> #define SW_TIMEO_SEC           0
> #define SW_TIMEO_USEC          3000000
> 
> #define SW_MAX_UINT            4294967295
> #define SW_MAX_INT             2147483647
> 
> #ifndef MAX
> #define MAX(a, b)              (a)>(b)?a:b;
> #endif
> #ifndef MIN
> #define MIN(a, b)              (a)<(b)?a:b;
> #endif
> 
> #define SW_STRL(s)             s, sizeof(s)
> #define SW_START_SLEEP         usleep(100000)  //sleep 1s,wait fork and pthread_create
> 
> #ifdef SW_MALLOC_DEBUG
> #define sw_malloc(__size)      malloc(__size);swWarn("malloc(%ld)", __size)
> #define sw_free(ptr)           if(ptr){free(ptr);ptr=NULL;swWarn("free");}
> #else
> #define sw_malloc              malloc
> #define sw_free(ptr)           if(ptr){free(ptr);ptr=NULL;}
> #endif
> 
> #define sw_calloc              calloc
> #define sw_realloc             realloc
> 
> #define METHOD_DEF(class,name,...)  class##_##name(class *object, ##__VA_ARGS__)
> #define METHOD(class,name,...)      class##_##name(object, ##__VA_ARGS__)
> //-------------------------------------------------------------------------------
> #define SW_OK                  0
> #define SW_ERR                -1
> #define SW_AGAIN              -2
> #define SW_BUSY               -3
> #define SW_DONE               -4
> #define SW_DECLINED           -5
> #define SW_ABORT              -6
> //-------------------------------------------------------------------------------
> enum swReturnType
> {
>     SW_CONTINUE = 1,
>     SW_WAIT     = 2,
>     SW_CLOSE    = 3,
>     SW_ERROR    = 4,
>     SW_READY    = 5,
> };
> //-------------------------------------------------------------------------------
> enum swFd_type
> {
>     SW_FD_TCP             = 0, //tcp socket
>     SW_FD_LISTEN          = 1, //server socket
>     SW_FD_CLOSE           = 2, //socket closed
>     SW_FD_ERROR           = 3, //socket error
>     SW_FD_UDP             = 4, //udp socket
>     SW_FD_PIPE            = 5, //pipe
>     SW_FD_WRITE           = 7, //fd can write
>     SW_FD_TIMER           = 8, //timer fd
>     SW_FD_AIO             = 9, //linux native aio
>     SW_FD_SIGNAL          = 11, //signalfd
>     SW_FD_DNS_RESOLVER    = 12, //dns resolver
>     SW_FD_INOTIFY         = 13, //server socket
>     SW_FD_USER            = 15, //SW_FD_USER or SW_FD_USER+n: for custom event
>     SW_FD_STREAM_CLIENT   = 16, //swClient stream
>     SW_FD_DGRAM_CLIENT    = 17, //swClient dgram
> };
> 
> enum swBool_type
> {
>     SW_TRUE = 1,
>     SW_FALSE = 0,
> };
> 
> enum swEvent_type
> {
>     SW_EVENT_DEAULT = 256,
>     SW_EVENT_READ = 1u << 9,
>     SW_EVENT_WRITE = 1u << 10,
>     SW_EVENT_ERROR = 1u << 11,
> };
> //-------------------------------------------------------------------------------
> enum swServer_mode
> {
>     SW_MODE_BASE          =  1,
>     SW_MODE_THREAD        =  2,
>     SW_MODE_PROCESS       =  3,
>     SW_MODE_SINGLE        =  4,
> };
> 
> #define SW_MODE_PACKET		0x10 
> //-------------------------------------------------------------------------------
> enum swSocket_type
> {
>     SW_SOCK_TCP          =  1,
>     SW_SOCK_UDP          =  2,
>     SW_SOCK_TCP6         =  3,
>     SW_SOCK_UDP6         =  4,
>     SW_SOCK_UNIX_DGRAM   =  5,  //unix sock dgram
>     SW_SOCK_UNIX_STREAM  =  6,  //unix sock stream
> };
> 
> #define SW_SOCK_SSL            (1u << 9)
> //-------------------------------------------------------------------------------
> enum swLog_level
> {
>     SW_LOG_DEBUG = 0,
>     SW_LOG_TRACE,
>     SW_LOG_INFO,
>     SW_LOG_NOTICE,
>     SW_LOG_WARNING,
>     SW_LOG_ERROR,
> 
> };
> //-------------------------------------------------------------------------------
> enum swFactory_dispatch_mode
> {
>     SW_DISPATCH_ROUND = 1,
>     SW_DISPATCH_FDMOD = 2,
>     SW_DISPATCH_QUEUE = 3,
>     SW_DISPATCH_IPMOD = 4,
>     SW_DISPATCH_UIDMOD = 5,
> };
> 
> enum swWorker_status
> {
>     SW_WORKER_BUSY = 1,
>     SW_WORKER_IDLE = 2,
>     SW_WORKER_DEL  = 3,
> };
> //-------------------------------------------------------------------------------
> 
> #define swWarn(str,...)        SwooleGS->lock.lock(&SwooleGS->lock);\
> snprintf(sw_error,SW_ERROR_MSG_SIZE,"%s: "str,__func__,##__VA_ARGS__);\
> swLog_put(SW_LOG_WARNING, sw_error);\
> SwooleGS->lock.unlock(&SwooleGS->lock)
> 
> #define swNotice(str,...)        SwooleGS->lock.lock(&SwooleGS->lock);\
> snprintf(sw_error,SW_ERROR_MSG_SIZE,str,##__VA_ARGS__);\
> swLog_put(SW_LOG_NOTICE, sw_error);\
> SwooleGS->lock.unlock(&SwooleGS->lock)
> 
> #define swError(str,...)       SwooleGS->lock.lock(&SwooleGS->lock);\
> snprintf(sw_error, SW_ERROR_MSG_SIZE, str, ##__VA_ARGS__);\
> swLog_put(SW_LOG_ERROR, sw_error);\
> SwooleGS->lock.unlock(&SwooleGS->lock);\
> exit(1)
> 
> #define swSysError(str,...) SwooleGS->lock.lock(&SwooleGS->lock);\
> snprintf(sw_error,SW_ERROR_MSG_SIZE,"%s(:%d): "str" Error: %s[%d].",__func__,__LINE__,##__VA_ARGS__,strerror(errno),errno);\
> swLog_put(SW_LOG_ERROR, sw_error);\
> SwooleGS->lock.unlock(&SwooleGS->lock)
> 
> #define swoole_error_log(level, errno, str, ...)      do{SwooleG.error=errno;\
>     if (level >= SwooleG.log_level){\
>     snprintf(sw_error, SW_ERROR_MSG_SIZE, "%s (ERROR %d): "str,__func__,errno,##__VA_ARGS__);\
>     SwooleGS->lock.lock(&SwooleGS->lock);\
>     swLog_put( SW_LOG_ERROR, sw_error);\
>     SwooleGS->lock.unlock(&SwooleGS->lock);}}while(0)
> 
> #ifdef SW_DEBUG_REMOTE_OPEN
> #define swDebug(str,...) int __debug_log_n = snprintf(sw_error,SW_ERROR_MSG_SIZE,str,##__VA_ARGS__);\
> write(SwooleG.debug_fd, sw_error, __debug_log_n);
> #else
> #define swDebug(str,...)
> #endif
> 
> #ifdef SW_DEBUG
> #define swTrace(str,...)       {printf("[%s:%d@%s]"str"\n",__FILE__,__LINE__,__func__,##__VA_ARGS__);}
> //#define swWarn(str,...)        {printf("[%s:%d@%s]"str"\n",__FILE__,__LINE__,__func__,##__VA_ARGS__);}
> #else
> #define swTrace(str,...)
> //#define swWarn(str,...)        {printf(sw_error);}
> #endif
> 
> enum swTraceType
> {
>     SW_TRACE_SERVER  = 1,
>     SW_TRACE_CLIENT  = 2,
>     SW_TRACE_BUFFER  = 3,
>     SW_TRACE_CONN    = 4,
>     SW_TRACE_EVENT   = 5,
>     SW_TRACE_WORKER,
>     SW_TRACE_MEMORY,
>     SW_TRACE_REACTOR,
>     SW_TRACE_PHP,
>     SW_TRACE_HTTP2,
> };
> 
> #if SW_LOG_TRACE_OPEN == 1
> #define swTraceLog(id,str,...)      SwooleGS->lock.lock(&SwooleGS->lock);\
> snprintf(sw_error,SW_ERROR_MSG_SIZE,"%s: "str,__func__,##__VA_ARGS__);\
> swLog_put(SW_LOG_TRACE, sw_error);\
> SwooleGS->lock.unlock(&SwooleGS->lock)
> #elif SW_LOG_TRACE_OPEN == 0
> #define swTraceLog(id,str,...)
> #else
> #define swTraceLog(id,str,...)      if (id==SW_LOG_TRACE_OPEN) {SwooleGS->lock.lock(&SwooleGS->lock);\
> snprintf(sw_error,SW_ERROR_MSG_SIZE,"%s: "str,__func__,##__VA_ARGS__);\
> swLog_put(SW_LOG_TRACE, sw_error);\
> SwooleGS->lock.unlock(&SwooleGS->lock);}
> #endif
> 
> #define swYield()              sched_yield() //or usleep(1)
> //#define swYield()              usleep(500000)
> #define SW_MAX_FDTYPE          32 //32 kinds of event
> #define SW_ERROR_MSG_SIZE      512
> 
> //------------------------------Base--------------------------------
> #ifndef uchar
> typedef unsigned char uchar;
> #endif
> 
> #ifdef SW_USE_OPENSSL
> #include <openssl/ssl.h>
> #endif
> 
> typedef void (*swDestructor)(void *data);
> typedef void (*swCallback)(void *data);
> 
> typedef struct
> {
>     uint32_t id;
>     uint32_t fd :24;
>     uint32_t reactor_id :8;
> } swSession;
> 
> typedef struct _swString
> {
>     size_t length;
>     size_t size;
>     off_t offset;
>     char *str;
> } swString;
> 
> typedef void* swObject;
> 
> typedef struct _swLinkedList_node
> {
>     struct _swLinkedList_node *prev;
>     struct _swLinkedList_node *next;
>     ulong_t priority;
>     void *data;
> } swLinkedList_node;
> 
> typedef struct
> {
>     uint32_t num;
>     uint8_t type;
>     swLinkedList_node *head;
>     swLinkedList_node *tail;
>     swDestructor dtor;
> } swLinkedList;
> 
> typedef struct
> {
>     union
>     {
>         struct sockaddr_in inet_v4;
>         struct sockaddr_in6 inet_v6;
>         struct sockaddr_un un;
>     } addr;
>     socklen_t len;
> } swSocketAddress;
> 
> 
> typedef struct _swConnection
> {
>     /**
>      * file descript
>      */
>     int fd;
> 
>     /**
>      * session id
>      */
>     uint32_t session_id :24;
> 
>     /**
>      * socket type, SW_SOCK_TCP or SW_SOCK_UDP
>      */
>     uint8_t socket_type;
> 
>     /**
>      * fd type, SW_FD_TCP or SW_FD_PIPE or SW_FD_TIMERFD
>      */
>     uint8_t fdtype;
> 
>     int events;
> 
>     /**
>      * is active
>      * system fd must be 0. en: timerfd, signalfd, listen socket
>      */
>     uint32_t active :1;
> 
>     uint32_t connect_notify :1;
> 
>     /**
>      * for SWOOLE_BASE mode.
>      */
>     uint32_t close_notify :1;
> 
>     uint32_t recv_wait :1;
>     uint32_t send_wait :1;
> 
>     uint32_t direct_send :1;
>     uint32_t ssl_send :1;
> 
>     /**
>      * protected connection, cannot be closed by heartbeat thread.
>      */
>     uint32_t protect :1;
> 
>     uint32_t close_wait :1;
>     uint32_t closed :1;
>     uint32_t closing :1;
>     uint32_t close_force :1;
>     uint32_t close_reset :1;
> 
>     uint32_t removed :1;
>     uint32_t overflow :1;
> 
>     uint32_t tcp_nopush :1;
>     uint32_t tcp_nodelay :1;
> 
>     uint32_t ssl_want_read :1;
>     uint32_t ssl_want_write :1;
> 
>     uint32_t http_upgrade :1;
>     uint32_t http2_stream :1;
> 
>     /**
>      * ReactorThread id
>      */
>     uint16_t from_id;
> 
>     /**
>      * from which socket fd
>      */
>     uint16_t from_fd;
> 
>     /**
>      * socket address
>      */
>     swSocketAddress info;
> 
>     /**
>      * link any thing, for kernel, do not use with application.
>      */
>     void *object;
> 
>     /**
>      * input buffer
>      */
>     struct _swBuffer *in_buffer;
> 
>     /**
>      * output buffer
>      */
>     struct _swBuffer *out_buffer;
> 
>     /**
>      * connect time(seconds)
>      */
>     time_t connect_time;
> 
>     /**
>      * received time with last data
>      */
>     time_t last_time;
> 
>     /**
>      * bind uid
>      */
>     long uid;
> 
>     /**
>      * memory buffer size;
>      */
>     int buffer_size;
> 
>     /**
>      *  upgarde websocket
>      */
>     uint8_t websocket_status;
> 
> #ifdef SW_USE_OPENSSL
>     SSL *ssl;
>     uint32_t ssl_state;
>     swString ssl_client_cert;
> #endif
>     sw_atomic_t lock;
> } swConnection;
> 
> typedef struct _swProtocol
> {
>     /* one package: eof check */
>     uint8_t split_by_eof;
>     uint8_t package_eof_len;  //数据缓存结束符长度
>     char package_eof[SW_DATA_EOF_MAXLEN + 1];  //数据缓存结束符
> 
>     char package_length_type;  //length field type
>     uint8_t package_length_size;
>     uint16_t package_length_offset;  //第几个字节开始表示长度
>     uint16_t package_body_offset;  //第几个字节开始计算长度
>     uint32_t package_max_length;
> 
>     int (*onPackage)(swConnection *conn, char *data, uint32_t length);
>     int (*get_package_length)(struct _swProtocol *protocol, swConnection *conn, char *data, uint32_t length);
> } swProtocol;
> //------------------------------String--------------------------------
> #define swoole_tolower(c)      (u_char) ((c >= 'A' && c <= 'Z') ? (c | 0x20) : c)
> #define swoole_toupper(c)      (u_char) ((c >= 'a' && c <= 'z') ? (c & ~0x20) : c)
> 
> size_t swoole_utf8_length(u_char *p, size_t n);
> size_t swoole_utf8_length(u_char *p, size_t n);
> 
> static sw_inline size_t swoole_size_align(size_t size, int pagesize)
> {
>     return size + (pagesize - (size % pagesize));
> }
> 
> static sw_inline void swString_clear(swString *str)
> {
>     str->length = 0;
>     str->offset = 0;
> }
> 
> swString *swString_new(size_t size);
> swString *swString_dup(const char *src_str, int length);
> swString *swString_dup2(swString *src);
> 
> void swString_print(swString *str);
> void swString_free(swString *str);
> int swString_append(swString *str, swString *append_str);
> int swString_append_ptr(swString *str, char *append_str, int length);
> 
> int swString_extend(swString *str, size_t new_size);
> 
> #define swString_length(s) (s->length)
> #define swString_ptr(s) (s->str)
> //------------------------------Base--------------------------------
> 
> typedef struct _swDataHead
> {
>     int fd;  //文件描述符
>     uint16_t len;  //长度
>     int16_t from_id;  //Reactor Id
>     uint8_t type;  //类型
>     uint8_t from_fd;
> } swDataHead;
> 
> typedef struct _swEvent
> {
>     int fd;
>     int16_t from_id;
>     uint8_t type;
>     swConnection *socket;
> } swEvent;
> 
> typedef struct _swEventData
> {
>     swDataHead info;
>     char data[SW_BUFFER_SIZE];
> } swEventData;
> 
> typedef struct _swDgramPacket
> {
>     union
>     {
>         struct in6_addr v6;
>         struct in_addr v4;
>         struct
>         {
>             uint16_t path_length;
>         } un;
>     } addr;
>     uint16_t port;
>     uint32_t length;
>     char data[0];
> } swDgramPacket;
> 
> typedef struct _swSendData
> {
>     swDataHead info;
>     /**
>      * for big package
>      */
>     uint32_t length;
>     char *data;
> } swSendData;
> 
> typedef void * (*swThreadStartFunc)(void *);
> typedef int (*swHandle)(swEventData *buf);
> typedef void (*swSignalFunc)(int);
> typedef struct _swReactor swReactor;
> 
> typedef int (*swReactor_handle)(swReactor *reactor, swEvent *event);
> //------------------Pipe--------------------
> typedef struct _swPipe
> {
>     void *object;
>     int blocking;
>     double timeout;
> 
>     int (*read)(struct _swPipe *, void *recv, int length);
>     int (*write)(struct _swPipe *, void *send, int length);
>     int (*getFd)(struct _swPipe *, int isWriteFd);
>     int (*close)(struct _swPipe *);
> } swPipe;
> 
> int swPipeBase_create(swPipe *p, int blocking);
> int swPipeEventfd_create(swPipe *p, int blocking, int semaphore, int timeout);
> int swPipeUnsock_create(swPipe *p, int blocking, int protocol);
> 
> static inline int swPipeNotify_auto(swPipe *p, int blocking, int semaphore)
> {
> #ifdef HAVE_EVENTFD
>     return swPipeEventfd_create(p, blocking, semaphore, 0);
> #else
>     return swPipeBase_create(p, blocking);
> #endif
> }
> 
> void swBreakPoint(void);
> 
> //------------------Queue--------------------
> typedef struct _swQueue_Data
> {
>     long mtype; /* type of received/sent message */
>     char mdata[sizeof(swEventData)]; /* text of the message */
> } swQueue_data;
> 
> typedef struct _swMsgQueue
> {
>     int blocking;
>     int msg_id;
>     int ipc_wait;
>     uint8_t delete;
>     long type;
> } swMsgQueue;
> 
> int swMsgQueue_create(swMsgQueue *q, int wait, key_t msg_key, long type);
> int swMsgQueue_push(swMsgQueue *p, swQueue_data *in, int data_length);
> int swMsgQueue_pop(swMsgQueue *p, swQueue_data *out, int buffer_length);
> int swMsgQueue_stat(swMsgQueue *q, int *queue_num, int *queue_bytes);
> void swMsgQueue_free(swMsgQueue *p);
> 
> //------------------Lock--------------------------------------
> enum SW_LOCKS
> {
>     SW_RWLOCK = 1,
> #define SW_RWLOCK SW_RWLOCK
>     SW_FILELOCK = 2,
> #define SW_FILELOCK SW_FILELOCK
>     SW_MUTEX = 3,
> #define SW_MUTEX SW_MUTEX
>     SW_SEM = 4,
> #define SW_SEM SW_SEM
>     SW_SPINLOCK = 5,
> #define SW_SPINLOCK SW_SPINLOCK
>     SW_ATOMLOCK = 6,
> #define SW_ATOMLOCK SW_ATOMLOCK
> };
> 
> //文件锁
> typedef struct _swFileLock
> {
>     struct flock lock_t;
>     int fd;
> } swFileLock;
> 
> //互斥锁
> typedef struct _swMutex
> {
>     pthread_mutex_t _lock;
>     pthread_mutexattr_t attr;
> } swMutex;
> 
> #ifdef HAVE_RWLOCK
> typedef struct _swRWLock
> {
>     pthread_rwlock_t _lock;
>     pthread_rwlockattr_t attr;
> 
> } swRWLock;
> #endif
> 
> #ifdef HAVE_SPINLOCK
> typedef struct _swSpinLock
> {
>     pthread_spinlock_t lock_t;
> } swSpinLock;
> #endif
> 
> typedef struct _swAtomicLock
> {
>     sw_atomic_t lock_t;
>     uint32_t spin;
> } swAtomicLock;
> 
> typedef struct _swSem
> {
>     key_t key;
>     int semid;
> } swSem;
> 
> typedef struct _swLock
> {
> 	int type;
>     union
>     {
>         swMutex mutex;
> #ifdef HAVE_RWLOCK
>         swRWLock rwlock;
> #endif
> #ifdef HAVE_SPINLOCK
>         swSpinLock spinlock;
> #endif
>         swFileLock filelock;
>         swSem sem;
>         swAtomicLock atomlock;
>     } object;
> 
>     int (*lock_rd)(struct _swLock *);
>     int (*lock)(struct _swLock *);
>     int (*unlock)(struct _swLock *);
>     int (*trylock_rd)(struct _swLock *);
>     int (*trylock)(struct _swLock *);
>     int (*free)(struct _swLock *);
> } swLock;
> 
> //Thread Condition
> typedef struct _swCond
> {
>     swLock lock;
>     pthread_cond_t cond;
> 
>     int (*wait)(struct _swCond *object);
>     int (*timewait)(struct _swCond *object, long, long);
>     int (*notify)(struct _swCond *object);
>     int (*broadcast)(struct _swCond *object);
>     void (*free)(struct _swCond *object);
> } swCond;
> 
> #define SW_SHM_MMAP_FILE_LEN  64
> 
> typedef struct _swShareMemory_mmap
> {
>     int size;
>     char mapfile[SW_SHM_MMAP_FILE_LEN];
>     int tmpfd;
>     int key;
>     int shmid;
>     void *mem;
> } swShareMemory;
> 
> void *swShareMemory_mmap_create(swShareMemory *object, int size, char *mapfile);
> void *swShareMemory_sysv_create(swShareMemory *object, int size, int key);
> int swShareMemory_sysv_free(swShareMemory *object, int rm);
> int swShareMemory_mmap_free(swShareMemory *object);
> 
> //-------------------memory manager-------------------------
> typedef struct _swMemoryPool
> {
> 	void *object;
> 	void* (*alloc)(struct _swMemoryPool *pool, uint32_t size);
> 	void (*free)(struct _swMemoryPool *pool, void *ptr);
> 	void (*destroy)(struct _swMemoryPool *pool);
> } swMemoryPool;
> 
> typedef struct _swFixedPool_slice
> {
>     uint8_t lock;
>     struct _swFixedPool_slice *next;
>     struct _swFixedPool_slice *pre;
>     char data[0];
> 
> } swFixedPool_slice;
> 
> typedef struct _swFixedPool
> {
>     void *memory;
>     size_t size;
> 
>     swFixedPool_slice *head;
>     swFixedPool_slice *tail;
> 
>     /**
>      * total memory size
>      */
>     uint32_t slice_num;
> 
>     /**
>      * memory usage
>      */
>     uint32_t slice_use;
> 
>     /**
>      * Fixed slice size, not include the memory used by swFixedPool_slice
>      */
>     uint32_t slice_size;
> 
>     /**
>      * use shared memory
>      */
>     uint8_t shared;
> 
> } swFixedPool;
> /**
>  * FixedPool, random alloc/free fixed size memory
>  */
> swMemoryPool* swFixedPool_new(uint32_t slice_num, uint32_t slice_size, uint8_t shared);
> swMemoryPool* swFixedPool_new2(uint32_t slice_size, void *memory, size_t size);
> swMemoryPool* swMalloc_new();
> 
> /**
>  * RingBuffer, In order for malloc / free
>  */
> swMemoryPool *swRingBuffer_new(uint32_t size, uint8_t shared);
> 
> /**
>  * Global memory, the program life cycle only malloc / free one time
>  */
> swMemoryPool* swMemoryGlobal_new(int pagesize, char shared);
> 
> void swFixedPool_debug(swMemoryPool *pool);
> 
> /**
>  * alloc shared memory
>  */
> void* sw_shm_malloc(size_t size);
> void sw_shm_free(void *ptr);
> void* sw_shm_calloc(size_t num, size_t _size);
> void* sw_shm_realloc(void *ptr, size_t new_size);
> #ifdef HAVE_RWLOCK
> int swRWLock_create(swLock *lock, int use_in_process);
> #endif
> int swSem_create(swLock *lock, key_t key);
> int swMutex_create(swLock *lock, int use_in_process);
> int swMutex_lockwait(swLock *lock, int timeout_msec);
> int swFileLock_create(swLock *lock, int fd);
> #ifdef HAVE_SPINLOCK
> int swSpinLock_create(swLock *object, int spin);
> #endif
> int swAtomicLock_create(swLock *object, int spin);
> int swCond_create(swCond *cond);
> 
> typedef struct _swThreadParam
> {
> 	void *object;
> 	int pti;
> } swThreadParam;
> 
> extern int16_t sw_errno;
> extern char sw_error[SW_ERROR_MSG_SIZE];
> 
> enum swProcessType
> {
>     SW_PROCESS_MASTER     = 1,
>     SW_PROCESS_WORKER     = 2,
>     SW_PROCESS_MANAGER    = 3,
>     SW_PROCESS_TASKWORKER = 4,
>     SW_PROCESS_USERWORKER = 5,
> };
> 
> #define swIsMaster()          (SwooleG.process_type==SW_PROCESS_MASTER)
> #define swIsWorker()          (SwooleG.process_type==SW_PROCESS_WORKER)
> #define swIsTaskWorker()      (SwooleG.process_type==SW_PROCESS_TASKWORKER)
> #define swIsManager()         (SwooleG.process_type==SW_PROCESS_MANAGER)
> 
> //----------------------tool function---------------------
> int swLog_init(char *logfile);
> void swLog_put(int level, char *cnt);
> void swLog_free(void);
> #define sw_log(str,...)       {snprintf(sw_error,SW_ERROR_MSG_SIZE,str,##__VA_ARGS__);swLog_put(SW_LOG_INFO, sw_error);}
> 
> uint64_t swoole_hash_key(char *str, int str_len);
> uint32_t swoole_common_multiple(uint32_t u, uint32_t v);
> uint32_t swoole_common_divisor(uint32_t u, uint32_t v);
> 
> static sw_inline uint16_t swoole_swap_endian16(uint16_t x)
> {
>     return (((x & 0xff) << 8) | ((x & 0xff00) >> 8));
> }
> 
> static sw_inline uint32_t swoole_swap_endian32(uint32_t x)
> {
>     return (((x & 0xff) << 24) | ((x & 0xff00) << 8) | ((x & 0xff0000) >> 8) | ((x & 0xff000000) >> 24));
> }
> 
> static sw_inline int32_t swoole_unpack(char type, void *data)
> {
>     switch(type)
>     {
>     /*-------------------------16bit-----------------------------*/
>     /**
>      * signed short (always 16 bit, machine byte order)
>      */
>     case 's':
>         return *((int16_t *) data);
>     /**
>      * unsigned short (always 16 bit, machine byte order)
>      */
>     case 'S':
>         return *((uint16_t *) data);
>     /**
>      * unsigned short (always 16 bit, big endian byte order)
>      */
>     case 'n':
>         return ntohs(*((uint16_t *) data));
>     /**
>      * unsigned short (always 32 bit, little endian byte order)
>      */
>     case 'v':
>         return swoole_swap_endian16(ntohs(*((uint16_t *) data)));
> 
>     /*-------------------------32bit-----------------------------*/
>     /**
>      * unsigned long (always 32 bit, machine byte order)
>      */
>     case 'L':
>         return *((uint32_t *) data);
>     /**
>      * signed long (always 32 bit, machine byte order)
>      */
>     case 'l':
>         return *((int *) data);
>     /**
>      * unsigned long (always 32 bit, big endian byte order)
>      */
>     case 'N':
>         return ntohl(*((uint32_t *) data));
>     /**
>      * unsigned short (always 32 bit, little endian byte order)
>      */
>     case 'V':
>         return swoole_swap_endian32(ntohl(*((uint32_t *) data)));
> 
>     default:
>         return *((uint32_t *) data);
>     }
> }
> 
> static inline char* swoole_strnstr(char *haystack, char *needle, uint32_t length)
> {
>     int i;
>     uint32_t needle_length = strlen(needle);
>     assert(needle_length > 0);
> 
>     for (i = 0; i < (int) (length - needle_length + 1); i++)
>     {
>         if ((haystack[0] == needle[0]) && (0 == memcmp(haystack, needle, needle_length)))
>         {
>             return (char *) haystack;
>         }
>         haystack++;
>     }
> 
>     return NULL;
> }
> 
> static inline int swoole_strnpos(char *haystack, uint32_t haystack_length, char *needle, uint32_t needle_length)
> {
>     assert(needle_length > 0);
>     uint32_t i;
> 
>     for (i = 0; i < (int) (haystack_length - needle_length + 1); i++)
>     {
>         if ((haystack[0] == needle[0]) && (0 == memcmp(haystack, needle, needle_length)))
>         {
>             return i;
>         }
>         haystack++;
>     }
> 
>     return -1;
> }
> 
> static inline int swoole_strrnpos(char *haystack, char *needle, uint32_t length)
> {
>     uint32_t needle_length = strlen(needle);
>     assert(needle_length > 0);
>     uint32_t i;
>     haystack += (length - needle_length);
> 
>     for (i = length - needle_length; i > 0; i--)
>     {
>         if ((haystack[0] == needle[0]) && (0 == memcmp(haystack, needle, needle_length)))
>         {
>             return i;
>         }
>         haystack--;
>     }
> 
>     return -1;
> }
> 
> static inline void swoole_strtolower(char *str, int length)
> {
>     char *c, *e;
> 
>     c = str;
>     e = c + length;
> 
>     while (c < e)
>     {
>         *c = tolower(*c);
>         c++;
>     }
> }
> 
> int swoole_itoa(char *buf, long value);
> void swoole_dump_bin(char *data, char type, int size);
> void swoole_dump_hex(char *data, int outlen);
> int swoole_type_size(char type);
> int swoole_mkdir_recursive(const char *dir);
> char* swoole_dirname(char *file);
> void swoole_dump_ascii(char *data, int size);
> int swoole_sync_writefile(int fd, void *data, int len);
> int swoole_sync_readfile(int fd, void *buf, int len);
> int swoole_rand(int min, int max);
> int swoole_system_random(int min, int max);
> long swoole_file_get_size(FILE *fp);
> int swoole_tmpfile(char *filename);
> swString* swoole_file_get_contents(char *filename);
> void swoole_open_remote_debug(void);
> char *swoole_dec2hex(int value, int base);
> int swoole_version_compare(char *version1, char *version2);
> #ifdef HAVE_EXECINFO
> void swoole_print_trace(void);
> #endif
> void swoole_ioctl_set_block(int sock, int nonblock);
> void swoole_fcntl_set_block(int sock, int nonblock);
> 
> //----------------------core function---------------------
> int swSocket_set_timeout(int sock, double timeout);
> int swWrite(int, void *, int);
> 
> static sw_inline int swSocket_is_dgram(uint8_t type)
> {
>     return (type == SW_SOCK_UDP || type == SW_SOCK_UDP6 || type == SW_SOCK_UNIX_DGRAM);
> }
> 
> static sw_inline int swSocket_is_stream(uint8_t type)
> {
>     return (type == SW_SOCK_TCP || type == SW_SOCK_TCP6 || type == SW_SOCK_UNIX_STREAM);
> }
> 
> #ifdef SW_USE_IOCTL
> #define swSetNonBlock(sock)   swoole_ioctl_set_block(sock, 1)
> #define swSetBlock(sock)      swoole_ioctl_set_block(sock, 0)
> #else
> #define swSetNonBlock(sock)   swoole_fcntl_set_block(sock, 1)
> #define swSetBlock(sock)      swoole_fcntl_set_block(sock, 0)
> #endif
> 
> void swoole_init(void);
> void swoole_clean(void);
> void swoole_update_time(void);
> double swoole_microtime(void);
> void swoole_rtrim(char *str, int len);
> 
> static sw_inline uint64_t swoole_hton64(uint64_t host)
> {
>     uint64_t ret = 0;
>     uint32_t high, low;
> 
>     low = host & 0xFFFFFFFF;
>     high = (host >> 32) & 0xFFFFFFFF;
>     low = htonl(low);
>     high = htonl(high);
> 
>     ret = low;
>     ret <<= 32;
>     ret |= high;
>     return ret;
> }
> 
> static sw_inline uint64_t swoole_ntoh64(uint64_t net)
> {
>     uint64_t ret = 0;
>     uint32_t high, low;
> 
>     low = net & 0xFFFFFFFF;
>     high = (net >> 32) & 0xFFFFFFFF;
>     low = ntohl(low);
>     high = ntohl(high);
>     ret = low;
>     ret <<= 32;
>     ret |= high;
>     return ret;
> }
> 
> int swSocket_create(int type);
> int swSocket_bind(int sock, int type, char *host, int port);
> int swSocket_wait(int fd, int timeout_ms, int events);
> void swSocket_clean(int fd);
> int swSocket_sendto_blocking(int fd, void *__buf, size_t __n, int flag, struct sockaddr *__addr, socklen_t __addr_len);
> int swSocket_set_buffer_size(int fd, int buffer_size);
> int swSocket_udp_sendto(int server_sock, char *dst_ip, int dst_port, char *data, uint32_t len);
> int swSocket_udp_sendto6(int server_sock, char *dst_ip, int dst_port, char *data, uint32_t len);
> int swSocket_sendfile_sync(int sock, char *filename, double timeout);
> int swSocket_write_blocking(int __fd, void *__data, int __len);
> 
> static sw_inline int swWaitpid(pid_t __pid, int *__stat_loc, int __options)
> {
>     int ret;
>     do
>     {
>         ret = waitpid(__pid, __stat_loc, __options);
>         if (ret < 0 && errno == EINTR)
>         {
>             continue;
>         }
>         break;
>     } while(1);
>     return ret;
> }
> 
> static sw_inline int swKill(pid_t __pid, int __sig)
> {
>     int ret;
>     do
>     {
>         ret = kill(__pid, __sig);
>         if (ret < 0 && errno == EINTR)
>         {
>             continue;
>         }
>         break;
>     } while (1);
>     return ret;
> }
> 
> #if defined(TCP_NOPUSH) || defined(TCP_CORK)
> #define HAVE_TCP_NOPUSH
> #ifdef TCP_NOPUSH
> static sw_inline int swSocket_tcp_nopush(int sock, int nopush)
> {
>     return setsockopt(sock, IPPROTO_TCP, TCP_NOPUSH, (const void *) &nopush, sizeof(int));
> }
> 
> #elif defined(TCP_CORK)
> static sw_inline int swSocket_tcp_nopush(int sock, int nopush)
> {
>     return setsockopt(sock, IPPROTO_TCP, TCP_CORK, (const void *) &nopush, sizeof(int));
> }
> #endif
> #else
> #define swSocket_tcp_nopush(sock, nopush)
> #endif
> 
> void swFloat2timeval(float timeout, long int *sec, long int *usec);
> swSignalFunc swSignal_set(int sig, swSignalFunc func, int restart, int mask);
> void swSignal_add(int signo, swSignalFunc func);
> void swSignal_callback(int signo);
> void swSignal_clear(void);
> void swSignal_none(void);
> 
> #ifdef HAVE_SIGNALFD
> void swSignalfd_init();
> int swSignalfd_setup(swReactor *reactor);
> #endif
> 
> typedef struct _swDefer_callback
> {
>     struct _swDefer_callback *next, *prev;
>     swCallback callback;
>     void *data;
> } swDefer_callback;
> 
> struct _swReactor
> {
>     void *object;
>     void *ptr;  //reserve
> 
>     /**
>      * last signal number
>      */
>     int singal_no;
> 
>     uint32_t event_num;
>     uint32_t max_event_num;
> 
>     uint32_t check_timer :1;
>     uint32_t running :1;
> 
>     /**
>      * disable accept new connection
>      */
>     uint32_t disable_accept :1;
> 
>     uint32_t check_signalfd :1;
> 
>     /**
>      * multi-thread reactor, cannot realloc sockets.
>      */
>     uint32_t thread :1;
> 
> 	/**
> 	 * reactor->wait timeout (millisecond) or -1
> 	 */
> 	int32_t timeout_msec;
> 
> 	uint16_t id; //Reactor ID
> 	uint16_t flag; //flag
> 
>     uint32_t max_socket;
> 
>     /**
>      * for thread
>      */
>     swConnection *socket_list;
> 
>     /**
>      * for process
>      */
>     swArray *socket_array;
> 
>     swReactor_handle handle[SW_MAX_FDTYPE];        //默认事件
>     swReactor_handle write_handle[SW_MAX_FDTYPE];  //扩展事件1(一般为写事件)
>     swReactor_handle error_handle[SW_MAX_FDTYPE];  //扩展事件2(一般为错误事件,如socket关闭)
> 
>     int (*add)(swReactor *, int fd, int fdtype);
>     int (*set)(swReactor *, int fd, int fdtype);
>     int (*del)(swReactor *, int fd);
>     int (*wait)(swReactor *, struct timeval *);
>     void (*free)(swReactor *);
> 
>     int (*setHandle)(swReactor *, int fdtype, swReactor_handle);
>     swDefer_callback *defer_callback_list;
> 
>     void (*onTimeout)(swReactor *);
>     void (*onFinish)(swReactor *);
> 
>     void (*enable_accept)(swReactor *);
> 
>     int (*write)(swReactor *, int, void *, int);
>     int (*close)(swReactor *, int);
>     int (*defer)(swReactor *, swCallback, void *);
> };
> 
> typedef struct _swWorker swWorker;
> typedef struct _swThread swThread;
> typedef struct _swProcessPool swProcessPool;
> 
> struct _swWorker
> {
> 	/**
> 	 * worker process
> 	 */
> 	pid_t pid;
> 
> 	/**
> 	 * worker thread
> 	 */
> 	pthread_t tid;
> 
> 	swProcessPool *pool;
> 
> 	swMemoryPool *pool_output;
> 
> 	swMsgQueue *queue;
> 
> 	/**
> 	 * redirect stdout to pipe_master
> 	 */
> 	uint8_t redirect_stdout;
> 
> 	/**
>      * redirect stdin to pipe_worker
>      */
>     uint8_t redirect_stdin;
> 
>     /**
>      * redirect stderr to pipe_worker
>      */
>     uint8_t redirect_stderr;
> 
> 	/**
> 	 * worker status, IDLE or BUSY
> 	 */
>     uint8_t status;
>     uint8_t type;
>     uint8_t ipc_mode;
> 
>     uint8_t deleted;
>     uint8_t child_process;
> 
>     /**
>      * tasking num
>      */
>     sw_atomic_t tasking_num;
> 
> 	/**
> 	 * worker id
> 	 */
> 	uint32_t id;
> 
> 	swLock lock;
> 
> 	void *send_shm;
> 
> 	swPipe *pipe_object;
> 
> 	int pipe_master;
> 	int pipe_worker;
> 
> 	int pipe;
> 	void *ptr;
> 	void *ptr2;
> };
> 
> struct _swProcessPool
> {
>     /**
>      * reloading
>      */
>     uint8_t reloading;
>     uint8_t reload_flag;
>     uint8_t dispatch_mode;
> 
>     /**
>      * process type
>      */
>     uint8_t type;
> 
>     /**
>      * worker->id = start_id + i
>      */
>     uint16_t start_id;
> 
>     /**
>      * use message queue IPC
>      */
>     uint8_t use_msgqueue;
>     /**
>      * message queue key
>      */
>     key_t msgqueue_key;
> 
>     int worker_num;
>     int max_request;
> 
>     int (*onTask)(struct _swProcessPool *pool, swEventData *task);
> 
>     void (*onWorkerStart)(struct _swProcessPool *pool, int worker_id);
>     void (*onWorkerStop)(struct _swProcessPool *pool, int worker_id);
> 
>     int (*main_loop)(struct _swProcessPool *pool, swWorker *worker);
>     int (*onWorkerNotFound)(struct _swProcessPool *pool, pid_t pid);
> 
>     sw_atomic_t round_id;
>     sw_atomic_t run_worker_num;
> 
>     swWorker *workers;
>     swPipe *pipes;
>     swHashMap *map;
>     swReactor *reactor;
>     swMsgQueue *queue;
> 
>     void *ptr;
>     void *ptr2;
> };
> 
> //----------------------------------------Reactor---------------------------------------
> static sw_inline int swReactor_error(swReactor *reactor)
> {
>     switch (errno)
>     {
>     case EINTR:
>         if (reactor->singal_no)
>         {
>             swSignal_callback(reactor->singal_no);
>             reactor->singal_no = 0;
>         }
>         return SW_OK;
>     }
>     return SW_ERR;
> }
> 
> static sw_inline int swReactor_event_read(int fdtype)
> {
>     return (fdtype < SW_EVENT_DEAULT) || (fdtype & SW_EVENT_READ);
> }
> 
> static sw_inline int swReactor_event_write(int fdtype)
> {
>     return fdtype & SW_EVENT_WRITE;
> }
> 
> static sw_inline int swReactor_event_error(int fdtype)
> {
>     return fdtype & SW_EVENT_ERROR;
> }
> 
> static sw_inline int swReactor_fdtype(int fdtype)
> {
>     return fdtype & (~SW_EVENT_READ) & (~SW_EVENT_WRITE) & (~SW_EVENT_ERROR);
> }
> 
> static sw_inline int swReactor_events(int fdtype)
> {
>     int events = 0;
>     if (swReactor_event_read(fdtype))
>     {
>         events |= SW_EVENT_READ;
>     }
>     if (swReactor_event_write(fdtype))
>     {
>         events |= SW_EVENT_WRITE;
>     }
>     if (swReactor_event_error(fdtype))
>     {
>         events |= SW_EVENT_ERROR;
>     }
>     return events;
> }
> 
> int swReactor_create(swReactor *reactor, int max_event);
> int swReactor_setHandle(swReactor *, int, swReactor_handle);
> int swReactor_add(swReactor *reactor, int fd, int type);
> swConnection* swReactor_get(swReactor *reactor, int fd);
> int swReactor_del(swReactor *reactor, int fd);
> int swReactor_onWrite(swReactor *reactor, swEvent *ev);
> int swReactor_close(swReactor *reactor, int fd);
> int swReactor_write(swReactor *reactor, int fd, void *buf, int n);
> int swReactor_wait_write_buffer(swReactor *reactor, int fd);
> void swReactor_set(swReactor *reactor, int fd, int fdtype);
> 
> static sw_inline int swReactor_add_event(swReactor *reactor, int fd, enum swEvent_type event_type)
> {
>     swConnection *conn = swReactor_get(reactor, fd);
>     if (!(conn->events & event_type))
>     {
>         return reactor->set(reactor, fd, conn->fdtype | conn->events | event_type);
>     }
>     return SW_OK;
> }
> 
> static sw_inline int swReactor_del_event(swReactor *reactor, int fd, enum swEvent_type event_type)
> {
>     swConnection *conn = swReactor_get(reactor, fd);
>     if (conn->events & event_type)
>     {
>         return reactor->set(reactor, fd, conn->fdtype | (conn->events & (~event_type)));
>     }
>     return SW_OK;
> }
> 
> swReactor_handle swReactor_getHandle(swReactor *reactor, int event_type, int fdtype);
> int swReactorEpoll_create(swReactor *reactor, int max_event_num);
> int swReactorPoll_create(swReactor *reactor, int max_event_num);
> int swReactorKqueue_create(swReactor *reactor, int max_event_num);
> int swReactorSelect_create(swReactor *reactor);
> 
> /*----------------------------Process Pool-------------------------------*/
> int swProcessPool_create(swProcessPool *pool, int worker_num, int max_request, key_t msgqueue_key, int nopipe);
> int swProcessPool_wait(swProcessPool *pool);
> int swProcessPool_start(swProcessPool *pool);
> void swProcessPool_shutdown(swProcessPool *pool);
> pid_t swProcessPool_spawn(swWorker *worker);
> int swProcessPool_dispatch(swProcessPool *pool, swEventData *data, int *worker_id);
> int swProcessPool_dispatch_blocking(swProcessPool *pool, swEventData *data, int *dst_worker_id);
> int swProcessPool_add_worker(swProcessPool *pool, swWorker *worker);
> int swProcessPool_del_worker(swProcessPool *pool, swWorker *worker);
> 
> static sw_inline swWorker* swProcessPool_get_worker(swProcessPool *pool, int worker_id)
> {
>     return &(pool->workers[worker_id - pool->start_id]);
> }
> 
> //-----------------------------Channel---------------------------
> enum SW_CHANNEL_FLAGS
> {
>     SW_CHAN_LOCK     = 1u << 1,
>     SW_CHAN_NOTIFY   = 1u << 2,
>     SW_CHAN_SHM      = 1u << 3,
> };
> 
> typedef struct _swChannel
> {
> 	int head;    //头部，出队列方向
> 	int tail;    //尾部，入队列方向
> 	int size;    //队列总尺寸
> 	char head_tag;
> 	char tail_tag;
> 	int num;
> 	int flag;
> 	int maxlen;
> 	void *mem;   //内存块
> 	swLock lock;
> 	swPipe notify_fd;
> } swChannel;
> 
> swChannel* swChannel_new(int size, int maxlen, int flag);
> int swChannel_pop(swChannel *object, void *out, int buffer_length);
> int swChannel_push(swChannel *object, void *in, int data_length);
> int swChannel_out(swChannel *object, void *out, int buffer_length);
> int swChannel_in(swChannel *object, void *in, int data_length);
> int swChannel_wait(swChannel *object);
> int swChannel_notify(swChannel *object);
> void swChannel_free(swChannel *object);
> 
> swLinkedList* swLinkedList_new(uint8_t type, swDestructor dtor);
> int swLinkedList_append(swLinkedList *ll, void *data);
> void swLinkedList_remove_node(swLinkedList *ll, swLinkedList_node *remove_node);
> int swLinkedList_prepend(swLinkedList *ll, void *data);
> void* swLinkedList_pop(swLinkedList *ll);
> void* swLinkedList_shift(swLinkedList *ll);
> void swLinkedList_free(swLinkedList *ll);
> /*----------------------------Thread Pool-------------------------------*/
> enum swThread_type
> {
>     SW_THREAD_MASTER = 1,
>     SW_THREAD_REACTOR = 2,
>     SW_THREAD_WORKER = 3,
>     SW_THREAD_UDP = 4,
>     SW_THREAD_UNIX_DGRAM = 5,
>     SW_THREAD_HEARTBEAT = 6,
> };
> 
> typedef struct _swThreadPool
> {
>     pthread_mutex_t mutex;
>     pthread_cond_t cond;
> 
>     swThread *threads;
>     swThreadParam *params;
> 
>     void *ptr1;
>     void *ptr2;
> 
> #ifdef SW_THREADPOOL_USE_CHANNEL
>     swChannel *chan;
> #else
>     swRingQueue queue;
> #endif
> 
>     int thread_num;
>     int shutdown;
>     sw_atomic_t task_num;
> 
>     void (*onStart)(struct _swThreadPool *pool, int id);
>     void (*onStop)(struct _swThreadPool *pool, int id);
>     int (*onTask)(struct _swThreadPool *pool, void *task, int task_len);
> 
> } swThreadPool;
> 
> struct _swThread
> {
>     pthread_t tid;
>     int id;
>     swThreadPool *pool;
> };
> 
> int swThreadPool_dispatch(swThreadPool *pool, void *task, int task_len);
> int swThreadPool_create(swThreadPool *pool, int max_num);
> int swThreadPool_run(swThreadPool *pool);
> int swThreadPool_free(swThreadPool *pool);
> 
> //--------------------------------protocol------------------------------
> int swProtocol_get_package_length(swProtocol *protocol, swConnection *conn, char *data, uint32_t size);
> int swProtocol_recv_check_length(swProtocol *protocol, swConnection *conn, swString *buffer);
> int swProtocol_recv_check_eof(swProtocol *protocol, swConnection *conn, swString *buffer);
> 
> //--------------------------------timer------------------------------
> typedef struct _swTimer_node
> {
>     swHeap_node *heap_node;
>     void *data;
>     int64_t exec_msec;
>     uint32_t interval;
>     long id;
>     uint8_t remove :1;
> } swTimer_node;
> 
> typedef struct _swTimer
> {
>     /*--------------timerfd & signal timer--------------*/
>     swHeap *heap;
>     int num;
>     int use_pipe;
>     int lasttime;
>     int fd;
>     long _next_id;
>     long _current_id;
>     long _next_msec;
>     swPipe pipe;
>     /*-----------------for EventTimer-------------------*/
>     struct timeval basetime;
>     /*--------------------------------------------------*/
>     int (*set)(struct _swTimer *timer, long exec_msec);
>     /*-----------------event callback-------------------*/
>     void (*onAfter)(struct _swTimer *timer, swTimer_node *event);
>     void (*onTick)(struct _swTimer *timer, swTimer_node *event);
> } swTimer;
> 
> int swTimer_init(long msec);
> swTimer_node* swTimer_add(swTimer *timer, int _msec, int interval, void *data);
> swTimer_node* swTimer_get(swTimer *timer, long id);
> void swTimer_del(swTimer *timer, swTimer_node *node);
> void swTimer_free(swTimer *timer);
> int swTimer_select(swTimer *timer);
> 
> int swSystemTimer_init(int msec, int use_pipe);
> void swSystemTimer_signal_handler(int sig);
> int swSystemTimer_event_handler(swReactor *reactor, swEvent *event);
> //--------------------------------------------------------------
> typedef struct _swModule
> {
>     char *name;
>     void (*test)(void);
>     int (*shutdown)(struct _swModule*);
> 
> } swModule;
> 
> int swModule_load(char *so_file);
> 
> //Share Memory
> typedef struct
> {
>     pid_t master_pid;
>     pid_t manager_pid;
> 
>     uint32_t session_round :24;
>     uint8_t start;  //after swServer_start will set start=1
> 
>     time_t now;
> 
>     sw_atomic_t spinlock;
>     swLock lock;
> 
>     swProcessPool task_workers;
>     swProcessPool event_workers;
> 
> } swServerGS;
> 
> //Worker process global Variable
> typedef struct
> {
>     /**
>      * Always run
>      */
>     uint8_t run_always;
> 
>     /**
>      * Current Proccess Worker's id
>      */
>     uint32_t id;
> 
>     /**
>      * pipe_worker
>      */
>     int pipe_used;
> 
>     uint32_t reactor_wait_onexit :1;
>     uint32_t reactor_init :1;
>     uint32_t reactor_ready :1;
>     uint32_t in_client :1;
>     uint32_t shutdown :1;
>     uint32_t reload;
>     uint32_t reload_count;   //reload计数
> 
>     uint32_t request_count;
> 
>     int max_request;
> 
>     swString **buffer_input;
>     swString **buffer_output;
>     swWorker *worker;
> 
> } swWorkerG;
> 
> typedef struct
> {
>     uint16_t id;
>     uint8_t type;
>     uint8_t update_time;
>     uint8_t factory_lock_target;
>     int16_t factory_target_worker;
> } swThreadG;
> 
> typedef struct _swServer swServer;
> typedef struct _swFactory swFactory;
> 
> typedef struct
> {
>     swTimer timer;
> 
>     uint8_t running :1;
>     uint8_t use_timerfd :1;
>     uint8_t use_signalfd :1;
>     uint8_t reuse_port :1;
>     uint8_t socket_dontwait :1;
> 
>     /**
>      * Timer used pipe
>      */
>     uint8_t use_timer_pipe :1;
> 
>     int error;
>     int process_type;
>     pid_t pid;
> 
>     int signal_alarm;  //for timer with message queue
>     int signal_fd;
>     int log_fd;
>     int null_fd;
>     int debug_fd;
> 
>     /**
>      * worker(worker and task_worker) process chroot / user / group
>      */
>     char *chroot;
>     char *user;
>     char *group;
> 
>     uint8_t log_level;
>     char *log_file;
> 
>     /**
>      *  task worker process num
>      */
>     uint16_t task_worker_num;
>     /**
>      *  task worker process max
>      */
>     uint8_t task_recycle_num;
>     char *task_tmpdir;
>     uint16_t task_tmpdir_len;
>     uint8_t task_ipc_mode;
>     uint16_t task_max_request;
> 
>     uint16_t cpu_num;
> 
>     uint32_t pagesize;
>     uint32_t max_sockets;
>     struct utsname uname;
> 
>     /**
>      * Unix socket default buffer size
>      */
>     uint32_t socket_buffer_size;
> 
>     swServer *serv;
>     swFactory *factory;
> 
>     swMemoryPool *memory_pool;
>     swReactor *main_reactor;
> 
>     swPipe *task_notify;
>     swEventData *task_result;    
>     
>     pthread_t heartbeat_pidt;
> 
> } swServerG;
> 
> typedef struct
> {
>     time_t start_time;
>     sw_atomic_t connection_num;
>     sw_atomic_t accept_count;
>     sw_atomic_t close_count;
>     sw_atomic_t tasking_num;
>     sw_atomic_t request_count;
> } swServerStats;
> 
> extern swServerG SwooleG;              //Local Global Variable
> extern swServerGS *SwooleGS;           //Share Memory Global Variable
> extern swWorkerG SwooleWG;             //Worker Global Variable
> extern __thread swThreadG SwooleTG;   //Thread Global Variable
> extern swServerStats *SwooleStats;
> 
> #define SW_CPU_NUM                    (SwooleG.cpu_num)
> 
> //-----------------------------------------------
> //OS Feature
> #if defined(HAVE_KQUEUE) || !defined(HAVE_SENDFILE)
> int swoole_sendfile(int out_fd, int in_fd, off_t *offset, size_t size);
> #else
> #include <sys/sendfile.h>
> #define swoole_sendfile(out_fd, in_fd, offset, limit)    sendfile(out_fd, in_fd, offset, limit)
> #endif
> 
> static sw_inline void sw_spinlock(sw_atomic_t *lock)
> {
>     uint32_t i, n;
>     while (1)
>     {
>         if (*lock == 0 && sw_atomic_cmp_set(lock, 0, 1))
>         {
>             return;
>         }
>         if (SW_CPU_NUM > 1)
>         {
>             for (n = 1; n < SW_SPINLOCK_LOOP_N; n <<= 1)
>             {
>                 for (i = 0; i < n; i++)
>                 {
>                     sw_atomic_cpu_pause();
>                 }
> 
>                 if (*lock == 0 && sw_atomic_cmp_set(lock, 0, 1))
>                 {
>                     return;
>                 }
>             }
>         }
>         swYield();
>     }
> }
> 
> #ifdef __cplusplus
> }
> #endif
> 
> #endif /* SWOOLE_H_ */
Only in ../swoole-1.8.5-stable/include: table.h
Only in ../swoole-1.8.5-stable/include: uthash.h
Only in ../swoole-1.8.5-stable/include: websocket.h
Only in ../swoole-1.8.5-stable/: package.xml
Only in ../swoole-1.8.5-stable/: php-tests
diff -r ./zan-extension/php7_wrapper.h ../swoole-1.8.5-stable/php7_wrapper.h
20,24d19
< #if PHP_MAJOR_VERSION >= 7
< #include "ext/date/php_date.h"
< #include "ext/standard/url.h"
< #endif
< 
45,46c40
< #define sw_zval_dup(val)                      (val)
< #define sw_zval_free(val)                     (sw_zval_ptr_dtor(&(val)))
---
> 
54d47
< 
57,59d49
< #define SW_ALLOC_INIT_THE_ZVAL(p,_p)		  ALLOC_INIT_ZVAL(p)
< #define sw_copy_to_stack(a, b)
< 
68c58
< #define SWOOLE_FETCH_TSRMLS                   TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL)
---
> #define sw_copy_to_stack(a, b)
81d70
< 
87d75
< #define SW_RETVAL_STRING                      RETVAL_STRING
89,90d76
< 
< #define sw_zend_call_method_with_0_params     zend_call_method_with_0_params
93d78
< 
146d130
< #define sw_zend_get_executed_filename()     zend_get_executed_filename(TSRMLS_C)
150d133
< 
204c187
< static sw_inline char* sw_php_format_date(char *format, size_t format_len, time_t ts, int localtime)
---
> static inline char* sw_php_format_date(char *format, size_t format_len, time_t ts, int localtime)
207c190,192
<     char *return_str = estrndup(time->val, time->len);
---
>     char *return_str = (char*) emalloc(time->len + 1);
>     memcpy(return_str, time->val, time->len);
>     return_str[time->len] = 0;
217c202,203
<     char *return_str = estrndup(str->val, str->len);
---
>     char *return_str = (char*) emalloc(str->len + 1);
>     memcpy(return_str, str->val, str->len);
218a205
>     return_str[str->len] = 0;
242d228
< 
244,250c230,232
< #define SW_ALLOC_INIT_ZVAL(p)           do{p = (zval *)emalloc(sizeof(zval));bzero(p, sizeof(zval));}while(0)
< #define SW_ALLOC_INIT_THE_ZVAL(p,_p)	    do{bzero(&_p,sizeof(_p));p = &_p;}while(0)
< #define sw_copy_to_stack(a, b)          do {zval *__tmp = a;a = &b;memcpy(a, __tmp, sizeof(zval));}while(0)
< 
< #define SW_RETURN_STRINGL(s, l, dup)    do{RETVAL_STRINGL(s, l);if (dup == 0) efree(s);}while(0);return
< #define SW_RETVAL_STRINGL(s, l, dup)    do{RETVAL_STRINGL(s, l); if (dup == 0) efree(s);}while(0)
< #define SW_RETVAL_STRING(s, dup)        do{RETVAL_STRING(s); if (dup == 0) efree(s);}while(0)
---
> #define SW_ALLOC_INIT_ZVAL(p)           p = emalloc(sizeof(zval)); bzero(p, sizeof(zval))
> #define SW_RETURN_STRINGL(s, l, dup)    RETURN_STRINGL(s, l)
> #define SW_RETVAL_STRINGL(s, l, dup)    RETVAL_STRINGL(s, l); if (dup == 0) efree(s)
261,280c243,244
< #define sw_zend_get_executed_filename()                             zend_get_executed_filename()
< 
< #define sw_zend_call_method_with_0_params(obj, ptr, what, method, retval) \
<     zval __retval;\
<     zend_call_method_with_0_params(*obj, ptr, what, method, &__retval);\
<     if (ZVAL_IS_NULL(&__retval)) *(retval) = NULL;\
<     else *(retval) = &__retval;
< #define sw_zend_call_method_with_1_params(obj, ptr, what, method, retval, v1)           \
<     zval __retval;\
<     zend_call_method_with_1_params(*obj, ptr, what, method, &__retval, v1);\
<     if (ZVAL_IS_NULL(&__retval)) *(retval) = NULL;\
<     else *(retval) = &__retval;
< 
< #define sw_zend_call_method_with_2_params(obj, ptr, what, method, retval, v1, v2)    \
<     zval __retval;\
<     zend_call_method_with_2_params(*obj, ptr, what, method, &__retval, v1, v2);\
<     if (ZVAL_IS_NULL(&__retval)) *(retval) = NULL;\
<     else *(retval) = &__retval;
< 
< #define SWOOLE_FETCH_TSRMLS
---
> #define sw_zend_call_method_with_1_params(obj, ptr, what, method, retval, v1)           zend_call_method_with_1_params(*obj,ptr,what,method,*retval,v1)
> #define sw_zend_call_method_with_2_params(obj, ptr, what, method, retval, name, cb)     zend_call_method_with_2_params(*obj,ptr,what,method,*retval,name,cb)
285,299c249,251
< 
< static sw_inline zval* sw_zval_dup(zval *val)
< {
< 	if (!val) return NULL;
<     zval *dup;
<     SW_ALLOC_INIT_ZVAL(dup);
<     memcpy(dup, val, sizeof(zval));
<     return dup;
< }
< 
< static sw_inline void sw_zval_free(zval *val)
< {
<     sw_zval_ptr_dtor(&val);
<     efree(val);
< }
---
> #define sw_copy_to_stack(a, b)                zval *__tmp = a;\
>     a = &b;\
>     memcpy(a, __tmp, sizeof(zval))
307c259
< static sw_inline int sw_zend_is_callable(zval *cb, int a, char **name)
---
> static inline int sw_zend_is_callable(zval *cb, int a, char **name)
309c261
<     zend_string *key = NULL;
---
>     zend_string *key;
311,312c263,264
<     char *tmp = estrndup(key->val, key->len);
<     zend_string_release(key);
---
>     char *tmp = (char *)emalloc(key->len);
>     memcpy(tmp, key->val, key->len);
313a266
>     zend_string_free(key);
324c277
<     zval **real_p = (zval **)pData;
---
>     zval **real_p = pData;
330c283
<     zval **real_p = (zval **)pData;
---
>     zval **real_p = pData;
334c287
< static inline int sw_zend_hash_update(HashTable *ht, char *k, int len, zval *val, int size, void *ptr)
---
> static inline int sw_zend_hash_update(HashTable *ht, char *k, int len, void *val, int size, void *ptr)
336c289
<     return zend_hash_str_update(ht, (const char*)k, len -1, val) ? SUCCESS : FAILURE;
---
>     return zend_hash_str_update(ht, k, len -1, val) ? SUCCESS : FAILURE;
diff -r ./zan-extension/php_swoole.h ../swoole-1.8.5-stable/php_swoole.h
34d33
< #include <ext/standard/sha1.h>
37,38d35
< #include <ext/standard/php_array.h>
< 
45,47c42,44
< #include "swServer.h"
< #include "swClient.h"
< #include "swAsyncIO.h"
---
> #include "Server.h"
> #include "Client.h"
> #include "async.h"
49c46
< #define PHP_SWOOLE_VERSION  "3.0.4"
---
> #define PHP_SWOOLE_VERSION  "1.8.5"
51d47
< #define YZ_SWOOLE_VERSION   "master"
85,93c81
< #define SWOOLE_OBJECT_MAX       10000000
< 
< enum obj_swoole_property
< {
<     swoole_property_common = 0,
<     swoole_property_socket = 1,
< 	swoole_connpool_object = 2,
< 	swoole_property_nums
< };
---
> #define SWOOLE_OBJECT_MAX       1000000
97,100c85,88
<     void **array;									/// object 数组
<     uint32_t size;									/// object 数组长度
<     void **property[swoole_property_nums];			/// object 属性数组
<     uint32_t property_size[swoole_property_nums];
---
>     void **array;
>     uint32_t size;
>     void **property[SWOOLE_PROPERTY_MAX];
>     uint32_t property_size[SWOOLE_PROPERTY_MAX];
119c107,115
< #define swoole_efree(p)  do{if (p) efree(p); p=NULL;}while(0)
---
> #define swoole_efree(p)  if (p) efree(p)
> 
> #if defined(SW_ASYNC_MYSQL)
> #if defined(SW_HAVE_MYSQLI) && defined(SW_HAVE_MYSQLND)
> #else
> #error "Enable async_mysql support, require mysqli and mysqlnd."
> #undef SW_ASYNC_MYSQL
> #endif
> #endif
158c154
<     SW_CLIENT_CB_onConnect = 1,
---
>     SW_CLIENT_CB_onConnect,
166,191c162,181
< 	SW_SERVER_CB_onConnect,        //worker(event)
< 	SW_SERVER_CB_onReceive,        //worker(event)
< 	SW_SERVER_CB_onClose,          //worker(event)
< 	SW_SERVER_CB_onPacket,         //worker(event)
< 
< 	SW_SERVER_CB_onStart,          //master
< 	SW_SERVER_CB_onShutdown,       //master
< 	SW_SERVER_CB_onWorkerStart,    //worker(event & task)
< 	SW_SERVER_CB_onWorkerStop,     //worker(event & task)
< 	SW_SERVER_CB_onTask,           //worker(task)
< 	SW_SERVER_CB_onFinish,         //worker(event & task)
< 	SW_SERVER_CB_onWorkerError,    //manager
< 	SW_SERVER_CB_onManagerStart,   //manager
< 	SW_SERVER_CB_onManagerStop,    //manager
< 	SW_SERVER_CB_onPipeMessage,    //worker(evnet & task)
< 
< 	//--------------------------Swoole\Http\Server----------------------
< 	SW_SERVER_CB_onRequest,        //http server
< 	//--------------------------Swoole\WebSocket\Server-----------------
< 	SW_SERVER_CB_onHandShake,      //worker(event)
< 	SW_SERVER_CB_onOpen,           //worker(event)
< 	SW_SERVER_CB_onMessage,        //worker(event)
< 	//--------------------------Buffer Event----------------------------
< //	SW_SERVER_CB_onBufferFull,     //worker(event)
< //	SW_SERVER_CB_onBufferEmpty,    //worker(event)
< 	//-------------------------------END--------------------------------
---
>     /**
>      * port callback
>      */
>     SW_SERVER_CB_onConnect,        //accept new connection(worker)
>     SW_SERVER_CB_onReceive,        //receive data(worker)
>     SW_SERVER_CB_onClose,          //close tcp connection(worker)
>     SW_SERVER_CB_onPacket,         //udp packet
>     /**
>      * server callback
>      */
>     SW_SERVER_CB_onStart,          //Server start(master)
>     SW_SERVER_CB_onShutdown,       //Server sthudown(master)
>     SW_SERVER_CB_onWorkerStart,    //Worker start(worker)
>     SW_SERVER_CB_onWorkerStop,     //Worker shutdown(worker)
>     SW_SERVER_CB_onTask,           //new task(task_worker)
>     SW_SERVER_CB_onFinish,         //async task finish(worker)
>     SW_SERVER_CB_onWorkerError,    //worker exception(manager)
>     SW_SERVER_CB_onManagerStart,
>     SW_SERVER_CB_onManagerStop,
>     SW_SERVER_CB_onPipeMessage,
194c184
< #define PHP_SERVER_CALLBACK_NUM             (SW_SERVER_CB_onMessage+1)
---
> #define PHP_SERVER_CALLBACK_NUM             (SW_SERVER_CB_onPipeMessage+1)
205,206d194
< 
< 
207a196
> #define SW_FLAG_KEEP                        (1u << 12)
220,221c209
< 
< #define php_swoole_socktype(type)           (type & (~SW_FLAG_SYNC) & (~SW_FLAG_ASYNC) & (~SW_SOCK_SSL))
---
> #define php_swoole_socktype(type)           (type & (~SW_FLAG_SYNC) & (~SW_FLAG_ASYNC) & (~SW_FLAG_KEEP) & (~SW_SOCK_SSL))
224,229d211
< #define php_swoole_array_separate(arr)       zval *_new_##arr;\
<     SW_MAKE_STD_ZVAL(_new_##arr);\
<     array_init(_new_##arr);\
<     sw_php_array_merge(Z_ARRVAL_P(_new_##arr), Z_ARRVAL_P(arr));\
<     arr = _new_##arr;
< 
231a214
> extern zend_class_entry *swoole_lock_class_entry_ptr;
234,236d216
< extern zend_class_entry *swoole_http_server_class_entry_ptr;
< extern zend_class_entry *swoole_http_response_class_entry_ptr;
< extern zend_class_entry *swoole_http_request_class_entry_ptr;
239,240d218
< 
< #ifdef HAVE_PCRE
242,244d219
< #endif
< 
< extern zend_class_entry *swoole_timer_class_entry_ptr;
246c221,222
< extern zend_class_entry *swoole_websocket_server_class_entry_ptr;
---
> extern zend_class_entry *swoole_table_class_entry_ptr;
> extern zend_class_entry *swoole_http_server_class_entry_ptr;
249,250d224
< extern zend_class_entry *swoole_mysql_class_entry_ptr;
< extern zend_class_entry *swoole_redis_class_entry_ptr;
252c226,241
< extern void releaseConnobj(zval* client);
---
> extern zval *php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];
> 
> #define PHP_MEMORY_DEBUG  0
> 
> #if PHP_MEMORY_DEBUG
> typedef struct
> {
>     int new_client;
>     int free_client;
>     int new_http_response;
>     int new_http_request;
>     int free_http_response;
>     int free_http_request;
> } php_vmstat_t;
> extern php_vmstat_t php_vmstat;
> #endif
264,271d252
< //For YouZan Nova
< PHP_FUNCTION(nova_encode);
< PHP_FUNCTION(nova_decode);
< PHP_FUNCTION(is_nova_packet);
< PHP_FUNCTION(nova_get_sequence);
< PHP_FUNCTION(nova_get_time);
< PHP_FUNCTION(nova_get_ip);
< 
301,306c282,283
< PHP_METHOD(swoole_server, getClientList);
< PHP_METHOD(swoole_server, getClientInfo);
< 
< //For YouZan
< PHP_METHOD(swoole_server, denyRequest);
< PHP_METHOD(swoole_server, exit);
---
> PHP_METHOD(swoole_server, connection_list);
> PHP_METHOD(swoole_server, connection_info);
316a294
> #ifdef SWOOLE_SOCKETS_SUPPORT
318c296
< 
---
> #endif
334a313,314
> PHP_FUNCTION(swoole_async_readfile);
> PHP_FUNCTION(swoole_async_writefile);
336d315
< PHP_FUNCTION(swoole_clean_dns_cache);
338d316
< 
345,352d322
< PHP_FUNCTION(swoole_timer_set);
< PHP_FUNCTION(swoole_timer_exists);
< 
< //---------------------------------------------------------
< //                  swoole_client api
< //---------------------------------------------------------
< 
< PHP_FUNCTION(swoole_client_select);
354,368d323
< 
< //---------------------------------------------------------
< //                  swoole_connpool callback api
< //---------------------------------------------------------
< 
< ZEND_FUNCTION(onClientConnect);
< ZEND_FUNCTION(onClientClose);
< ZEND_FUNCTION(onClientTimeout);
< ZEND_FUNCTION(onClientRecieve);
< ZEND_FUNCTION(onSubClientConnect);
< 
< 
< //---------------------------------------------------------
< //                 others global api
< //---------------------------------------------------------
371d325
< 
373c327
< // 					 		end
---
> //                  swoole_mysql
375,378c329,331
< 
< extern zval *php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];
< #if PHP_MAJOR_VERSION >= 7
< extern zval _php_sw_server_callbacks[PHP_SERVER_CALLBACK_NUM];
---
> #ifdef SW_ASYNC_MYSQL
> PHP_FUNCTION(swoole_get_mysqli_sock);
> PHP_FUNCTION(swoole_mysql_query);
381c334
< extern zval *php_swoole_server_get_callback(swServer *serv, int server_fd, int event_type);
---
> PHP_FUNCTION(swoole_client_select);
383c336
< void swoole_destroy_table(zend_resource *rsrc TSRMLS_DC);
---
> void swoole_destory_table(zend_resource *rsrc TSRMLS_DC);
386c339,342
< void swoole_aio_init(int module_number TSRMLS_DC);
---
> void swoole_async_init(int module_number TSRMLS_DC);
> void swoole_table_init(int module_number TSRMLS_DC);
> void swoole_lock_init(int module_number TSRMLS_DC);
> void swoole_atomic_init(int module_number TSRMLS_DC);
388,391c344
< void swoole_connpool_init(int module_number TSRMLS_DC);
< void swoole_timer_init(int module_number TSRMLS_DC);
< void swoole_mysql_init(int module_number TSRMLS_DC);
< 
---
> #ifdef SW_ASYNC_HTTPCLIENT
393c346
< 
---
> #endif
397d349
< 
399d350
< void swoole_server_init(int module_number TSRMLS_DC);
403c354
< 
---
> void swoole_mysql_init(int module_number TSRMLS_DC);
406,408d356
< void php_swoole_check_reactor();
< void swoole_thread_clean();
< void php_swoole_at_shutdown(char *function);
409a358
> void php_swoole_check_reactor();
412c361
< 
---
> void php_swoole_check_timer(int interval);
415c364
< swClient* php_swoole_client_new(zval *object, char *host, int host_len, int port,swClient** cli);
---
> swClient* php_swoole_client_new(zval *object, char *host, int host_len, int port);
418,419c367
< 
< static sw_inline void php_swoole_sha1(const char *str, int _len, unsigned char *digest)
---
> static sw_inline void* swoole_get_object(zval *object)
421,424c369,375
<     PHP_SHA1_CTX context;
<     PHP_SHA1Init(&context);
<     PHP_SHA1Update(&context, (unsigned char *) str, _len);
<     PHP_SHA1Final(digest, &context);
---
> #if PHP_MAJOR_VERSION < 7
>     zend_object_handle handle = Z_OBJ_HANDLE_P(object);
> #else
>     int handle = (int)Z_OBJ_HANDLE(*object);
> #endif
>     assert(handle < swoole_objects.size);
>     return swoole_objects.array[handle];
427c378
< static sw_inline int swoole_check_callable(zval *callback TSRMLS_CC)
---
> static sw_inline void* swoole_get_property(zval *object, int property_id)
429,443c380,389
< 	if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return SW_ERR;
< 	}
< 
< 	char *func_name = NULL;
< 	int iRet = sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC)? SW_OK:SW_ERR;
< 
< 	if (func_name)
< 	{
< 		if (iRet < 0) swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
< 		swoole_efree(func_name);
< 	}
< 
< 	return iRet;
---
> #if PHP_MAJOR_VERSION < 7
>     zend_object_handle handle = Z_OBJ_HANDLE_P(object);
> #else
>     int handle = (int) Z_OBJ_HANDLE(*object);
> #endif
>     if (handle >= swoole_objects.property_size[property_id])
>     {
>         return NULL;
>     }
>     return swoole_objects.property[property_id][handle];
449,451c395
< void* swoole_get_object(zval *object);
< void* swoole_get_property(zval *object, int property_id);
< 
---
> #ifdef SWOOLE_SOCKETS_SUPPORT
453c397
< 
---
> #endif
455a400
> zval *php_swoole_get_recv_data(zval *,swEventData *req TSRMLS_DC);
457d401
< void php_swoole_get_recv_data(zval *zdata, swEventData *req, char *header, uint32_t header_length TSRMLS_DC);
462,464d405
< #define php_swoole_array_get_value(ht, str, v)     (sw_zend_hash_find(ht, str, sizeof(str), (void **) &v) == SUCCESS && !ZVAL_IS_NULL(v))
< #define php_swoole_array_get_ptr_value(ht, str, v)     (sw_zend_hash_find(ht, str, strlen(str)+1, (void **) &v) == SUCCESS && !ZVAL_IS_NULL(v))
< 
Only in ./zan-extension/src: Base.c
Only in ../swoole-1.8.5-stable/src/core: Channel.c
diff -r ./zan-extension/src/core/RingQueue.c ../swoole-1.8.5-stable/src/core/RingQueue.c
16d15
< 
18,20c17,18
< #include "swError.h"
< #include "swLog.h"
< #include "swBaseData.h"
---
> #include "swoole.h"
> #include "RingQueue.h"
26,29d23
< 	if (!queue){
< 		return SW_ERR;
< 	}
< 
34c28
<         return SW_ERR;
---
>         return -1;
36d29
< 
41c34
<         return SW_ERR;
---
>         return -1;
47c40
<     return SW_OK;
---
>     return 0;
52c45
<     if (!queue || !(queue->num < queue->size))
---
>     if (!(queue->num < queue->size))
54c47
<         return SW_ERR;
---
>         return -1;
56d48
< 
79c71
<     return SW_OK;
---
>     return 0;
84,87c76,77
<     if (!queue || !(queue->num > 0)){
<         return SW_ERR;
<     }
< 
---
>     if (!(queue->num > 0))
>         return -1;
103c93
<     return SW_OK;
---
>     return 0;
109,112d98
< 	if (!queue){
< 		return SW_ERR;
< 	}
< 
117c103
<         return SW_ERR;
---
>         return -1;
123c109
<     return SW_OK;
---
>     return 0;
diff -r ./zan-extension/src/core/UnitTest.c ../swoole-1.8.5-stable/src/core/UnitTest.c
35c35
<         utmap = swHashMap_create(32, free);
---
>         utmap = swHashMap_new(32, free);
38c38
<     u = (swHashTable_unitTest *) sw_malloc(sizeof(swHashTable_unitTest));
---
>     u = (swHashTable_unitTest *) malloc(sizeof(swHashTable_unitTest));
diff -r ./zan-extension/src/core/array.c ../swoole-1.8.5-stable/src/core/array.c
17,23c17,18
< 
< #include "swError.h"
< #include "swLog.h"
< #include "swBaseData.h"
< 
< #define swArray_page(array, n)      ((!array->page_size)? array->page_num: (n) / (array)->page_size)
< #define swArray_offset(array, n)    ((!array->page_size)? array->page_num: (n) % (array)->page_size)
---
> #include "swoole.h"
> #include "array.h"
28c23
< swArray *swArray_create(int page_size, size_t item_size)
---
> swArray *swArray_new(int page_size, size_t item_size)
36d30
< 
37a32
> 
59,60c54,55
<     int index;
<     for (index = 0; index < array->page_num; index++)
---
>     int i;
>     for (i = 0; i < array->page_num; i++)
62c57
<         sw_free(array->pages[index]);
---
>         sw_free(array->pages[i]);
64d58
< 
74c68
<     if (!array || array->page_num == SW_ARRAY_PAGE_MAX)
---
>     if (array->page_num == SW_ARRAY_PAGE_MAX)
94,97d87
< 	if (!array){
< 		return NULL;
< 	}
< 
99,101c89,93
< 
<     return (page >= array->page_num)? NULL:
<     		array->pages[page] + (swArray_offset(array, n) * array->item_size);
---
>     if (page >= array->page_num)
>     {
>         return NULL;
>     }
>     return array->pages[page] + (swArray_offset(array, n) * array->item_size);
109,112d100
< 	if (!array){
< 		return SW_ERR;
< 	}
< 
120d107
< 
129,132d115
< 	if (!array){
< 		return SW_ERR;
< 	}
< 
139d121
< 
146,149d127
< 	if (!array){
< 		return NULL;
< 	}
< 
Only in ../swoole-1.8.5-stable/src/core: base.c
diff -r ./zan-extension/src/core/hashmap.c ../swoole-1.8.5-stable/src/core/hashmap.c
17d16
< 
19,22c18,19
< #include "swLog.h"
< #include "swUthash.h"
< #include "swHash.h"
< #include "swBaseData.h"
---
> #include "uthash.h"
> #include "hash.h"
34,83d30
< static sw_inline swHashMap_node *swHashMap_node_find(swHashMap_node *root, char *key_str, uint16_t key_len)
< {
<     swHashMap_node *out = NULL;
<     unsigned bucket, hash;
<     if (root)
<     {
<         hash = swoole_hash_jenkins(key_str, key_len);
<         bucket = hash & (root->hh.tbl->num_buckets - 1);
<         HASH_FIND_IN_BKT(root->hh.tbl, hh, (root)->hh.tbl->buckets[bucket], key_str, key_len, out);
<     }
< 
<     return out;
< }
< 
< static int swHashMap_node_delete(swHashMap_node *root, swHashMap_node *del_node)
< {
<     unsigned bucket;
<     struct UT_hash_handle *_hd_hh_del;
< 
<     if ((del_node->hh.prev == NULL) && (del_node->hh.next == NULL))
<     {
<         sw_free(root->hh.tbl->buckets);
<         sw_free(root->hh.tbl);
<     }
<     else
<     {
<         _hd_hh_del = &(del_node->hh);
<         if (del_node == ELMT_FROM_HH(root->hh.tbl, root->hh.tbl->tail))
<         {
<             root->hh.tbl->tail = (UT_hash_handle*) ((ptrdiff_t) (del_node->hh.prev) + root->hh.tbl->hho);
<         }
<         if (del_node->hh.prev)
<         {
<             ((UT_hash_handle*) ((ptrdiff_t) (del_node->hh.prev) + root->hh.tbl->hho))->next = del_node->hh.next;
<         }
<         else
<         {
<             DECLTYPE_ASSIGN(root, del_node->hh.next);
<         }
<         if (_hd_hh_del->next)
<         {
<             ((UT_hash_handle*) ((ptrdiff_t) _hd_hh_del->next + root->hh.tbl->hho))->prev = _hd_hh_del->prev;
<         }
<         HASH_TO_BKT(_hd_hh_del->hashv, root->hh.tbl->num_buckets, bucket);
<         HASH_DEL_IN_BKT(hh, root->hh.tbl->buckets[bucket], _hd_hh_del);
<         root->hh.tbl->num_items--;
<     }
<     return SW_OK;
< }
< 
122,126d68
< 	if (!hmap)
< 	{
< 		return NULL;
< 	}
< 
151c93
< swHashMap* swHashMap_create(uint32_t bucket_num, swHashMap_dtor dtor)
---
> swHashMap* swHashMap_new(uint32_t bucket_num, swHashMap_dtor dtor)
159d100
< 
168a110,111
>     hmap->root = root;
> 
175,177c118
<         sw_free(hmap);
<         sw_free(root);
<         goto error;
---
>         return NULL;
189c130
<         goto error;
---
>         return NULL;
191d131
< 
195d134
<     hmap->root = root;
199,204d137
< 
< error:
< 	sw_free(hmap);
< 	sw_free(root->hh.tbl);
< 	sw_free(root);
< 	return NULL;
209,213d141
< 	if (!data)
< 	{
< 		return SW_ERR;
< 	}
< 
220d147
< 
238d164
< 
244a171,220
> static sw_inline swHashMap_node *swHashMap_node_find(swHashMap_node *root, char *key_str, uint16_t key_len)
> {
>     swHashMap_node *out;
>     unsigned bucket, hash;
>     out = NULL;
>     if (root)
>     {
>         hash = swoole_hash_jenkins(key_str, key_len);
>         bucket = hash & (root->hh.tbl->num_buckets - 1);
>         HASH_FIND_IN_BKT(root->hh.tbl, hh, (root)->hh.tbl->buckets[bucket], key_str, key_len, out);
>     }
>     return out;
> }
> 
> static int swHashMap_node_delete(swHashMap_node *root, swHashMap_node *del_node)
> {
>     unsigned bucket;
>     struct UT_hash_handle *_hd_hh_del;
> 
>     if ((del_node->hh.prev == NULL) && (del_node->hh.next == NULL))
>     {
>         sw_free(root->hh.tbl->buckets);
>         sw_free(root->hh.tbl);
>     }
>     else
>     {
>         _hd_hh_del = &(del_node->hh);
>         if (del_node == ELMT_FROM_HH(root->hh.tbl, root->hh.tbl->tail))
>         {
>             root->hh.tbl->tail = (UT_hash_handle*) ((ptrdiff_t) (del_node->hh.prev) + root->hh.tbl->hho);
>         }
>         if (del_node->hh.prev)
>         {
>             ((UT_hash_handle*) ((ptrdiff_t) (del_node->hh.prev) + root->hh.tbl->hho))->next = del_node->hh.next;
>         }
>         else
>         {
>             DECLTYPE_ASSIGN(root, del_node->hh.next);
>         }
>         if (_hd_hh_del->next)
>         {
>             ((UT_hash_handle*) ((ptrdiff_t) _hd_hh_del->next + root->hh.tbl->hho))->prev = _hd_hh_del->prev;
>         }
>         HASH_TO_BKT(_hd_hh_del->hashv, root->hh.tbl->num_buckets, bucket);
>         HASH_DEL_IN_BKT(hh, root->hh.tbl->buckets[bucket], _hd_hh_del);
>         root->hh.tbl->num_items--;
>     }
>     return SW_OK;
> }
> 
249c225
<     if (!ret)
---
>     if (ret == NULL)
253d228
< 
323,355d297
< int swHashMap_move(swHashMap *hmap, char *old_key, uint16_t old_key_len, char *new_key, uint16_t new_key_len)
< {
<     swHashMap_node *root = hmap->root;
<     swHashMap_node *node = swHashMap_node_find(root, old_key, old_key_len);
<     if (node == NULL)
<     {
<         return SW_ERR;
<     }
<     swHashMap_node_delete(root, node);
<     sw_strdup_free(node->key_str);
<     node->key_str = strndup(new_key, new_key_len);
<     node->key_int = new_key_len;
<     return swHashMap_node_add(root, node);
< }
< 
< int swHashMap_move_int(swHashMap *hmap, uint64_t old_key, uint64_t new_key)
< {
<     swHashMap_node *ret = NULL;
<     swHashMap_node *root = hmap->root;
< 
<     HASH_FIND_INT(root, &old_key, ret);
<     if (ret == NULL)
<     {
<         return SW_ERR;
<     }
<     HASH_DEL(root, ret);
< 
<     ret->key_int = new_key;
<     HASH_ADD_INT(root, key_int, ret);
< 
<     return SW_OK;
< }
< 
386,390d327
< 	if (!hmap)
< 	{
< 		return;
< 	}
< 
diff -r ./zan-extension/src/core/heap.c ../swoole-1.8.5-stable/src/core/heap.c
17,19c17,18
< 
< #include "swBaseData.h"
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
> #include "heap.h"
29c28
< swHeap *swHeap_create(size_t n, uint8_t type)
---
> swHeap *swHeap_new(size_t n, uint8_t type)
41d39
< 
56c54,61
<     return (type == SW_MIN_HEAP)? a > b :a < b;
---
>     if (type == SW_MIN_HEAP)
>     {
>         return a > b;
>     }
>     else
>     {
>         return a < b;
>     }
66a72,73
>     swHeap_node * child_node = heap->nodes[child_i];
> 
71c78
<     swHeap_node * child_node = heap->nodes[child_i];
---
> 
126d132
< 
136d141
< 
164,168d168
< 	if (!node)
< 	{
< 		return SW_ERR;
< 	}
< 
180,181d179
< 	
< 	sw_free(node);
221c219
<         printf("#%d\tpriority=%llu, data=%p\n", i, heap->nodes[i]->priority, heap->nodes[i]->data);
---
>         printf("#%d\tpriority=%ld, data=%p\n", i, heap->nodes[i]->priority, heap->nodes[i]->data);
diff -r ./zan-extension/src/core/list.c ../swoole-1.8.5-stable/src/core/list.c
17,19c17
< #include "swLog.h"
< #include "swError.h"
< #include "swBaseData.h"
---
> #include "swoole.h"
21,22c19
< 
< swLinkedList* swLinkedList_create(uint8_t type, swDestructor dtor)
---
> swLinkedList* swLinkedList_new(uint8_t type, swDestructor dtor)
36,43c33
< int swLinkedList_empty(swLinkedList *ll)
< {
<     if(!ll)
<         return 1;
<     return (ll->num == 0);
< }
< 
< swLinkedList_node* swLinkedList_append(swLinkedList *ll, void *data,uint64_t priority)
---
> int swLinkedList_append(swLinkedList *ll, void *data)
49c39
<         return NULL;
---
>         return SW_ERR;
52d41
<     node->priority = priority;
68c57
<     return node;
---
>     return SW_OK;
81c70
<     ll->num++;
---
>     ll->num ++;
123,134d111
< swLinkedList_node* swLinkedList_get_tail_node(swLinkedList* ll)
< {
< 	if (ll->tail == NULL)
< 	{
< 		return NULL;
< 	}
< 
< 	swLinkedList_node *node = ll->tail;
< 	return node;
< }
< 
< 
200c177
<     swLinkedList_node *tmp = NULL;
---
>     swLinkedList_node *tmp;
202c179
<     while (node)
---
>     do
211c188
<     }
---
>     } while (node);
diff -r ./zan-extension/src/core/log.c ../swoole-1.8.5-stable/src/core/log.c
17,19c17
< #include "swLog.h"
< #include "swWork.h"
< #include "swBaseOperator.h"
---
> #include "swoole.h"
24,27d21
< 
< int16_t sw_errno = 0;
< char sw_error[SW_ERROR_MSG_SIZE] = {0};
< 
36d29
< 
50,52c43,46
<     const char *level_str = NULL;
<     char date_str[SW_LOG_DATE_STRLEN] = {0};
<     char log_str[SW_LOG_BUFFER_SIZE] = {0};
---
>     const char *level_str;
>     char date_str[SW_LOG_DATE_STRLEN];
>     char log_str[SW_LOG_BUFFER_SIZE];
>     int n;
76,79c70,74
<     time_t t = time(NULL);
<     struct tm *p = localtime(&t);
<     snprintf(date_str, SW_LOG_DATE_STRLEN, "%d-%02d-%02d %02d:%02d:%02d",
<     		p->tm_year + 1900, p->tm_mon + 1, p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
---
>     time_t t;
>     struct tm *p;
>     t = time(NULL);
>     p = localtime(&t);
>     snprintf(date_str, SW_LOG_DATE_STRLEN, "%d-%02d-%02d %02d:%02d:%02d", p->tm_year + 1900, p->tm_mon + 1, p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
105,106c100
<     int n = snprintf(log_str, SW_LOG_BUFFER_SIZE,
<     		"[%s %c%d.%d]\t%s\t%s\n", date_str, process_flag, SwooleG.pid, process_id, level_str, cnt);
---
>     n = snprintf(log_str, SW_LOG_BUFFER_SIZE, "[%s %c%d.%d]\t%s\t%s\n", date_str, process_flag, SwooleG.pid, process_id, level_str, cnt);
109,152d102
< 
< void swPrintf_dump_ascii(char *data, int size)
< {
<     int index = 0;
<     for (index = 0; index < size; index++)
<     {
<         printf("%d ", (unsigned) data[index]);
<     }
<     printf("\n");
< }
< 
< void swPrintf_dump_bin(char *data, char type, int size)
< {
<     int type_size = swoole_type_size(type);
<     int n = size / type_size;
< 
<     int index = 0;
<     for (index = 0; index < n; index++)
<     {
<         printf("%d,", swoole_unpack(type, data + type_size * index));
<     }
< 
<     printf("\n");
< }
< 
< void swPrintf_dump_hex(char *data, int outlen)
< {
<     long index = 0;
<     for (index = 0; index < outlen; ++index)
<     {
<         if ((index & 0x0fu) == 0)
<         {
<             printf("%08zX: ", index);
<         }
< 
<         printf("%02X ", data[index]);
<         if (((index + 1) & 0x0fu) == 0)
<         {
<             printf("\n");
<         }
<     }
< 
<     printf("\n");
< }
diff -r ./zan-extension/src/core/rbtree.c ../swoole-1.8.5-stable/src/core/rbtree.c
17,19c17,18
< 
< #include "swBaseData.h"
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
> #include "rbtree.h"
45,77d43
< void *swRbtree_find(swRbtree *tree, uint32_t key)
< {
<     swRbtree_node *tmp = tree->root;
<     swRbtree_node *sentinel = tree->sentinel;
<     while (tmp != sentinel)
<     {
<         if (key != tmp->key)
<         {
<             tmp = (key < tmp->key) ? tmp->left : tmp->right;
<             continue;
<         }
<         return tmp->value;
<     }
<     return NULL;
< }
< 
< swRbtree* swRbtree_create()
< {
<     swRbtree *rbtree = sw_malloc(sizeof(swRbtree));
<     swRbtree_node *sentinel = sw_malloc(sizeof(swRbtree_node));
< 
<     sentinel->color = 0;
<     rbtree->root = sentinel;
<     rbtree->sentinel = sentinel;
<     return rbtree;
< }
< 
< void swRbtree_free(swRbtree* rbtree)
< {
<     sw_free(rbtree->root);
<     sw_free(rbtree);
< }
< 
85c51
<     swRbtree_node *node = (swRbtree_node *) sw_malloc(sizeof(swRbtree_node));
---
>     swRbtree_node *node = (swRbtree_node *) malloc(sizeof(swRbtree_node));
407a374,405
> void *swRbtree_find(swRbtree *tree, uint32_t key)
> {
>     swRbtree_node *tmp = tree->root;
>     swRbtree_node *sentinel = tree->sentinel;
>     while (tmp != sentinel)
>     {
>         if (key != tmp->key)
>         {
>             tmp = (key < tmp->key) ? tmp->left : tmp->right;
>             continue;
>         }
>         return tmp->value;
>     }
>     return NULL;
> }
> 
> swRbtree* swRbtree_new()
> {
>     swRbtree *rbtree = sw_malloc(sizeof(swRbtree));
>     swRbtree_node *sentinel = sw_malloc(sizeof(swRbtree_node));
> 
>     sentinel->color = 0;
>     rbtree->root = sentinel;
>     rbtree->sentinel = sentinel;
>     return rbtree;
> }
> 
> void swRbtree_free(swRbtree* rbtree)
> {
>     sw_free(rbtree->root);
>     sw_free(rbtree);
> }
Only in ../swoole-1.8.5-stable/src/core: socket.c
diff -r ./zan-extension/src/core/string.c ../swoole-1.8.5-stable/src/core/string.c
17,21c17
< #include "swLog.h"
< #include "swError.h"
< #include "swBaseData.h"
< #include "swBaseOperator.h"
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
43,48d38
< void swString_free(swString *str)
< {
<     sw_free(str->str);
<     sw_free(str);
< }
< 
87d76
< 
91a81,86
> void swString_free(swString *str)
> {
>     sw_free(str->str);
>     sw_free(str);
> }
> 
95,96c90
<     if ((new_size > str->size) &&
<     		swString_extend(str, swoole_size_align(new_size * 2, sysconf(_SC_PAGESIZE))) < 0)
---
>     if (new_size > str->size)
98c92,95
<         return SW_ERR;
---
>         if (swString_extend(str, swoole_size_align(new_size * 2, sysconf(_SC_PAGESIZE))) < 0)
>         {
>             return SW_ERR;
>         }
100d96
< 
108c104
<     char buf[16] = {0};
---
>     char buf[16];
112,113c108
<     if (new_size > str->size &&
<     		swString_extend(str, swoole_size_align(new_size * 2, sysconf(_SC_PAGESIZE))) < 0)
---
>     if (new_size > str->size)
115c110,113
<         return SW_ERR;
---
>         if (swString_extend(str, swoole_size_align(new_size * 2, sysconf(_SC_PAGESIZE))) < 0)
>         {
>             return SW_ERR;
>         }
126,127c124
<     if (new_size > str->size &&
<     		swString_extend(str, swoole_size_align(new_size * 2, sysconf(_SC_PAGESIZE))) < 0)
---
>     if (new_size > str->size)
129c126,129
<         return SW_ERR;
---
>         if (swString_extend(str, swoole_size_align(new_size * 2, sysconf(_SC_PAGESIZE))) < 0)
>         {
>             return SW_ERR;
>         }
131d130
< 
137,166d135
< int swString_write(swString *str, off_t offset, swString *write_str)
< {
<     int new_length = offset + write_str->length;
<     if (new_length > str->size &&
<     		swString_extend(str, swoole_size_align(new_length * 2, sysconf(_SC_PAGESIZE))) < 0)
<     {
<         return SW_ERR;
<     }
< 
<     memcpy(str->str + offset, write_str->str, write_str->length);
<     str->length = (new_length > str->length)? new_length:str->length;
< 
<     return SW_OK;
< }
< 
< int swString_write_ptr(swString *str, off_t offset, char *write_str, int length)
< {
<     int new_length = offset + length;
<     if (new_length > str->size &&
<     		swString_extend(str, swoole_size_align(new_length * 2, sysconf(_SC_PAGESIZE))) < 0)
<     {
<         return SW_ERR;
<     }
< 
<     memcpy(str->str + offset, write_str, length);
<     str->length = (new_length > str->length)? new_length:str->length;
< 
<     return SW_OK;
< }
< 
171c140
<     if (!new_str)
---
>     if (new_str == NULL)
176d144
< 
diff -r ./zan-extension/src/factory/Factory.c ../swoole-1.8.5-stable/src/factory/Factory.c
17,24c17,18
< #include "swWork.h"
< #include "swFactory.h"
< #include "swServer.h"
< #include "swExecutor.h"
< 
< static int swFactory_start(swFactory *factory);
< static int swFactory_dispatch(swFactory *factory, swDispatchData *task);
< static int swFactory_shutdown(swFactory *factory);
---
> #include "swoole.h"
> #include "Server.h"
36a31,67
> int swFactory_start(swFactory *factory)
> {
>     return SW_OK;
> }
> 
> int swFactory_shutdown(swFactory *factory)
> {
>     return SW_OK;
> }
> 
> int swFactory_dispatch(swFactory *factory, swDispatchData *task)
> {
>     swServer *serv = SwooleG.serv;
>     factory->last_from_id = task->data.info.from_id;
> 
>     if (swEventData_is_stream(task->data.info.type))
>     {
>         swConnection *conn = swServer_connection_get(serv, task->data.info.fd);
>         if (conn == NULL || conn->active == 0)
>         {
>             swWarn("dispatch[type=%d] failed, connection#%d is not active.", task->data.info.type, task->data.info.fd);
>             return SW_ERR;
>         }
>         //server active close, discard data.
>         if (conn->closed)
>         {
>             swWarn("dispatch[type=%d] failed, connection#%d is closed by server.", task->data.info.type,
>                     task->data.info.fd);
>             return SW_OK;
>         }
>         //converted fd to session_id
>         task->data.info.fd = conn->session_id;
>         task->data.info.from_fd = conn->from_fd;
>     }
>     return swWorker_onTask(factory, &task->data);
> }
> 
118,119c149,152
< 	resp->length += (resp->length == 0)? resp->info.len :0;
< 
---
>     if (resp->length == 0)
>     {
>         resp->length = resp->info.len;
>     }
131,169d163
< static int swFactory_start(swFactory *factory)
< {
<     return SW_OK;
< }
< 
< static int swFactory_shutdown(swFactory *factory)
< {
<     return SW_OK;
< }
< 
< static int swFactory_dispatch(swFactory *factory, swDispatchData *task)
< {
<     swServer *serv = SwooleG.serv;
<     factory->last_from_id = task->data.info.from_id;
< 
<     if (swEventData_is_stream(task->data.info.type))
<     {
<         swConnection *conn = swServer_connection_get(serv, task->data.info.fd);
<         if (conn == NULL || conn->active == 0)
<         {
<             swWarn("dispatch[type=%d] failed, connection#%d is not active.", task->data.info.type, task->data.info.fd);
<             return SW_ERR;
<         }
<         //server active close, discard data.
<         if (conn->closed)
<         {
<             swWarn("dispatch[type=%d] failed, connection#%d is closed by server.", task->data.info.type,
<                     task->data.info.fd);
<             return SW_OK;
<         }
<         //converted fd to session_id
<         task->data.info.fd = conn->session_id;
<         task->data.info.from_fd = conn->from_fd;
<     }
<     return swWorker_onTask(factory, &task->data);
< }
< 
< 
< 
diff -r ./zan-extension/src/factory/FactoryProcess.c ../swoole-1.8.5-stable/src/factory/FactoryProcess.c
17,23c17,18
< #include "swLog.h"
< #include "swError.h"
< #include "swWork.h"
< #include "swServer.h"
< #include "swFactory.h"
< #include "swExecutor.h"
< #include "swBaseOperator.h"
---
> #include "swoole.h"
> #include "Server.h"
28,34d22
< 
< static __thread struct
< {
<     long target_worker_id;
<     swDataHead _send;
< } sw_notify_data;
< 
44,47d31
<     if (!factory || worker_num < 1){
<         return SW_ERR;
<     }
<     
68a53,54
>     int status;
> 
74d59
<     int status = 0;
84a70
>     int i;
85a72
>     swWorker *worker;
87,88c74
<     int index = 0;
<     for (index = 0; index < serv->worker_num; index++)
---
>     for (i = 0; i < serv->worker_num; i++)
90c76,77
<         if (swWorker_create(swServer_get_worker(serv, index)) < 0)
---
>         worker = swServer_get_worker(serv, i);
>         if (swWorker_create(worker) < 0)
96c83
<     serv->reactor_pipe_num = (serv->reactor_num)? serv->worker_num / serv->reactor_num: 1;
---
>     serv->reactor_pipe_num = serv->worker_num / serv->reactor_num;
104d90
< 
109a96,101
> static __thread struct
> {
>     long target_worker_id;
>     swDataHead _send;
> } sw_notify_data;
> 
212d203
<     memset(&ev_data, 0, sizeof(ev_data));
230a222
> 
245a238
> 
259d251
< 
diff -r ./zan-extension/src/factory/FactoryThread.c ../swoole-1.8.5-stable/src/factory/FactoryThread.c
17,21c17,18
< #include "swWork.h"
< #include "swSignal.h"
< #include "swFactory.h"
< #include "swServer.h"
< #include "swBaseOperator.h"
---
> #include "swoole.h"
> #include "Server.h"
51,55c48
<     if (!factory || worker_num < 1){
<         return SW_ERR;
<     }
< 
<     swFactoryThread *object = NULL;
---
>     swFactoryThread *object;
67d59
<     	sw_free(object);
71,73c63,65
<     swReactorThread *thread = NULL;
<     int index;
<     for (index = 0; index < serv->reactor_num; index++)
---
>     int i;
>     swReactorThread *thread;
>     for (i = 0; i < serv->reactor_num; i++)
75c67
<         thread = swServer_get_thread(serv, index);
---
>         thread = swServer_get_thread(serv, i);
136d127
< 
187,188c178,181
< 
<     return SW_OK;
---
>     else
>     {
>         return SW_OK;
>     }
206c199,218
<     swoole_cpu_setAffinity(id,serv);
---
> #ifdef HAVE_CPU_AFFINITY
>     if (serv->open_cpu_affinity)
>     {
>         cpu_set_t cpu_set;
>         CPU_ZERO(&cpu_set);
>         if (serv->cpu_affinity_available_num)
>         {
>             CPU_SET(serv->cpu_affinity_available[id % serv->cpu_affinity_available_num], &cpu_set);
>         }
>         else
>         {
>             CPU_SET(id % SW_CPU_NUM, &cpu_set);
>         }
>         if (0 != pthread_setaffinity_np(pthread_self(), sizeof(cpu_set), &cpu_set))
>         {
>             swWarn("pthread_setaffinity_np() failed");
>         }
>     }
> #endif
> 
Only in ./zan-extension/src/factory: ProcessPool.c
Only in ./zan-extension/src/factory: ThreadPool.c
diff -r ./zan-extension/src/lock/AtomicLock.c ../swoole-1.8.5-stable/src/lock/AtomicLock.c
17,18c17
< #include "swBaseOperator.h"
< #include "swLock.h"
---
> #include "swoole.h"
26,29d24
< 	if (!lock){
< 		return SW_ERR;
< 	}
< 
diff -r ./zan-extension/src/lock/Cond.c ../swoole-1.8.5-stable/src/lock/Cond.c
17,18c17
< #include "swLock.h"
< #include "swLog.h"
---
> #include "swoole.h"
28c27
<     if (!cond || pthread_cond_init(&cond->cond, NULL) < 0)
---
>     if (pthread_cond_init(&cond->cond, NULL) < 0)
33d31
< 
diff -r ./zan-extension/src/lock/FileLock.c ../swoole-1.8.5-stable/src/lock/FileLock.c
17c17
< #include "swLock.h"
---
> #include "swoole.h"
28,31d27
< 	if (!lock){
< 		return SW_ERR;
< 	}
< 
diff -r ./zan-extension/src/lock/Mutex.c ../swoole-1.8.5-stable/src/lock/Mutex.c
17c17
< #include "swLock.h"
---
> #include "swoole.h"
26,30c26
<     if (!lock)
<     {
<         return SW_ERR;
<     }
<     
---
>     int ret;
32c28
< 
---
>     lock->type = SW_MUTEX;
34c30
<     if (use_in_process && pthread_mutexattr_setpshared(&lock->object.mutex.attr, PTHREAD_PROCESS_SHARED) < 0)
---
>     if (use_in_process == 1)
36c32
<         return SW_ERR;
---
>         pthread_mutexattr_setpshared(&lock->object.mutex.attr, PTHREAD_PROCESS_SHARED);
38,40c34
< 
< 
<     if (pthread_mutex_init(&lock->object.mutex._lock, &lock->object.mutex.attr) < 0)
---
>     if ((ret = pthread_mutex_init(&lock->object.mutex._lock, &lock->object.mutex.attr)) < 0)
44,45d37
< 
<     lock->type = SW_MUTEX;
90c82
<         if (pthread_mutex_trylock(&lock->object.mutex._lock)< 0)
---
>         if (pthread_mutex_trylock(&lock->object.mutex._lock) == 0)
92,93c84
<         	usleep(sleep_ms);
<         	timeout_msec -= sub;
---
>             return 0;
97c88,89
<         	return 0;
---
>             usleep(sleep_ms);
>             timeout_msec -= sub;
diff -r ./zan-extension/src/lock/RWLock.c ../swoole-1.8.5-stable/src/lock/RWLock.c
16a17
> #include "swoole.h"
20,21d20
< #include "swLock.h"
< 
31,34c30
< 	if (!lock){
< 		return SW_ERR;
< 	}
< 
---
>     int ret;
36,37c32,33
< 
<     if (use_in_process && pthread_rwlockattr_setpshared(&lock->object.rwlock.attr, PTHREAD_PROCESS_SHARED) < 0)
---
>     lock->type = SW_RWLOCK;
>     if (use_in_process == 1)
39c35
<         return SW_ERR;
---
>         pthread_rwlockattr_setpshared(&lock->object.rwlock.attr, PTHREAD_PROCESS_SHARED);
41d36
< 
46,47d40
< 
<     lock->type = SW_RWLOCK;
diff -r ./zan-extension/src/lock/Semaphore.c ../swoole-1.8.5-stable/src/lock/Semaphore.c
17,18c17
< #include "swLock.h"
< #include "swLog.h"
---
> #include "swoole.h"
27,30c26
< 	if (!lock){
< 		return SW_ERR;
< 	}
< 
---
>     int ret;
32,33c28,29
<     int ret = semget(key, 1, IPC_CREAT | 0666);
<     if (ret <= 0)
---
>     lock->type = SW_SEM;
>     if ((ret = semget(key, 1, IPC_CREAT | 0666)) < 0)
38c34
<     if (semctl(ret, 0, SETVAL, 1) < 0)
---
>     if (semctl(ret, 0, SETVAL, 1) == -1)
43,44d38
< 
<     lock->type = SW_SEM;
diff -r ./zan-extension/src/lock/SpinLock.c ../swoole-1.8.5-stable/src/lock/SpinLock.c
17c17
< #include "swLock.h"
---
> #include "swoole.h"
28,31c28
< 	if (!lock){
< 		return SW_ERR;
< 	}
< 
---
>     int ret;
33c30,31
<     if (pthread_spin_init(&lock->object.spinlock.lock_t, use_in_process) < 0)
---
>     lock->type = SW_SPINLOCK;
>     if ((ret = pthread_spin_init(&lock->object.spinlock.lock_t, use_in_process)) < 0)
35c33
<         return SW_ERR;
---
>         return -1;
37,38d34
< 
<     lock->type = SW_SPINLOCK;
43c39
<     return SW_OK;
---
>     return 0;
diff -r ./zan-extension/src/memory/Buffer.c ../swoole-1.8.5-stable/src/memory/Buffer.c
17,20c17,18
< 
< #include "swLog.h"
< #include "swMemory/memoryPool.h"
< #include "swMemory/buffer.h"
---
> #include "swoole.h"
> #include "buffer.h"
102d99
< 
120c117
<     void **will_free_trunk = NULL;  //free the point
---
>     void * *will_free_trunk;  //free the point
127d123
< 
132d127
< 
164c159
<     int index = 0;
---
>     int i = 0;
169,170c164,165
<     	index++;
<         printf("%d.\tlen=%d", index, trunk->length);
---
>         i++;
>         printf("%d.\tlen=%d", i, trunk->length);
175d169
< 
179d172
< 
diff -r ./zan-extension/src/memory/FixedPool.c ../swoole-1.8.5-stable/src/memory/FixedPool.c
17c17
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
98c98
<     swFixedPool_slice *slice = NULL;
---
>     swFixedPool_slice *slice;
104a105
> 
134c135
<     swFixedPool_slice *slice = NULL;
---
>     swFixedPool_slice *slice;
136a138
> 
166c168
<     swFixedPool_slice *slice = NULL;
---
>     swFixedPool_slice *slice;
168a171
> 
169a173
> 
226d229
<         }
227a231
>         }
diff -r ./zan-extension/src/memory/Malloc.c ../swoole-1.8.5-stable/src/memory/Malloc.c
17,18c17
< #include "swMemory/memoryPool.h"
< #include "swLog.h"
---
> #include "swoole.h"
24,36d22
< void* malloc_debug(const char* file,int line,const char* func,int __size)
< {
< 	void *ptr = malloc(__size);
< 	swWarn("malloc debug %s,%d,%s malloc %p",file,line,func,ptr);
< 	return ptr;
< }
< 
< void free_debug(const char* file,int line,const char* func,void* ptr)
< {
< 	swWarn("free debug %s,%d,%s free %p",file,line,func,ptr);
< 	free(ptr);
< }
< 
diff -r ./zan-extension/src/memory/MemoryGlobal.c ../swoole-1.8.5-stable/src/memory/MemoryGlobal.c
17,19c17
< #include "swLog.h"
< #include "swError.h"
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
22a21,32
> typedef struct _swMemoryGlobal
> {
>     int size;  //总容量
>     void *mem; //剩余内存的指针
>     int offset; //内存分配游标
>     char shared;
>     int pagesize;
>     swLock lock; //锁
>     void *root_page;
>     void *cur_page;
> } swMemoryGlobal;
> 
30c40
<     swMemoryGlobal gm, *gm_ptr = NULL;
---
>     swMemoryGlobal gm, *gm_ptr;
108d117
< 
diff -r ./zan-extension/src/memory/RingBuffer.c ../swoole-1.8.5-stable/src/memory/RingBuffer.c
17,19c17
< #include "swLog.h"
< #include "swError.h"
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
21c19,39
< static void swRingBuffer_destroy(swMemoryPool *pool);
---
> typedef struct
> {
>     uint8_t shared;
>     uint8_t status;
>     uint32_t size;
>     uint32_t alloc_offset;
>     uint32_t collect_offset;
>     uint32_t alloc_count;
>     sw_atomic_t free_count;
>     void *memory;
> } swRingBuffer;
> 
> typedef struct
> {
>     uint16_t lock;
>     uint16_t index;
>     uint32_t length;
>     char data[0];
> } swRingBuffer_item;
> 
> static void swRingBuffer_destory(swMemoryPool *pool);
55c73
<     pool->destroy = swRingBuffer_destroy;
---
>     pool->destroy = swRingBuffer_destory;
84,85c102
<             if (object->collect_offset + sizeof(swRingBuffer_item) >object->size ||
<             		object->collect_offset >= object->size)
---
>             if (object->collect_offset + sizeof(swRingBuffer_item) >object->size || object->collect_offset >= object->size)
90d106
< 
105c121
<     swRingBuffer_item *item = NULL;
---
>     swRingBuffer_item *item;
167c183
< //    assert(item->lock == 1);
---
>     assert(item->lock == 1);
184c200
< static void swRingBuffer_destroy(swMemoryPool *pool)
---
> static void swRingBuffer_destory(swMemoryPool *pool)
diff -r ./zan-extension/src/memory/ShareMemory.c ../swoole-1.8.5-stable/src/memory/ShareMemory.c
17,18c17
< #include "swLog.h"
< #include "swMemory/memoryPool.h"
---
> #include "swoole.h"
23a23
>     void *mem;
26c26
<     void *mem = swShareMemory_mmap_create(&object, size, NULL);
---
>     mem = swShareMemory_mmap_create(&object, size, NULL);
31,33c31,35
< 
<     memcpy(mem, &object, sizeof(swShareMemory));
<     return mem + sizeof(swShareMemory);
---
>     else
>     {
>         memcpy(mem, &object, sizeof(swShareMemory));
>         return mem + sizeof(swShareMemory);
>     }
38a41,42
>     void *mem;
>     void *ret_mem;
41c45
<     void *mem = swShareMemory_mmap_create(&object, size, NULL);
---
>     mem = swShareMemory_mmap_create(&object, size, NULL);
46,51c50,57
< 
< 	memcpy(mem, &object, sizeof(swShareMemory));
< 	void *ret_mem = mem + sizeof(swShareMemory);
< 	//calloc需要初始化
< 	bzero(ret_mem, size - sizeof(swShareMemory));
< 	return ret_mem;
---
>     else
>     {
>         memcpy(mem, &object, sizeof(swShareMemory));
>         ret_mem = mem + sizeof(swShareMemory);
>         //calloc需要初始化
>         bzero(ret_mem, size - sizeof(swShareMemory));
>         return ret_mem;
>     }
57a64,67
> #ifdef SW_DEBUG
>     char check = *(char *)(ptr + object->size); //尝试访问
>     swTrace("check:%c\n", check);
> #endif
64,68c74,79
<     if (object->size >= new_size){
<     	return ptr;
<     }
< 
<     void *new_ptr = sw_shm_malloc(new_size);
---
> #ifdef SW_DEBUG
>     char check = *(char *)(ptr + object->size); //尝试访问
>     swTrace("check:%c\n", check);
> #endif
>     void *new_ptr;
>     new_ptr = sw_shm_malloc(new_size);
73,76c84,89
< 
<     memcpy(new_ptr, ptr, object->size);
< 	sw_shm_free(ptr);
< 	return new_ptr;
---
>     else
>     {
>         memcpy(new_ptr, ptr, object->size);
>         sw_shm_free(ptr);
>         return new_ptr;
>     }
81,86c94
<     if (!object || size <= 0){
<     	return NULL;
<     }
< 
<     bzero(object, sizeof(swShareMemory));
<     int flag = MAP_SHARED;
---
>     void *mem;
87a96,98
>     int flag = MAP_SHARED;
>     bzero(object, sizeof(swShareMemory));
> 
91,96c102,106
< 
<     mapfile = (!mapfile)? "/dev/zero":mapfile;
<     strncpy(object->mapfile, mapfile, SW_SHM_MMAP_FILE_LEN);
< 
<     tmpfd = open(mapfile, O_RDWR);
<     if(tmpfd < 0)
---
>     if(mapfile == NULL)
>     {
>         mapfile = "/dev/zero";
>     }
>     if((tmpfd = open(mapfile, O_RDWR)) < 0)
100c110
< 
---
>     strncpy(object->mapfile, mapfile, SW_SHM_MMAP_FILE_LEN);
104c114
<     void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE, flag, tmpfd, 0);
---
>     mem = mmap(NULL, size, PROT_READ | PROT_WRITE, flag, tmpfd, 0);
129,134c139,141
< 	if (!object || size <= 0){
< 		return NULL;
< 	}
< 
< 	bzero(object, sizeof(swShareMemory));
<     key = (key == 0)? IPC_PRIVATE:key;
---
>     int shmid;
>     void *mem;
>     bzero(object, sizeof(swShareMemory));
135a143,146
>     if (key == 0)
>     {
>         key = IPC_PRIVATE;
>     }
137d147
<     int shmid = -1;
143,145c153
< 
<     void *mem = shmat(shmid, NULL, 0);
<     if ((int)mem < 0)
---
>     if ((mem = shmat(shmid, NULL, 0)) < 0)
162,165c170
< 	if (!object){
< 		return -1;
< 	}
< 
---
>     int shmid = object->shmid;
167c172
<     if (rm)
---
>     if (rm == 1)
169c174
<         shmctl(object->shmid, IPC_RMID, NULL);
---
>         shmctl(shmid, IPC_RMID, NULL);
171d175
< 
diff -r ./zan-extension/src/memory/Table.c ../swoole-1.8.5-stable/src/memory/Table.c
17,21c17,18
< 
< #include "swHash.h"
< #include "swBaseOperator.h"
< #include "swMemory/table.h"
< 
---
> #include "swoole.h"
> #include "table.h"
33,36d29
< 	if (!col){
< 		return ;
< 	}
< 
43,46d35
< 	if (!table){
< 		return;
< 	}
< 
47a37
> 
55,56c45,46
<     int index = 0, tmp_i = 0;
<     for (index = 0; index < table->list_n; index++)
---
>     int i, tmp_i = 0;
>     for (i = 0; i < table->list_n; i++)
58c48
<         if (table->rows_list[index] != NULL)
---
>         if (table->rows_list[i] != NULL)
60c50
<             tmp[tmp_i] = table->rows_list[index];
---
>             tmp[tmp_i] = table->rows_list[i];
70,71c60
< unlock:
<     table->lock.unlock(&table->lock);
---
>     unlock: table->lock.unlock(&table->lock);
82,83c71,72
<         uint32_t index = 10;
<         while ((1U << index) < rows_size)
---
>         uint32_t i = 10;
>         while ((1U << i) < rows_size)
85c74
<             index++;
---
>             i++;
87c76
<         rows_size = 1 << index;
---
>         rows_size = 1 << i;
95d83
< 
99d86
<         SwooleG.memory_pool->free(SwooleG.memory_pool,table);
102d88
< 
106,107d91
<     	table->lock.free(&table->lock);
<     	SwooleG.memory_pool->free(SwooleG.memory_pool,table);
111,112c95
< 
<     table->columns = swHashMap_create(SW_HASHMAP_INIT_BUCKET_N, (swHashMap_dtor)swTableColumn_free);
---
>     table->columns = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, (swHashMap_dtor)swTableColumn_free);
115,117d97
<     	sw_free(table->iterator);
<     	table->lock.free(&table->lock);
<     	SwooleG.memory_pool->free(SwooleG.memory_pool,table);
132,135d111
<     if (!col){
<     	return SW_ERR;
<     }
< 
139d114
<     	sw_free(col);
142d116
< 
180d153
< 
189,192d161
< 	if (!table){
< 		return SW_ERR;
< 	}
< 
236,237c205,206
<     int index;
<     for (index = 0; index < table->size; index++)
---
>     int i;
>     for (i = 0; i < table->size; i++)
239c208
<         table->rows[index] = memory + (row_memory_size * index);
---
>         table->rows[i] = memory + (row_memory_size * i);
241d209
< 
250,254d217
< 	if (!table)
< 	{
< 		return ;
< 	}
< 
265,266d227
< 
<     SwooleG.memory_pool->free(SwooleG.memory_pool,table);
288,291d248
< 	if (!table){
< 		return NULL;
< 	}
< 
292a250
> 
307,308c265,270
<     int index = 0;
<     for (index = 0; index < table->iterator->collision_index; index++)
---
>     if (table->iterator->collision_index == 0)
>     {
>         return row;
>     }
>     int i;
>     for (i = 0; i < table->iterator->collision_index; i++)
312d273
< 
318,321d278
< 	if (!table){
< 		return ;
< 	}
< 
324a282
> 
336,337c294,295
<             int index = 0;
<             while(index++)
---
>             int i = 0;
>             for (;; i++)
340c298
<                 if (index != table->iterator->collision_index)
---
>                 if (i == table->iterator->collision_index)
342c300,309
<                 	continue;
---
>                     if (row == NULL)
>                     {
>                         table->iterator->absolute_index++;
>                         table->iterator->collision_index = 0;
>                     }
>                     else
>                     {
>                         table->iterator->collision_index++;
>                     }
>                     return;
344,355d310
< 
<                 if (row == NULL)
< 				{
< 					table->iterator->absolute_index++;
< 					table->iterator->collision_index = 0;
< 				}
< 				else
< 				{
< 					table->iterator->collision_index++;
< 				}
< 
< 				return;
363,365c318,321
< 	if (!table){
< 		return NULL;
< 	}
---
>     if (keylen > SW_TABLE_KEY_SIZE)
>     {
>         keylen = SW_TABLE_KEY_SIZE;
>     }
367d322
< 	keylen = (keylen > SW_TABLE_KEY_SIZE)? SW_TABLE_KEY_SIZE:keylen;
381d335
< 
400,404c354,357
< 	if (!table){
< 			return NULL;
< 	}
< 
< 	keylen = (keylen > SW_TABLE_KEY_SIZE)? SW_TABLE_KEY_SIZE:keylen;
---
>     if (keylen > SW_TABLE_KEY_SIZE)
>     {
>         keylen = SW_TABLE_KEY_SIZE;
>     }
472,476c425,428
< 	if (!table){
< 		return SW_ERR;
< 	}
< 
< 	keylen = (keylen > SW_TABLE_KEY_SIZE)? SW_TABLE_KEY_SIZE:keylen;
---
>     if (keylen > SW_TABLE_KEY_SIZE)
>     {
>         keylen = SW_TABLE_KEY_SIZE;
>     }
diff -r ./zan-extension/src/network/Client.c ../swoole-1.8.5-stable/src/network/Client.c
17,20c17,18
< #include "swReactor.h"
< #include "swLog.h"
< #include "swDNS.h"
< #include "swClient.h"
---
> #include "swoole.h"
> #include "Client.h"
28d25
< static int swClient_udp_sendto(swClient *cli, char *data, int length, int flags);
36d32
< static int swClient_free(swClient *cli);
48a45
> static swHashMap *swoole_dns_cache = NULL;
50a48,54
> typedef struct
> {
>     int length;
>     char addr[0];
> 
> } swDNS_cache;
> 
53,54c57,91
<     int _type,_domain;
<     int sockfd = swSocket_create(type,&_type,&_domain);
---
>     int _domain;
>     int _type;
> 
>     bzero(cli, sizeof(*cli));
>     switch (type)
>     {
>     case SW_SOCK_TCP:
>         _domain = AF_INET;
>         _type = SOCK_STREAM;
>         break;
>     case SW_SOCK_TCP6:
>         _domain = AF_INET6;
>         _type = SOCK_STREAM;
>         break;
>     case SW_SOCK_UNIX_STREAM:
>         _domain = AF_UNIX;
>         _type = SOCK_STREAM;
>         break;
>     case SW_SOCK_UDP:
>         _domain = AF_INET;
>         _type = SOCK_DGRAM;
>         break;
>     case SW_SOCK_UDP6:
>         _domain = AF_INET6;
>         _type = SOCK_DGRAM;
>         break;
>     case SW_SOCK_UNIX_DGRAM:
>         _domain = AF_UNIX;
>         _type = SOCK_DGRAM;
>         break;
>     default:
>         return SW_ERR;
>     }
> 
>     int sockfd = socket(_domain, _type, 0);
56a94
>         swWarn("socket() failed. Error: %s[%d]", strerror(errno), errno);
59,75c97,105
<     
<     cli->socket = async? swReactor_get(SwooleG.main_reactor, sockfd) : sw_malloc(sizeof(swConnection));
< 	if (!cli->socket)
< 	{
< 		swWarn("malloc(%d) failed.", (int ) sizeof(swConnection));
< 		close(sockfd);
< 		return SW_ERR;
< 	}
< 
< 	cli->type = type;
< 	cli->_sock_type = _type;
< 	cli->_sock_domain = _domain;
< 
< 	bzero(cli->socket, sizeof(swConnection));
< 	cli->socket->fd = sockfd;
< 	cli->socket->object = cli;
< 	cli->socket->socket_type = type;
---
> 
>     if (async)
>     {
>         cli->socket = swReactor_get(SwooleG.main_reactor, sockfd);
>     }
>     else
>     {
>         cli->socket = sw_malloc(sizeof(swConnection));
>     }
78,79d107
<     cli->type = type;
<     cli->async = async;
81c109,119
<     if (cli->async)
---
>     if (!cli->socket)
>     {
>         swWarn("malloc(%d) failed.", (int ) sizeof(swConnection));
>         return SW_ERR;
>     }
> 
>     bzero(cli->socket, sizeof(swConnection));
>     cli->socket->fd = sockfd;
>     cli->socket->object = cli;
> 
>     if (async)
83c121
<         swSetNonBlock(cli->socket->fd,1);
---
>         swSetNonBlock(cli->socket->fd);
94c132
<     if (swSocket_is_stream(cli->type))
---
>     if (swSocket_is_stream(type))
97,99c135,146
<         cli->connect = (cli->async)? swClient_tcp_connect_async : swClient_tcp_connect_sync;
<         cli->send = (cli->async)? swClient_tcp_send_async:swClient_tcp_send_sync;
<         cli->sendfile = (cli->async)? swClient_tcp_sendfile_async:swClient_tcp_sendfile_sync;
---
>         if (async)
>         {
>             cli->connect = swClient_tcp_connect_async;
>             cli->send = swClient_tcp_send_async;
>             cli->sendfile = swClient_tcp_sendfile_async;
>         }
>         else
>         {
>             cli->connect = swClient_tcp_connect_sync;
>             cli->send = swClient_tcp_send_sync;
>             cli->sendfile = swClient_tcp_sendfile_sync;
>         }
105c152
<         cli->send = swClient_udp_sendto;
---
>         cli->send = swClient_udp_send;
107a155,157
>     cli->_sock_domain = _domain;
>     cli->_sock_type = _type;
> 
108a159,161
>     cli->type = type;
>     cli->async = async;
> 
115,118d167
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
124d172
< 
131,134d178
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
<     
150c194
< static int swClient_free(swClient *cli)
---
> static int swClient_inet_addr(swClient *cli, char *host, int port)
152c196,227
<     if (!cli || !cli->socket) {
---
>     struct hostent *host_entry;
>     void *s_addr = NULL;
> 
>     if (cli->type == SW_SOCK_TCP || cli->type == SW_SOCK_UDP)
>     {
>         cli->server_addr.addr.inet_v4.sin_family = AF_INET;
>         cli->server_addr.addr.inet_v4.sin_port = htons(port);
>         cli->server_addr.len = sizeof(cli->server_addr.addr.inet_v4);
>         s_addr = &cli->server_addr.addr.inet_v4.sin_addr.s_addr;
> 
>         if (inet_pton(AF_INET, host, s_addr))
>         {
>             return SW_OK;
>         }
>     }
>     else if (cli->type == SW_SOCK_TCP6 || cli->type == SW_SOCK_UDP6)
>     {
>         cli->server_addr.addr.inet_v6.sin6_family = AF_INET6;
>         cli->server_addr.addr.inet_v6.sin6_port = htons(port);
>         cli->server_addr.len = sizeof(cli->server_addr.addr.inet_v6);
>         s_addr = cli->server_addr.addr.inet_v6.sin6_addr.s6_addr;
> 
>         if (inet_pton(AF_INET6, host, s_addr))
>         {
>             return SW_OK;
>         }
>     }
>     else if (cli->type == SW_SOCK_UNIX_STREAM || cli->type == SW_SOCK_UNIX_DGRAM)
>     {
>         cli->server_addr.addr.un.sun_family = AF_UNIX;
>         strncpy(cli->server_addr.addr.un.sun_path, host, sizeof(cli->server_addr.addr.un.sun_path));
>         cli->server_addr.len = sizeof(cli->server_addr.addr.un);
156,157c231,269
< //    //remove from reactor
< //    cli->close(cli);
---
>     if (!swoole_dns_cache)
>     {
>         swoole_dns_cache = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, free);
>     }
> 
>     swDNS_cache *cache = swHashMap_find(swoole_dns_cache, host, strlen(host));
>     if (cache == NULL)
>     {
>         if (cli->async)
>         {
>             swWarn("DNS lookup will block the process. Please use swoole_async_dns_lookup.");
>         }
>         if (!(host_entry = gethostbyname(host)))
>         {
>             swWarn("gethostbyname('%s') failed.", host);
>             return SW_ERR;
>         }
>         if (host_entry->h_addrtype != AF_INET)
>         {
>             swWarn("Host lookup failed: Non AF_INET domain returned on AF_INET socket.");
>             return 0;
>         }
>         cache = sw_malloc(sizeof(int) + host_entry->h_length);
>         if (cache == NULL)
>         {
>             swWarn("malloc() failed.");
>             memcpy(s_addr, host_entry->h_addr_list[0], host_entry->h_length);
>             return SW_OK;
>         }
>         else
>         {
>             memcpy(cache->addr, host_entry->h_addr_list[0], host_entry->h_length);
>             cache->length = host_entry->h_length;
>         }
>         swHashMap_add(swoole_dns_cache, host, strlen(host), cache);
>     }
>     memcpy(s_addr, cache->addr, cache->length);
>     return SW_OK;
> }
158a271,278
> void swClient_free(swClient *cli)
> {
>     assert(cli->socket->fd != 0);
>     //remove from reactor
>     if (!cli->socket->closed)
>     {
>         cli->close(cli);
>     }
169d288
< 
174,175d292
<         cli->socket->closed = 1;
<         cli->socket = NULL;
181,182d297
< 
<     return SW_OK;
187,190d301
<     if (!cli || !cli->socket) {
<         return SW_OK;
<     }
< 
192c303
<     int needClosefd = !cli->socket->closed;
---
>     assert(fd != 0);
200d310
< 
202,203d311
<         cli->ssl_context = NULL;
< 
207d314
<             cli->ssl_cert_file = NULL;
212d318
<             cli->ssl_key_file = NULL;
225d330
<         cli->type = SW_SOCK_UNKNOW;
227c332,335
< 
---
>     if (cli->socket->closed)
>     {
>         return SW_OK;
>     }
229d336
<     int needCallback = 0;
237d343
<     
242c348
<             needCallback = 1;
---
>             cli->onClose(cli);
249,262c355
< 
<     swClient_free(cli);
< 
<     if (needCallback)
<     {
<     	cli->onClose(cli);
<     }
< 
<     if (needClosefd)
<     {
<     	close(fd);
<     }
< 
<     return SW_OK;
---
>     return close(fd);
267,271c360
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
<     int ret = -1;
---
>     int ret;
272a362
> 
278,283c368
<     if (cli->timeout > 0)
<     {
<     	swSocket_set_timeout(cli->socket->fd,cli->timeout);
<     }
< 
<     if (nonblock || cli->timeout > 0)
---
>     if (nonblock == 1)
285,363c370
<     	swSetNonBlock(cli->socket->fd,1);
<     }
< 
< 	ret = connect(cli->socket->fd, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
< 	if (ret < 0 && errno != EINPROGRESS)
< 	{
< 		return ret;
< 	}
< 
< 	int timeout_set = (cli->timeout >= 0)?cli->timeout*1000:0;
< 	if ((ret < 0 && errno == EINPROGRESS) && timeout_set > 0 &&
< 			swSocket_wait(cli->socket->fd,timeout_set,SW_EVENT_WRITE) >= 0)
< 	{
< 		ret = SW_OK;
< 		int error = 0;
< 		socklen_t len = sizeof(error);
< 		if (getsockopt(cli->socket->fd,SOL_SOCKET,SO_ERROR,&error,&len) < 0 || error != 0)
< 		{
< 			swWarn("get socket option %s\n",error? strerror(error):"error");
< 			ret = SW_ERR;
< 		}
< 	}
< 
< 	if (ret >= 0)
< 	{
< 		if (cli->timeout > 0 && !nonblock)
< 		{
< 			swSetNonBlock(cli->socket->fd,0);
< 		}
< 
< #ifdef SW_USE_OPENSSL
<     	if (cli->open_ssl)
<     	{
<         	if (swClient_enable_ssl_encrypt(cli) < 0 || swClient_ssl_handshake(cli) < 0)
<         	{
<             	return SW_ERR;
<         	}
<     	}
< #endif
<     	cli->socket->active = 1;
< 	}
< 	
<     return ret;
< }
< 
< /// 异步方式，需业务去解析域名，同步方式，内部阻塞解析域名
< static int swClient_inet_addr(swClient *cli, char *host, int port)
< {
< 	int hostLen = strlen(host);
< 	if (NULL == host || hostLen <= 0 || port < 0)
< 	{
< 		swWarn("%s:%d invailed host:port.",host,port);
< 		return SW_ERR;
< 	}
< 
<     void *s_addr = NULL;
<     int type = -1;
<     if (cli->type == SW_SOCK_TCP || cli->type == SW_SOCK_UDP)
<     {
<         cli->server_addr.addr.inet_v4.sin_family = AF_INET;
<         cli->server_addr.addr.inet_v4.sin_port = htons(port);
<         cli->server_addr.len = sizeof(cli->server_addr.addr.inet_v4);
<         s_addr = &cli->server_addr.addr.inet_v4.sin_addr.s_addr;
<         type = AF_INET;
<     }
<     else if (cli->type == SW_SOCK_TCP6 || cli->type == SW_SOCK_UDP6)
<     {
<         cli->server_addr.addr.inet_v6.sin6_family = AF_INET6;
<         cli->server_addr.addr.inet_v6.sin6_port = htons(port);
<         cli->server_addr.len = sizeof(cli->server_addr.addr.inet_v6);
<         s_addr = &cli->server_addr.addr.inet_v6.sin6_addr.s6_addr;
<         type = AF_INET6;
<     }
<     else if (cli->type == SW_SOCK_UNIX_STREAM || cli->type == SW_SOCK_UNIX_DGRAM)
<     {
<         cli->server_addr.addr.un.sun_family = AF_UNIX;
<         strncpy(cli->server_addr.addr.un.sun_path, host, sizeof(cli->server_addr.addr.un.sun_path));
<         cli->server_addr.len = sizeof(cli->server_addr.addr.un);
<         return SW_OK;
---
>         swSetNonBlock(cli->socket->fd);
367c374,378
<     	return SW_ERR;
---
>         if (cli->timeout > 0)
>         {
>             swSocket_set_timeout(cli->socket->fd, timeout);
>         }
>         swSetBlock(cli->socket->fd);
369,372c380
<     ///地址校验
<     int checkAddr = inet_pton(type,host, s_addr);
<     /// 异步客户端，需要自行解析地址
<     if (cli->async && checkAddr != 1)
---
>     while (1)
374c382,390
<         return SW_ERR;
---
>         ret = connect(cli->socket->fd, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
>         if (ret < 0)
>         {
>             if (errno == EINTR)
>             {
>                 continue;
>             }
>         }
>         break;
376,383d391
<     else if (!cli->async && checkAddr != 1)
<     {
<     	/// 非异步客户端，阻塞方式域名解析
<     	char ipaddr[SW_IP_MAX_LENGTH] = {0};
<     	int iret = swoole_gethostbyname(type,host,ipaddr,SW_IP_MAX_LENGTH);
<     	if (iret < 0){
<     		return SW_ERR;
<     	}
385,388c393,408
<     	iret = inet_pton(type,ipaddr,s_addr);
<     	if (iret != 1){
<     		return SW_ERR;
<     	}
---
>     if (ret >= 0)
>     {
>         cli->socket->active = 1;
> #ifdef SW_USE_OPENSSL
>         if (cli->open_ssl)
>         {
>             if (swClient_enable_ssl_encrypt(cli) < 0)
>             {
>                 return SW_ERR;
>             }
>             if (swClient_ssl_handshake(cli) < 0)
>             {
>                 return SW_ERR;
>             }
>         }
> #endif
391c411
<     return SW_OK;
---
>     return ret;
396c416,422
<     if (!cli || !cli->socket) {
---
>     int ret;
>     cli->timeout = timeout;
> 
>     //alloc input memory buffer
>     cli->buffer = swString_new(cli->buffer_input_size);
>     if (!cli->buffer)
>     {
406,411c432
<     int ret = 0;
<     cli->timeout = timeout;
< 
<     //alloc input memory buffer
<     cli->buffer = swString_new(cli->buffer_input_size);
<     if (!cli->buffer)
---
>     if (swClient_inet_addr(cli, host, port) < 0)
416,417c437
<     /// 地址解析由dns 模块提供，不再自己处理
<     if (swClient_inet_addr(cli, host, port) < 0)
---
>     if (cli->type == SW_SOCK_UNIX_STREAM)
419c439,459
<         return SW_ERR;
---
>         while (1)
>         {
>             ret = connect(cli->socket->fd, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
>             if (ret < 0)
>             {
>                 if (errno == EINTR)
>                 {
>                     continue;
>                 }
>             }
>             break;
>         }
>         if (ret == 0)
>         {
>             SwooleG.main_reactor->add(SwooleG.main_reactor, cli->socket->fd, SW_FD_STREAM_CLIENT | SW_EVENT_WRITE);
>         }
>         else
>         {
>             SwooleG.error = errno;
>         }
>         return ret;
422,435c462,472
<     /// 出现返回错误，还需要继续处理; ret == 0时需要，表示连接成了，还是需要继续处理
< 	ret = connect(cli->socket->fd, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
< 	if (ret == 0 || (ret < 0 && errno == EINPROGRESS))
< 	{
< 		ret = SwooleG.main_reactor->add(SwooleG.main_reactor, cli->socket->fd, cli->reactor_fdtype | SW_EVENT_WRITE);
< 	}
< 
<     return ret < 0? SW_ERR:SW_OK;
< }
< 
< static int swClient_tcp_send_async(swClient *cli, char *data, int length, int flags)
< {
<     if (!cli || !cli->socket) {
<         return SW_ERR;
---
>     while (1)
>     {
>         ret = connect(cli->socket->fd, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
>         if (ret < 0)
>         {
>             if (errno == EINTR)
>             {
>                 continue;
>             }
>         }
>         break;
438c475
<     if (length <= 0 || !data)
---
>     if (ret < 0 &&  errno == EINPROGRESS)
440c477,481
<         return SW_ERR;
---
>         if (SwooleG.main_reactor->add(SwooleG.main_reactor, cli->socket->fd, cli->reactor_fdtype | SW_EVENT_WRITE) < 0)
>         {
>             return SW_ERR;
>         }
>         return SW_OK;
443,444c484
<     int iret = SwooleG.main_reactor->write(SwooleG.main_reactor, cli->socket->fd, data, length);
<     return iret < 0? SW_ERR:length;
---
>     return ret;
447c487
< static int swClient_tcp_send_sync(swClient *cli, char *data, int length, int flags)
---
> static int swClient_tcp_send_async(swClient *cli, char *data, int length, int flags)
449c489,490
<     if (!cli || !cli->socket) {
---
>     if (SwooleG.main_reactor->write(SwooleG.main_reactor, cli->socket->fd, data, length) < 0)
>     {
452,453c493
< 
<     if (length <= 0 || !data)
---
>     else
455c495
<         return SW_ERR;
---
>         return length;
456a497
> }
457a499,500
> static int swClient_tcp_send_sync(swClient *cli, char *data, int length, int flags)
> {
459c502,505
<     int n = -1;
---
>     int n;
> 
>     assert(length > 0);
>     assert(data != NULL);
480d525
< 
484d528
< 
490,493d533
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
499d538
< 
505,509c544,545
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
<     if (swConnection_sendfile_async(cli->socket, filename) < 0){
---
>     if (swConnection_sendfile(cli->socket, filename) < 0)
>     {
513,528d548
< 
<     swConnection *socket = cli->socket;
<     if (!(socket->events & SW_EVENT_WRITE))
< 	{
< 		if (socket->events & SW_EVENT_READ)
< 		{
< 			return SwooleG.main_reactor->set(SwooleG.main_reactor, socket->fd,
< 					           socket->fdtype | SW_EVENT_READ | SW_EVENT_WRITE);
< 		}
< 		else
< 		{
< 			return SwooleG.main_reactor->add(SwooleG.main_reactor, socket->fd,
< 					           socket->fdtype | SW_EVENT_WRITE);
< 		}
< 	}
< 
534,537d553
<     if (!cli ||!cli->socket || !data) {
<         return SW_ERR;
<     }
< 
544,559c560,572
<     
<     int recvLen = 0;
<     do{
<     	int ret = swConnection_recv(cli->socket, data + recvLen, len - recvLen, flag);
<     	if (ret < 0 && EINTR == errno){
<     		continue;
<     	}
<     	else if(ret < 0){
<     		return SW_ERR;
<     	}
<     	else{
< 			recvLen += ret;
<     		return recvLen;
<     	}
< 
<     }while(1);
---
>     int ret = swConnection_recv(cli->socket, data, len, flag);
>     if (ret < 0)
>     {
>         if (errno == EINTR)
>         {
>             ret = swConnection_recv(cli->socket, data, len, flag);
>         }
>         else
>         {
>             return SW_ERR;
>         }
>     }
>     return ret;
564,567d576
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
572a582
>     cli->socket->active = 1;
576c586
<     if (cli->timeout > 0)
---
>     if (timeout > 0)
578c588
<         swSocket_set_timeout(cli->socket->fd, cli->timeout);
---
>         swSocket_set_timeout(cli->socket->fd, timeout);
594c604
<     else if (!udp_connect)
---
>     else if (udp_connect != 1)
599c609
<     if (connect(cli->socket->fd, (struct sockaddr *) (&cli->server_addr), cli->server_addr.len) >= 0)
---
>     if (connect(cli->socket->fd, (struct sockaddr *) (&cli->server_addr), cli->server_addr.len) == 0)
602c612
<         cli->send = swClient_udp_send;
---
>         connect_ok:
604d613
< connect_ok:
608,609c617
<         cli->socket->active = 1;
<         if (cli->async)
---
>         if (cli->async && cli->onConnect)
615,616c623
< 
<             if (cli->onConnect) cli->onConnect(cli);
---
>             cli->onConnect(cli);
618d624
< 
629c635
< static int swClient_udp_sendto(swClient *cli, char *data, int len, int flags)
---
> static int swClient_udp_send(swClient *cli, char *data, int len, int flags)
631,638c637,638
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
<     int n = -1;
< 
<     n = cli->async? send(cli->socket->fd,data,len,flags):
<     		sendto(cli->socket->fd, data, len, 0, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
---
>     int n;
>     n = sendto(cli->socket->fd, data, len, 0, (struct sockaddr *) &cli->server_addr.addr, cli->server_addr.len);
649,667d648
< static int swClient_udp_send(swClient *cli, char *data, int len, int flags)
< {
< 	if (!cli || !cli->socket) {
< 	        return SW_ERR;
< 	}
< 
< 	int n = -1;
< 
< 	n = send(cli->socket->fd,data,len,flags);
< 	if (n < 0 || n < len)
< 	{
< 		return SW_ERR;
< 	}
< 	else
< 	{
< 		return n;
< 	}
< }
< 
670,673d650
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
675,688c652,664
< 
< 	do{
< 		int ret = recvfrom(cli->socket->fd, data, length, flags, (struct sockaddr *) &cli->remote_addr.addr, &cli->remote_addr.len);
< 		if (ret < 0 && EINTR == errno){
< 			continue;
< 		}
< 		else if (ret < 0){
< 			return SW_ERR;
< 		}
< 		else{
< 			return ret;
< 		}
< 
< 	}while(1);
---
>     int ret = recvfrom(cli->socket->fd, data, length, flags, (struct sockaddr *) &cli->remote_addr.addr, &cli->remote_addr.len);
>     if (ret < 0)
>     {
>         if (errno == EINTR)
>         {
>             ret = recvfrom(cli->socket->fd, data, length, flags, (struct sockaddr *) &cli->remote_addr, &cli->remote_addr.len);
>         }
>         else
>         {
>             return SW_ERR;
>         }
>     }
>     return ret;
695,698c671
<     if (NULL == cli || !cli->socket) {
<         return SW_ERR;
<     }
< 
---
>     char *buf = cli->buffer->str;
700c673
<    
---
> 
725,727c698,714
<         n = (cli->open_eof_check)? swProtocol_recv_check_eof(protocol, conn, cli->buffer):
<         		swProtocol_recv_check_length(protocol, conn, cli->buffer);
<         return (n < 0)? cli->close(cli):SW_OK;
---
>         if (cli->open_eof_check)
>         {
>             n = swProtocol_recv_check_eof(protocol, conn, cli->buffer);
>         }
>         else
>         {
>             n = swProtocol_recv_check_length(protocol, conn, cli->buffer);
>         }
> 
>         if (n < 0)
>         {
>             return  cli->close(cli);
>         }
>         else
>         {
>             return SW_OK;
>         }
741,742c728
<             int needExtentBuf = buf_size > cli->buffer->size;
<             if (needExtentBuf && swString_extend(cli->buffer, buf_size) < 0)
---
>             if (buf_size > cli->buffer->size)
744c730
<             	return cli->close(cli);
---
>                 swString_extend(cli->buffer, buf_size);
752c738
<     n = swConnection_recv(event->socket, cli->buffer->str, buf_size, 0);
---
>     n = swConnection_recv(event->socket, buf, buf_size, 0);
775c761
<         cli->onReceive(cli, cli->buffer->str, n);
---
>         cli->onReceive(cli, buf, n);
790,792c776
<     if (!cli || !cli->socket) {
<         return SW_ERR;
<     }
---
>     char buffer[SW_BUFFER_SIZE_UDP];
794d777
<     char buffer[SW_BUFFER_SIZE_UDP] = {0};
804d786
< 
811,817c793,794
<     if (cli == NULL || cli->socket == NULL) {
<         return SW_ERR;
<     }
< 
<     uint32_t fd_active = cli->socket->active;
<     cli->close(cli);
<     if (!fd_active && cli->onError)
---
>     int ret = cli->close(cli);
>     if (!cli->socket->active && cli->onError)
819c796
<     	cli->onError(cli);
---
>         cli->onError(cli);
821,822c798
< 
<     return SW_OK;
---
>     return ret;
828,830d803
<     if (cli == NULL || !cli->socket) {
<         return SW_ERR;
<     }
851,860c824
<         if (swReactor_onWrite(SwooleG.main_reactor, event) != SW_OK)
<         {
<         	cli->close(cli);
< 			if (cli->onError)
< 			{
< 				cli->onError(cli);
< 			}
<         }
< 
<         return SW_OK;
---
>         return swReactor_onWrite(SwooleG.main_reactor, event);
870c834
<     //success,连接成功，表示可写
---
>     //success
873c837
<     	//listen read event,设置可读事件
---
>         //listen read event
893d856
< 
908,915c871,875
<         /// close 不会回调给外部，只有onError会回调
< //        cli->close(cli);
< //        if (cli->onError)
< //        {
< //            cli->onError(cli);
< //        }
< 
< 		swClient_onError(reactor,event);
---
>         cli->close(cli);
>         if (cli->onError)
>         {
>             cli->onError(cli);
>         }
920a881,895
> void swoole_open_remote_debug(void)
> {
>     swClient debug_client;
>     swClient_create(&debug_client, SW_SOCK_UDP, 0);
> 
>     if (debug_client.connect(&debug_client, SW_DEBUG_SERVER_HOST, SW_DEBUG_SERVER_PORT, -1, 1) < 0)
>     {
>         swWarn("connect to remote_debug_server[%s:%d] failed.", SW_DEBUG_SERVER_HOST, SW_DEBUG_SERVER_PORT);
>         SwooleG.debug_fd = 1;
>     }
>     else
>     {
>         SwooleG.debug_fd = debug_client.socket->fd;
>     }
> }
diff -r ./zan-extension/src/network/Connection.c ../swoole-1.8.5-stable/src/network/Connection.c
19,27c19,21
< 
< #include "swServer.h"
< #include "swSendfile.h"
< #include "swConnection.h"
< #include "swBaseOperator.h"
< 
< #ifdef SW_USE_OPENSSL
< #include "swProtocol/ssl.h"
< #endif
---
> #include "swoole.h"
> #include "Server.h"
> #include "Connection.h"
35,43c29
< typedef struct {
< 	char *filename;
< 	uint16_t name_len;
< 	int fd;
< 	off_t filesize;
< 	off_t offset;
< } swTask_sendfile;
< 
< 
---
> static char *str_ptr = NULL;
74,75c60
<     int sendn = (task->filesize - task->offset > SW_SENDFILE_TRUNK) ?
<     			SW_SENDFILE_TRUNK : task->filesize - task->offset;
---
>     int sendn = (task->filesize - task->offset > SW_SENDFILE_TRUNK) ? SW_SENDFILE_TRUNK : task->filesize - task->offset;
189c174
< int swConnection_get_ip(swConnection *conn,char* addip,int len)
---
> char* swConnection_get_ip(swConnection *conn)
191,198c176
<     if (len < SW_IP_MAX_LENGTH || !addip){
<         swWarn("swConnnection get ip cache len must more than %d\n",SW_IP_MAX_LENGTH);
<         return SW_ERR;
<     }
< 
<     const char	*ipstr = NULL;
<     bzero(addip,len);
<     if (swSocket_is_NET(conn->socket_type))
---
>     if (conn->socket_type == SW_SOCK_TCP)
200,203c178
<         ipstr = inet_ntop(AF_INET,&conn->info.addr.inet_v4.sin_addr,addip,len);
<     }
<     else if (swSocket_is_NET6(conn->socket_type)){
<         ipstr = inet_ntop(AF_INET6, &conn->info.addr.inet_v6.sin6_addr,addip,len);
---
>         return inet_ntoa(conn->info.addr.inet_v4.sin_addr);
205,226c180
< 
<     return (NULL == ipstr)? SW_ERR:SW_OK;
< }
< 
< int swConnection_get_port(swConnection *conn)
< {
<     if (swSocket_is_NET(conn->socket_type))
<     {
<         return ntohs(conn->info.addr.inet_v4.sin_port);
<     }
<     else if (swSocket_is_NET6(conn->socket_type))
<     {
<         return ntohs(conn->info.addr.inet_v6.sin6_port);
<     }
< 
<     return SW_ERR;
< }
< 
< ssize_t swConnection_recv(swConnection *conn, void *__buf, size_t __n, int __flags)
< {
< #ifdef SW_USE_OPENSSL
<     if (conn->ssl)
---
>     else
228,231c182
<         int ret = 0;
<         int written = 0;
< 
<         while(written < __n)
---
>         if (str_ptr)
233,248c184,194
<             ret = swSSL_recv(conn, __buf + written, __n - written);
<             if (__flags & MSG_WAITALL)
<             {
<                 if (ret <= 0)
<                 {
<                     return ret;
<                 }
<                 else
<                 {
<                     written += ret;
<                 }
<             }
<             else
<             {
<                 return ret;
<             }
---
>             free(str_ptr);
>         }
>         char tmp[INET6_ADDRSTRLEN];
>         if (inet_ntop(AF_INET6, &conn->info.addr.inet_v6.sin6_addr, tmp, sizeof(tmp)) == NULL)
>         {
>             return NULL;
>         }
>         else
>         {
>             str_ptr = strdup(tmp);
>             return str_ptr;
250,255d195
< 
<         return written;
<     }
<     else
<     {
<         return recv(conn->fd, __buf, __n, __flags);
257,259d196
< #else
<     return recv(conn->fd, __buf, __n, __flags);
< #endif
262c199
< int swConnection_send(swConnection *conn, void *__buf, size_t __n, int __flags)
---
> int swConnection_get_port(swConnection *conn)
264,265c201
< #ifdef SW_USE_OPENSSL
<     if (conn->ssl)
---
>     if (conn->socket_type == SW_SOCK_TCP)
267c203
<         return swSSL_send(conn, __buf, __n);
---
>         return ntohs(conn->info.addr.inet_v4.sin_port);
271,319c207
<         return send(conn->fd, __buf, __n, __flags);
<     }
< #else
<     return send(conn->fd, __buf, __n, __flags);
< #endif
< }
< 
< int swConnection_sendfile_sync(swConnection *conn, char *filename, double timeout)
< {
<     if (conn->closed)
<     {
<         return SW_ERR;        
<     }
< 
<     int timeout_ms = timeout < 0 ? -1 : timeout * 1000;
<     int sock = conn->fd;
<     int file_fd = open(filename, O_RDONLY);
<     if (file_fd < 0)
<     {
<         swWarn("open(%s) failed. Error: %s[%d]", filename, strerror(errno), errno);
<         return SW_ERR;
<     }
< 
<     int iret = SW_OK;
<     int sendn = 0;
<     off_t offset = 0;
<     size_t file_size = get_filelen(file_fd);
<     if (file_size <= 0)
<     {
<         goto end;
<     }
< 
<     while (offset < file_size)
<     {
<         if (swSocket_wait(sock, timeout_ms, SW_EVENT_WRITE) < 0)
<         {
<             iret = SW_ERR;
<             goto end;
<         }
<         else
<         {
<             sendn = (file_size - offset > SW_SENDFILE_TRUNK) ? SW_SENDFILE_TRUNK : file_size - offset;
<             if (swoole_sendfile(sock, file_fd, &offset, sendn) <= 0)
<             {
<                 iret = SW_ERR;
<                 swSysError("sendfile(%d, %s) failed.", sock, filename);
<                 goto end;
<             }
<         }
---
>         return ntohs(conn->info.addr.inet_v6.sin6_port);
321,324d208
< 
< end:
<     close(file_fd);
<     return iret;
335c219
< int swConnection_sendfile_async(swConnection *conn, char *filename)
---
> int swConnection_sendfile(swConnection *conn, char *filename)
337,345c221
<     int file_fd = open(filename, O_RDONLY);
<     if (file_fd < 0)
<     {
<         swSysError("open(%s) failed.",filename);
<         return SW_ERR;
<     }
< 
<     size_t filelen = get_filelen(file_fd);
<     if (filelen <= 0)
---
>     if (conn->out_buffer == NULL)
347,348c223,227
<         close(file_fd);
<         return SW_ERR;
---
>         conn->out_buffer = swBuffer_new(SW_BUFFER_SIZE);
>         if (conn->out_buffer == NULL)
>         {
>             return SW_ERR;
>         }
350a230
>     swBuffer_trunk error_chunk;
354d233
<         close(file_fd);
358d236
< 
359a238
> 
360a240,247
>     int file_fd = open(filename, O_RDONLY);
>     if (file_fd < 0)
>     {
>         free(task->filename);
>         free(task);
>         swSysError("open(%s) failed.", task->filename);
>         return SW_ERR;
>     }
362d248
<     task->filesize = filelen;
364,365c250,261
<     swBuffer_trunk *chunk = swConnection_get_out_buffer(conn, SW_CHUNK_SENDFILE);
<     if (!chunk)
---
>     struct stat file_stat;
>     if (fstat(file_fd, &file_stat) < 0)
>     {
>         swSysError("fstat(%s) failed.", filename);
>         error_chunk.store.ptr = task;
>         swConnection_sendfile_destructor(&error_chunk);
>         return SW_ERR;
>     }
>     task->filesize = file_stat.st_size;
> 
>     swBuffer_trunk *chunk = swBuffer_new_trunk(conn->out_buffer, SW_CHUNK_SENDFILE, 0);
>     if (chunk == NULL)
368d263
<         swBuffer_trunk error_chunk;
398a294
>         //buffer create failed
Only in ../swoole-1.8.5-stable/src/network: DNS.c
diff -r ./zan-extension/src/network/Manager.c ../swoole-1.8.5-stable/src/network/Manager.c
1,760c1,764
< /*
<   +----------------------------------------------------------------------+
<   | Swoole                                                               |
<   +----------------------------------------------------------------------+
<   | This source file is subject to version 2.0 of the Apache license,    |
<   | that is bundled with this package in the file LICENSE, and is        |
<   | available through the world-wide-web at the following url:           |
<   | http://www.apache.org/licenses/LICENSE-2.0.html                      |
<   | If you did not receive a copy of the Apache2.0 license and are unable|
<   | to obtain it through the world-wide-web, please send a note to       |
<   | license@swoole.com so we can mail you a copy immediately.            |
<   +----------------------------------------------------------------------+
<   | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |
<   +----------------------------------------------------------------------+
< */
< 
< 
< #include "list.h"
< #include "swLog.h"
< #include "swWork.h"
< #include "swSignal.h"
< #include "swExecutor.h"
< #include "swBaseOperator.h"
< 
< #include <sys/wait.h>
< 
< typedef struct
< {
<     uint8_t reloading;
<     uint8_t reload_event_worker;
<     uint8_t reload_task_worker;
< 
< } swManagerProcess;
< 
< static int swManager_loop_async(swFactory *factory);
< static int swManager_loop_sync(swFactory *factory);
< static void swManager_signal_handle(int sig);
< static pid_t swManager_spawn_worker(swFactory *factory, int worker_id);
< static void swManager_check_exit_status(swServer *serv, int worker_id, pid_t pid, int status);
< 
< static swManagerProcess ManagerProcess;
< 
< //create worker child proccess
< int swManager_start(swFactory *factory)
< {
<     swFactoryProcess *object = factory->object;
<     swServer *serv = factory->ptr;
< 
<     object->pipes = sw_calloc(serv->worker_num, sizeof(swPipe));
<     if (object->pipes == NULL)
<     {
<         swError("malloc[worker_pipes] failed. Error: %s [%d]", strerror(errno), errno);
<         return SW_ERR;
<     }
< 
<     //worker进程的pipes
<     int index = 0;
<     for (index = 0; index < serv->worker_num; index++)
<     {
<         if (swPipeUnsock_create(&object->pipes[index], 1, SOCK_DGRAM) < 0)
<         {
<             return SW_ERR;
<         }
<         serv->workers[index].pipe_master = object->pipes[index].getFd(&object->pipes[index], SW_PIPE_MASTER);
<         serv->workers[index].pipe_worker = object->pipes[index].getFd(&object->pipes[index], SW_PIPE_WORKER);
<         serv->workers[index].pipe_object = &object->pipes[index];
<         swServer_store_pipe_fd(serv, serv->workers[index].pipe_object);
<     }
< 
<     if (SwooleG.task_worker_num > 0)
<     {
<         key_t key = 0;
<         int create_pipe = 1;
< 
<         if (SwooleG.task_ipc_mode > SW_TASK_IPC_UNIXSOCK)
<         {
<             key = serv->message_queue_key;
<             create_pipe = 0;
<         }
< 
<         if (swProcessPool_create(&SwooleGS->task_workers, SwooleG.task_worker_num, SwooleG.task_max_request, key, create_pipe) < 0)
<         {
<             swWarn("[Master] create task_workers failed.");
<             return SW_ERR;
<         }
< 
<         swProcessPool *pool = &SwooleGS->task_workers;
<         swTaskWorker_init(pool);
< 
<         swWorker *worker = NULL;
<         for (index = 0; index < SwooleG.task_worker_num; index++)
<         {
<             worker = &pool->workers[index];
<             if (swWorker_create(worker) < 0)
<             {
<                 return SW_ERR;
<             }
<             if (SwooleG.task_ipc_mode == SW_IPC_UNSOCK)
<             {
<                 swServer_store_pipe_fd(SwooleG.serv, worker->pipe_object);
<             }
<         }
<     }
< 
<     //User Worker Process
<     if (serv->user_worker_num > 0)
<     {
<         serv->user_workers = sw_calloc(serv->user_worker_num, sizeof(swWorker *));
<         swUserWorker_node *user_worker;
<         index = 0;
<         LL_FOREACH(serv->user_worker_list, user_worker)
<         {
<             if (swWorker_create(user_worker->worker) < 0)
<             {
<                 return SW_ERR;
<             }
<             serv->user_workers[index++] = user_worker->worker;
<         }
<     }
< 
<     pid_t pid = fork();
<     switch (pid)
<     {
<     //创建manager进程
<     case 0:
<         //wait master process
<         SW_START_SLEEP;
<         if (SwooleGS->start == 0)
<         {
<             return SW_OK;
<         }
<         swServer_close_listen_port(serv);
<         /**
<          * create worker process
<          */
<         for (index = 0; index < serv->worker_num; index++)
<         {
<             //close(worker_pipes[i].pipes[0]);
<             pid = swManager_spawn_worker(factory, index);
<             if (pid < 0)
<             {
<                 swError("fork() failed.");
<                 return SW_ERR;
<             }
<             else
<             {
<                 serv->workers[index].pid = pid;
<             }
<         }
< 
<         /**
<          * create task worker process
<          */
<         if (SwooleG.task_worker_num > 0)
<         {
<             swProcessPool_start(&SwooleGS->task_workers);
<         }
< 
<         /**
<          * create user worker process
<          */
<         if (serv->user_worker_list)
<         {
<             swUserWorker_node *user_worker;
<             LL_FOREACH(serv->user_worker_list, user_worker)
<             {
<                 /**
<                  * store the pipe object
<                  */
<                 if (user_worker->worker->pipe_object)
<                 {
<                     swServer_store_pipe_fd(serv, user_worker->worker->pipe_object);
<                 }
<                 swManager_spawn_user_worker(serv, user_worker->worker);
<             }
<         }
< 
<         //标识为管理进程
<         SwooleG.process_type = SW_PROCESS_MANAGER;
<         SwooleG.pid = getpid();
< 
<         int ret = (serv->reload_async)? swManager_loop_async(factory):swManager_loop_sync(factory);
<         exit(ret);
<         break;
< 
<         //master process
<     case -1:
< 		swError("fork() failed.");
< 		return SW_ERR;
<     default:
<         SwooleGS->manager_pid = pid;
<         break;
<     }
< 
<     return SW_OK;
< }
< 
< static void swManager_check_exit_status(swServer *serv, int worker_id, pid_t pid, int status)
< {
<     if (status != 0)
<     {
<         swWarn("worker#%d[pid#%ld] abnormal exit, exited=%d, status=%d, wifsignaled=%d, signal=%d", worker_id, (long)pid,WIFEXITED(status), WEXITSTATUS(status), WIFSIGNALED(status), WTERMSIG(status));
<         if (serv->onWorkerError != NULL)
<         {
<             serv->onWorkerError(serv, worker_id, pid, WEXITSTATUS(status), WTERMSIG(status));
<         }
<     }
< }
< 
< static int swManager_loop_async(swFactory *factory)
< {
<     //hashMap 存储oid_pid ->new_pid的映射
<     swHashMap *pidMap = swHashMap_create(SW_HASHMAP_INIT_BUCKET_N, NULL);
<     if (pidMap == NULL)
<     {
<         swError("swHashMap_create failed");
<         return SW_ERR;
<     }
< 
<     SwooleG.use_signalfd = 0;
<     SwooleG.use_timerfd = 0;
< 
<     memset(&ManagerProcess, 0, sizeof(ManagerProcess));
< 
<     swServer *serv = factory->ptr;
<     if (serv->onManagerStart)
<     {
<         serv->onManagerStart(serv);
<     }
< 
<     int reload_worker_num = serv->worker_num + SwooleG.task_worker_num;
<     swWorker *reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));
<     if (reload_workers == NULL)
<     {
<         swError("malloc[reload_workers] failed");
<         return SW_ERR;
<     }
< 
<     //for reload
<     swSignal_add(SIGHUP, NULL);
<     swSignal_add(SIGTERM, swManager_signal_handle);
<     swSignal_add(SIGUSR1, swManager_signal_handle);
<     swSignal_add(SIGUSR2, swManager_signal_handle);
<     //swSignal_add(SIGINT, swManager_signal_handle);
< 
<     SwooleG.main_reactor = NULL;
<     pid_t pid = -1;
<     pid_t new_pid = -1;
<     int status = -1;
<     int index = 0;
<     while (SwooleG.running > 0)
<     {
<         pid = wait(&status);
<         if (pid < 0)
<         {
<             //pid < 0 代表manager进程收到reload信号量，将进程组复制到reload进程组，fork新的进程组
<             if (ManagerProcess.reloading == 0)
<             {
<                 swTrace("wait() failed. Error: %s [%d]", strerror(errno), errno);
<             }
<             else if (ManagerProcess.reload_event_worker == 1)
<             {
<                 swWarn("worker is reloading now.");
<                 memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);
<                 reload_worker_num = serv->worker_num;
< 
<                 if (SwooleG.task_worker_num > 0)
<                 {
<                     memcpy(reload_workers + serv->worker_num, SwooleGS->task_workers.workers,
<                             sizeof(swWorker) * SwooleG.task_worker_num);
<                     reload_worker_num += SwooleG.task_worker_num;
<                 }
< 
<                 ManagerProcess.reload_event_worker = 0;
<                 goto kill_workers;
<             }
<             else if (ManagerProcess.reload_task_worker == 1)
<             {
<                 swWarn("task is reloading now.");
<                 if (SwooleG.task_worker_num == 0)
<                 {
<                     swWarn("cannot reload workers, because server no have task workers.");
<                     continue;
<                 }
<                 memcpy(reload_workers, SwooleGS->task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);
<                 reload_worker_num = SwooleG.task_worker_num;
< 
<                 ManagerProcess.reload_task_worker = 0;
<                 goto kill_workers;
<             }            
<         }
< 
<         if (SwooleG.running == 1)
<         {
<             /* 回收worker */
<             for (index = 0; index < serv->worker_num; index++)
<             {
<                 //compare PID
<                 if (pid != serv->workers[index].pid)
<                 {
<                     continue;
<                 }
<                 else
<                 {
<                     swManager_check_exit_status(serv, index, pid, status);
< 
<                     //pid ->new pid
<                     new_pid = (pid_t)(long) swHashMap_find_int(pidMap, pid);
<                     swWarn(" now the worker pid is %d", new_pid);
<                     serv->workers[index].pid = new_pid;
<                 }
<             }
< 
<             if (pid > 0)
<             {
<                 swWarn(" pid %d is not in the workers need to exit", pid);
<                 swWorker *exit_worker = NULL;
<                 //task worker
<                 if (SwooleGS->task_workers.map)
<                 {
<                     exit_worker = swHashMap_find_int(SwooleGS->task_workers.map, pid);
<                     if (exit_worker != NULL)
<                     {
<                         swManager_check_exit_status(serv, exit_worker->id, pid, status);
<                         if (exit_worker->deleted == 1)  //主动回收不重启
<                         {
<                             exit_worker->deleted = 0;
<                         }
<                         else
<                         {
<                             swProcessPool_spawn(exit_worker);
<                         }
<                     }
<                 }
<                 //user process
<                 if (serv->user_worker_map != NULL)
<                 {
<                     swManager_wait_user_worker(&SwooleGS->event_workers, pid);
<                 }
<             }
<         }
< 
< kill_workers:
<         if (ManagerProcess.reloading == 1)
<         {
<             for (index = 0; index < serv->worker_num; index++)
<             {
<                 /* 先fork新的 再kill老的*/
<                 while (1)
<                 {
<                     new_pid = swManager_spawn_worker(factory, index);
<                     if (new_pid < 0)
<                     {
<                         usleep(100000);
<                         continue;
<                     }
<                     else
<                     {
<                         swHashMap_add_int(pidMap, reload_workers[index].pid, (void*) &new_pid);
<                         swWarn(" add pidMap new_pid is %d old pid is %d", new_pid, reload_workers[index].pid);
<                         break;
<                     }
<                 }
<                 
<                 swWarn("start kill workers, id: %d, pid: %d.", index, reload_workers[index].pid);
<                 if (swKill(reload_workers[index].pid, SIGUSR1) < 0)
<                 {
<                     swSysError("kill(%d, SIGTERM) failed.", reload_workers[index].pid);
<                 }  
<             }
< 
<             ManagerProcess.reloading = 0;
<         }
<     } 
< 
<     sw_free(reload_workers);
< 
<     //kill all child process
<     for (index = 0; index < serv->worker_num; index++)
<     {
<         swTrace("[Manager]kill worker processor");
<         swKill(serv->workers[index].pid, SIGTERM);
<     }
< 
<     //wait child process
<     for (index = 0; index < serv->worker_num; index++)
<     {
<         if (swWaitpid(serv->workers[index].pid, &status, 0) < 0)
<         {
<             swSysError("waitpid(%d) failed.", serv->workers[index].pid);
<         }
<     }
< 
<     //kill and wait task process
<     if (SwooleG.task_worker_num > 0)
<     {
<         swProcessPool_shutdown(&SwooleGS->task_workers);
<     }
< 
<     if (serv->user_worker_map)
<     {
<         swWorker* user_worker = NULL;
<         uint64_t key = 0;
< 
<         //kill user process
<         while (1)
<         {
<             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
<             //hashmap empty
<             if (user_worker == NULL)
<             {
<                 break;
<             }
<             swKill(user_worker->pid, SIGTERM);
<         }
< 
<         //wait user process
<         while (1)
<         {
<             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
<             //hashmap empty
<             if (user_worker == NULL)
<             {
<                 break;
<             }
<             if (swWaitpid(user_worker->pid, &status, 0) < 0)
<             {
<                 swSysError("waitpid(%d) failed.", serv->workers[index].pid);
<             }
<         }
<     }
< 
<     if (serv->onManagerStop)
<     {
<         serv->onManagerStop(serv);
<     }
< 
<     return SW_OK;   
< }
< 
< static int swManager_loop_sync(swFactory *factory)
< {
<     SwooleG.use_signalfd = 0;
<     SwooleG.use_timerfd = 0;
< 
<     memset(&ManagerProcess, 0, sizeof(ManagerProcess));
<     swServer *serv = factory->ptr;
<     if (serv->onManagerStart)
<     {
<         serv->onManagerStart(serv);
<     }
< 
<     int reload_worker_num = serv->worker_num + SwooleG.task_worker_num;
<     swWorker *reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));
<     if (reload_workers == NULL)
<     {
<         swError("malloc[reload_workers] failed");
<         return SW_ERR;
<     }
< 
<     //for reload
<     swSignal_add(SIGHUP, NULL);
<     swSignal_add(SIGTERM, swManager_signal_handle);
<     swSignal_add(SIGUSR1, swManager_signal_handle);
<     swSignal_add(SIGUSR2, swManager_signal_handle);
< #ifdef SIGRTMIN
<     swSignal_add(SIGRTMIN, swManager_signal_handle);
< #endif
<     //swSignal_add(SIGINT, swManager_signal_handle);
< 
<     SwooleG.main_reactor = NULL;
<     int pid = -1;
<     int new_pid = -1;
<     int index = 0;
<     int ret = -1;
<     int status = -1,reload_worker_i = 0;
<     while (SwooleG.running > 0)
<     {
<         pid = wait(&status);
<         if (pid < 0)
<         {
<             if (ManagerProcess.reloading == 0)
<             {
<                 swTrace("wait() failed. Error: %s [%d]", strerror(errno), errno);
<             }
<             else if (ManagerProcess.reload_event_worker == 1)
<             {
<                 swWarn("Server is reloading event_worker now.");
<                 memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);
<                 reload_worker_num = serv->worker_num;
<                 if (SwooleG.task_worker_num > 0)
<                 {
<                     memcpy(reload_workers + serv->worker_num, SwooleGS->task_workers.workers,
<                             sizeof(swWorker) * SwooleG.task_worker_num);
<                     reload_worker_num += SwooleG.task_worker_num;
<                 }
< 
<                 reload_worker_i = 0;
<                 ManagerProcess.reload_event_worker = 0;
<                 goto kill_worker;
<             }
<             else if (ManagerProcess.reload_task_worker == 1)
<             {
<                 swWarn("Server is reloading task_worker now.");
<                 if (SwooleG.task_worker_num == 0)
<                 {
<                     swWarn("cannot reload workers, because server no have task workers.");
<                     continue;
<                 }
< 
<                 memcpy(reload_workers, SwooleGS->task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);
<                 reload_worker_num = SwooleG.task_worker_num;
<                 reload_worker_i = 0;
<                 ManagerProcess.reload_task_worker = 0;
<                 goto kill_worker;
<             }
<         }
<         if (SwooleG.running == 1)
<         {
<             for (index = 0; index < serv->worker_num; index++)
<             {
<                 //compare PID
<                 if (pid != serv->workers[index].pid)
<                 {
<                     continue;
<                 }
<                 else
<                 {
<                     swManager_check_exit_status(serv, index, pid, status);
<                     pid = 0;
<                     while (1)
<                     {
<                         new_pid = swManager_spawn_worker(factory, index);
<                         if (new_pid < 0)
<                         {
<                             usleep(100000);
<                             continue;
<                         }
<                         else
<                         {
<                             serv->workers[index].pid = new_pid;
<                             break;
<                         }
<                     }
<                 }
<             }
< 
<             if (pid > 0)
<             {
<                 swWorker *exit_worker = NULL;
<                 //task worker
<                 if (SwooleGS->task_workers.map)
<                 {
<                     exit_worker = swHashMap_find_int(SwooleGS->task_workers.map, pid);
<                     if (exit_worker != NULL)
<                     {
<                         swManager_check_exit_status(serv, exit_worker->id, pid, status);
<                         if (exit_worker->deleted == 1)  //主动回收不重启
<                         {
<                             exit_worker->deleted = 0;
<                         }
<                         else
<                         {
<                             swProcessPool_spawn(exit_worker);
<                         }
<                     }
<                 }
<                 //user process
<                 if (serv->user_worker_map != NULL)
<                 {
<                     swManager_wait_user_worker(&SwooleGS->event_workers, pid);
<                 }
<             }
<         }
<         //reload worker
< kill_worker:
<         if (ManagerProcess.reloading == 1)
<         {
<             //reload finish
<             if (reload_worker_i >= reload_worker_num)
<             {
<                 ManagerProcess.reloading = 0;
<                 reload_worker_i = 0;
<                 continue;
<             }
<             swWarn("start kill workers, id: %d, pid: %d.", reload_worker_i, reload_workers[reload_worker_i].pid);
<             ret = swKill(reload_workers[reload_worker_i].pid, SIGTERM);
<             if (ret < 0)
<             {
<                 swSysError("kill(%d, SIGTERM) failed.", reload_workers[reload_worker_i].pid);
<             }
<             reload_worker_i++;
<         }
<     }
< 
<     sw_free(reload_workers);
< 
<     //kill all child process
<     for (index = 0; index < serv->worker_num; index++)
<     {
<         swTrace("[Manager]kill worker processor");
<         kill(serv->workers[index].pid, SIGTERM);
<     }
< 
<     //wait child process
<     for (index = 0; index < serv->worker_num; index++)
<     {
<         if (swWaitpid(serv->workers[index].pid, &status, 0) < 0)
<         {
<             swSysError("waitpid(%d) failed.", serv->workers[index].pid);
<         }
<     }
< 
<     //kill and wait task process
<     if (SwooleG.task_worker_num > 0)
<     {
<         swProcessPool_shutdown(&SwooleGS->task_workers);
<     }
< 
<     if (serv->user_worker_map)
<     {
<         swWorker* user_worker = NULL;
<         uint64_t key = 0;
< 
<         //kill user process
<         while (1)
<         {
<             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
<             //hashmap empty
<             if (user_worker == NULL)
<             {
<                 break;
<             }
<             swKill(user_worker->pid, SIGTERM);
<         }
< 
<         //wait user process
<         while (1)
<         {
<             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
<             //hashmap empty
<             if (user_worker == NULL)
<             {
<                 break;
<             }
<             if (swWaitpid(user_worker->pid, &status, 0) < 0)
<             {
<                 swSysError("waitpid(%d) failed.", serv->workers[index].pid);
<             }
<         }
<     }
< 
<     if (serv->onManagerStop)
<     {
<         serv->onManagerStop(serv);
<     }
< 
<     return SW_OK;
< }
< 
< static pid_t swManager_spawn_worker(swFactory *factory, int worker_id)
< {
<     pid_t pid = fork();
<     //fork() failed
<     if (pid < 0)
<     {
<         swWarn("Fork Worker failed. Error: %s [%d]", strerror(errno), errno);
<         return SW_ERR;
<     }
<     //worker child processor
<     else if (pid == 0)
<     {
<     	int ret = swWorker_loop(factory, worker_id);
<         exit(ret);
<     }
<     //parent,add to writer
<     else
<     {
<         return pid;
<     }
< }
< 
< static void swManager_signal_handle(int sig)
< {
<     switch (sig)
<     {
<     case SIGTERM:
<         SwooleG.running = 0;
<         break;
<         /**
<          * reload all workers
<          */
<     case SIGUSR1:
<         if (ManagerProcess.reloading == 0)
<         {
<             ManagerProcess.reloading = 1;
<             ManagerProcess.reload_event_worker = 1;
<         }
<         break;
<         /**
<          * only reload task workers
<          */
<     case SIGUSR2:
<         if (ManagerProcess.reloading == 0)
<         {
<             ManagerProcess.reloading = 1;
<             ManagerProcess.reload_task_worker = 1;
<         }
<         break;
<     default:
< #ifdef SIGRTMIN
<         if (sig == SIGRTMIN)
<         {
<             swServer_reopen_log_file(SwooleG.serv);
<         }
< #endif
<         break;
<     }
< }
< 
< int swManager_wait_user_worker(swProcessPool *pool, pid_t pid)
< {
<     swServer *serv = SwooleG.serv;
<     swWorker *exit_worker = swHashMap_find_int(serv->user_worker_map, pid);
<     if (exit_worker != NULL)
<     {
<         return swManager_spawn_user_worker(serv, exit_worker);
<     }
<     else
<     {
<         return SW_ERR;
<     }
< }
< 
< pid_t swManager_spawn_user_worker(swServer *serv, swWorker* worker)
< {
<     pid_t pid = fork();
<     if (pid < 0)
<     {
<         swWarn("Fork Worker failed. Error: %s [%d]", strerror(errno), errno);
<         return SW_ERR;
<     }
<     //child
<     else if (pid == 0)
<     {
<         serv->onUserWorkerStart(serv, worker);
<         exit(0);
<     }
<     //parent
<     else
<     {
<         if (worker->pid)
<         {
<             swHashMap_del_int(serv->user_worker_map, worker->pid);
<         }
<         worker->pid = pid;
<         swHashMap_add_int(serv->user_worker_map, pid, worker);
<         return pid;
<     }
< }
---
> /*
>   +----------------------------------------------------------------------+
>   | Swoole                                                               |
>   +----------------------------------------------------------------------+
>   | This source file is subject to version 2.0 of the Apache license,    |
>   | that is bundled with this package in the file LICENSE, and is        |
>   | available through the world-wide-web at the following url:           |
>   | http://www.apache.org/licenses/LICENSE-2.0.html                      |
>   | If you did not receive a copy of the Apache2.0 license and are unable|
>   | to obtain it through the world-wide-web, please send a note to       |
>   | license@swoole.com so we can mail you a copy immediately.            |
>   +----------------------------------------------------------------------+
>   | Author: Tianfeng Han  <mikan.tenny@gmail.com>                        |
>   +----------------------------------------------------------------------+
> */
> 
> #include "swoole.h"
> #include "Server.h"
> 
> #include <sys/wait.h>
> 
> typedef struct
> {
>     uint8_t reloading;
>     uint8_t reload_event_worker;
>     uint8_t reload_task_worker;
> 
> } swManagerProcess;
> 
> static int swManager_loop_async(swFactory *factory);
> static int swManager_loop_sync(swFactory *factory);
> static void swManager_signal_handle(int sig);
> static pid_t swManager_spawn_worker(swFactory *factory, int worker_id);
> static void swManager_check_exit_status(swServer *serv, int worker_id, pid_t pid, int status);
> 
> static swManagerProcess ManagerProcess;
> 
> //create worker child proccess
> int swManager_start(swFactory *factory)
> {
>     swFactoryProcess *object = factory->object;
>     int i, ret;
>     pid_t pid;
>     swServer *serv = factory->ptr;
> 
>     object->pipes = sw_calloc(serv->worker_num, sizeof(swPipe));
>     if (object->pipes == NULL)
>     {
>         swError("malloc[worker_pipes] failed. Error: %s [%d]", strerror(errno), errno);
>         return SW_ERR;
>     }
> 
>     //worker进程的pipes
>     for (i = 0; i < serv->worker_num; i++)
>     {
>         if (swPipeUnsock_create(&object->pipes[i], 1, SOCK_DGRAM) < 0)
>         {
>             return SW_ERR;
>         }
>         serv->workers[i].pipe_master = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_MASTER);
>         serv->workers[i].pipe_worker = object->pipes[i].getFd(&object->pipes[i], SW_PIPE_WORKER);
>         serv->workers[i].pipe_object = &object->pipes[i];
>         swServer_store_pipe_fd(serv, serv->workers[i].pipe_object);
>     }
> 
>     if (SwooleG.task_worker_num > 0)
>     {
>         key_t key = 0;
>         int create_pipe = 1;
> 
>         if (SwooleG.task_ipc_mode > SW_TASK_IPC_UNIXSOCK)
>         {
>             key = serv->message_queue_key;
>             create_pipe = 0;
>         }
> 
>         if (swProcessPool_create(&SwooleGS->task_workers, SwooleG.task_worker_num, SwooleG.task_max_request, key, create_pipe) < 0)
>         {
>             swWarn("[Master] create task_workers failed.");
>             return SW_ERR;
>         }
> 
>         swProcessPool *pool = &SwooleGS->task_workers;
>         swTaskWorker_init(pool);
> 
>         swWorker *worker;
>         for (i = 0; i < SwooleG.task_worker_num; i++)
>         {
>             worker = &pool->workers[i];
>             if (swWorker_create(worker) < 0)
>             {
>                 return SW_ERR;
>             }
>             if (SwooleG.task_ipc_mode == SW_IPC_UNSOCK)
>             {
>                 swServer_store_pipe_fd(SwooleG.serv, worker->pipe_object);
>             }
>         }
>     }
> 
>     //User Worker Process
>     if (serv->user_worker_num > 0)
>     {
>         serv->user_workers = sw_calloc(serv->user_worker_num, sizeof(swWorker *));
>         swUserWorker_node *user_worker;
>         i = 0;
>         LL_FOREACH(serv->user_worker_list, user_worker)
>         {
>             if (swWorker_create(user_worker->worker) < 0)
>             {
>                 return SW_ERR;
>             }
>             serv->user_workers[i++] = user_worker->worker;
>         }
>     }
> 
>     pid = fork();
>     switch (pid)
>     {
>     //创建manager进程
>     case 0:
>         //wait master process
>         SW_START_SLEEP;
>         if (SwooleGS->start == 0)
>         {
>             return SW_OK;
>         }
>         swServer_close_listen_port(serv);
>         /**
>          * create worker process
>          */
>         for (i = 0; i < serv->worker_num; i++)
>         {
>             //close(worker_pipes[i].pipes[0]);
>             pid = swManager_spawn_worker(factory, i);
>             if (pid < 0)
>             {
>                 swError("fork() failed.");
>                 return SW_ERR;
>             }
>             else
>             {
>                 serv->workers[i].pid = pid;
>             }
>         }
> 
>         /**
>          * create task worker process
>          */
>         if (SwooleG.task_worker_num > 0)
>         {
>             swProcessPool_start(&SwooleGS->task_workers);
>         }
> 
>         /**
>          * create user worker process
>          */
>         if (serv->user_worker_list)
>         {
>             swUserWorker_node *user_worker;
>             LL_FOREACH(serv->user_worker_list, user_worker)
>             {
>                 /**
>                  * store the pipe object
>                  */
>                 if (user_worker->worker->pipe_object)
>                 {
>                     swServer_store_pipe_fd(serv, user_worker->worker->pipe_object);
>                 }
>                 swManager_spawn_user_worker(serv, user_worker->worker);
>             }
>         }
> 
>         //标识为管理进程
>         SwooleG.process_type = SW_PROCESS_MANAGER;
>         SwooleG.pid = getpid();
> 
>         if (serv->reload_async)
>         {
>             ret = swManager_loop_async(factory);
>         }
>         else
>         {
>             ret = swManager_loop_sync(factory);
>         }
>         exit(ret);
>         break;
> 
>         //master process
>     default:
>         SwooleGS->manager_pid = pid;
>         break;
>     case -1:
>         swError("fork() failed.");
>         return SW_ERR;
>     }
>     return SW_OK;
> }
> 
> static void swManager_check_exit_status(swServer *serv, int worker_id, pid_t pid, int status)
> {
>     if (status != 0)
>     {
>         swWarn("worker#%d abnormal exit, status=%d, signal=%d", worker_id, WEXITSTATUS(status), WTERMSIG(status));
>         if (serv->onWorkerError != NULL)
>         {
>             serv->onWorkerError(serv, worker_id, pid, WEXITSTATUS(status), WTERMSIG(status));
>         }
>     }
> }
> 
> static int swManager_loop_async(swFactory *factory)
> {
>     int pid, new_pid;
>     int i;
>     int reload_worker_num;
>     int ret;
>     int status;
> 
>     //hashMap 存储oid_pid ->new_pid的映射
>     swHashMap *pidMap = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, NULL);
>     if (pidMap == NULL)
>     {
>         swError("swHashMap_new failed");
>         return SW_ERR;
>     }
> 
>     SwooleG.use_signalfd = 0;
>     SwooleG.use_timerfd = 0;
> 
>     memset(&ManagerProcess, 0, sizeof(ManagerProcess));
> 
>     swServer *serv = factory->ptr;
>     swWorker *reload_workers;
> 
>     if (serv->onManagerStart)
>     {
>         serv->onManagerStart(serv);
>     }
> 
>     reload_worker_num = serv->worker_num + SwooleG.task_worker_num;
>     reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));
>     if (reload_workers == NULL)
>     {
>         swError("malloc[reload_workers] failed");
>         return SW_ERR;
>     }
> 
>     //for reload
>     swSignal_add(SIGHUP, NULL);
>     swSignal_add(SIGTERM, swManager_signal_handle);
>     swSignal_add(SIGUSR1, swManager_signal_handle);
>     swSignal_add(SIGUSR2, swManager_signal_handle);
>     //swSignal_add(SIGINT, swManager_signal_handle);
> 
>     SwooleG.main_reactor = NULL;
> 
>     while (SwooleG.running > 0)
>     {
>         pid = wait(&status);
> 
>         if (pid < 0)
>         {
>             //pid < 0 代表manager进程收到reload信号量，将进程组复制到reload进程组，fork新的进程组
>             if (ManagerProcess.reloading == 0)
>             {
>                 swTrace("wait() failed. Error: %s [%d]", strerror(errno), errno);
>             }
>             else if (ManagerProcess.reload_event_worker == 1)
>             {
>                 swNotice("worker is reloading now.");
>                 memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);
>                 reload_worker_num = serv->worker_num;
> 
>                 if (SwooleG.task_worker_num > 0)
>                 {
>                     memcpy(reload_workers + serv->worker_num, SwooleGS->task_workers.workers,
>                             sizeof(swWorker) * SwooleG.task_worker_num);
>                     reload_worker_num += SwooleG.task_worker_num;
>                 }
>                 ManagerProcess.reload_event_worker = 0;
>                 goto kill_workers;
>             }
>             else if (ManagerProcess.reload_task_worker == 1)
>             {
>                 swNotice("task is reloading now.");
>                 if (SwooleG.task_worker_num == 0)
>                 {
>                     swWarn("cannot reload workers, because server no have task workers.");
>                     continue;
>                 }
>                 memcpy(reload_workers, SwooleGS->task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);
>                 reload_worker_num = SwooleG.task_worker_num;
> 
>                 ManagerProcess.reload_task_worker = 0;
>                 goto kill_workers;
>             }            
>         }
>         if (SwooleG.running == 1)
>         {
>             /* 回收worker */
>             for (i = 0; i < serv->worker_num; i++)
>             {
>                 //compare PID
>                 if (pid != serv->workers[i].pid)
>                 {
>                     continue;
>                 }
>                 else
>                 {
>                     swManager_check_exit_status(serv, i, pid, status);
> 
>                     //pid ->new pid
>                     new_pid = (pid_t) swHashMap_find_int(pidMap, pid);
>                     swWarn(" now the worker pid is %d", new_pid);
>                     serv->workers[i].pid = new_pid;
>                 }
>             }
> 
>             if (pid > 0)
>             {
>                 swWarn(" pid %d is not in the workers need to exit", pid);
>                 swWorker *exit_worker;
>                 //task worker
>                 if (SwooleGS->task_workers.map)
>                 {
>                     exit_worker = swHashMap_find_int(SwooleGS->task_workers.map, pid);
>                     if (exit_worker != NULL)
>                     {
>                         swManager_check_exit_status(serv, exit_worker->id, pid, status);
>                         if (exit_worker->deleted == 1)  //主动回收不重启
>                         {
>                             exit_worker->deleted = 0;
>                         }
>                         else
>                         {
>                             swProcessPool_spawn(exit_worker);
>                         }
>                     }
>                 }
>                 //user process
>                 if (serv->user_worker_map != NULL)
>                 {
>                     swManager_wait_user_worker(&SwooleGS->event_workers, pid);
>                 }
>             }
>         }
> 
>         kill_workers: if (ManagerProcess.reloading == 1)
>         {
>             for (i = 0; i < serv->worker_num; i++)
>             {
>                 /* 先fork新的 再kill老的*/
>                 while (1)
>                 {
>                     new_pid = swManager_spawn_worker(factory, i);
>                     if (new_pid < 0)
>                     {
>                         usleep(100000);
>                         continue;
>                     }
>                     else
>                     {
>                         swHashMap_add_int(pidMap, reload_workers[i].pid, (void*) new_pid);
>                         swWarn(" add pidMap new_pid is %d old pid is %d", new_pid, reload_workers[i].pid);
>                         break;
>                     }
>                 }
> 
>                 swWarn(" kill the reload workers %d", reload_workers[i].pid);
>                 ret = kill(reload_workers[i].pid, SIGUSR1);
>                 if (ret < 0)
>                 {
>                     swSysError("kill(%d, SIGTERM) failed.", reload_workers[i].pid);
>                 }  
>             }
>             ManagerProcess.reloading = 0;
>         }
>     } 
> 
>     sw_free(reload_workers);
> 
>     //kill all child process
>     for (i = 0; i < serv->worker_num; i++)
>     {
>         swTrace("[Manager]kill worker processor");
>         kill(serv->workers[i].pid, SIGTERM);
>     }
> 
>     //wait child process
>     for (i = 0; i < serv->worker_num; i++)
>     {
>         if (swWaitpid(serv->workers[i].pid, &status, 0) < 0)
>         {
>             swSysError("waitpid(%d) failed.", serv->workers[i].pid);
>         }
>     }
> 
>     //kill and wait task process
>     if (SwooleG.task_worker_num > 0)
>     {
>         swProcessPool_shutdown(&SwooleGS->task_workers);
>     }
> 
>     if (serv->user_worker_map)
>     {
>         swWorker* user_worker;
>         uint64_t key;
> 
>         //kill user process
>         while (1)
>         {
>             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
>             //hashmap empty
>             if (user_worker == NULL)
>             {
>                 break;
>             }
>             kill(user_worker->pid, SIGTERM);
>         }
> 
>         //wait user process
>         while (1)
>         {
>             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
>             //hashmap empty
>             if (user_worker == NULL)
>             {
>                 break;
>             }
>             if (swWaitpid(user_worker->pid, &status, 0) < 0)
>             {
>                 swSysError("waitpid(%d) failed.", serv->workers[i].pid);
>             }
>         }
>     }
> 
>     if (serv->onManagerStop)
>     {
>         serv->onManagerStop(serv);
>     }
> 
>     return SW_OK;   
> }
> 
> static int swManager_loop_sync(swFactory *factory)
> {
>     int pid, new_pid;
>     int i;
>     int reload_worker_i = 0;
>     int reload_worker_num;
>     int ret;
>     int status;
> 
>     SwooleG.use_signalfd = 0;
>     SwooleG.use_timerfd = 0;
> 
>     memset(&ManagerProcess, 0, sizeof(ManagerProcess));
> 
>     swServer *serv = factory->ptr;
>     swWorker *reload_workers;
> 
>     if (serv->onManagerStart)
>     {
>         serv->onManagerStart(serv);
>     }
> 
>     reload_worker_num = serv->worker_num + SwooleG.task_worker_num;
>     reload_workers = sw_calloc(reload_worker_num, sizeof(swWorker));
>     if (reload_workers == NULL)
>     {
>         swError("malloc[reload_workers] failed");
>         return SW_ERR;
>     }
> 
>     //for reload
>     swSignal_add(SIGHUP, NULL);
>     swSignal_add(SIGTERM, swManager_signal_handle);
>     swSignal_add(SIGUSR1, swManager_signal_handle);
>     swSignal_add(SIGUSR2, swManager_signal_handle);
>     //swSignal_add(SIGINT, swManager_signal_handle);
> 
>     SwooleG.main_reactor = NULL;
> 
>     while (SwooleG.running > 0)
>     {
>         pid = wait(&status);
> 
>         if (pid < 0)
>         {
>             if (ManagerProcess.reloading == 0)
>             {
>                 swTrace("wait() failed. Error: %s [%d]", strerror(errno), errno);
>             }
>             else if (ManagerProcess.reload_event_worker == 1)
>             {
>                 swNotice("Server is reloading now.");
>                 memcpy(reload_workers, serv->workers, sizeof(swWorker) * serv->worker_num);
>                 reload_worker_num = serv->worker_num;
>                 if (SwooleG.task_worker_num > 0)
>                 {
>                     memcpy(reload_workers + serv->worker_num, SwooleGS->task_workers.workers,
>                             sizeof(swWorker) * SwooleG.task_worker_num);
>                     reload_worker_num += SwooleG.task_worker_num;
>                 }
>                 reload_worker_i = 0;
>                 ManagerProcess.reload_event_worker = 0;
>                 goto kill_worker;
>             }
>             else if (ManagerProcess.reload_task_worker == 1)
>             {
>                 swNotice("Server is reloading now.");
>                 if (SwooleG.task_worker_num == 0)
>                 {
>                     swWarn("cannot reload workers, because server no have task workers.");
>                     continue;
>                 }
>                 memcpy(reload_workers, SwooleGS->task_workers.workers, sizeof(swWorker) * SwooleG.task_worker_num);
>                 reload_worker_num = SwooleG.task_worker_num;
>                 reload_worker_i = 0;
>                 ManagerProcess.reload_task_worker = 0;
>                 goto kill_worker;
>             }
>         }
>         if (SwooleG.running == 1)
>         {
>             for (i = 0; i < serv->worker_num; i++)
>             {
>                 //compare PID
>                 if (pid != serv->workers[i].pid)
>                 {
>                     continue;
>                 }
>                 else
>                 {
>                     swManager_check_exit_status(serv, i, pid, status);
>                     pid = 0;
>                     while (1)
>                     {
>                         new_pid = swManager_spawn_worker(factory, i);
>                         if (new_pid < 0)
>                         {
>                             usleep(100000);
>                             continue;
>                         }
>                         else
>                         {
>                             serv->workers[i].pid = new_pid;
>                             break;
>                         }
>                     }
>                 }
>             }
> 
>             if (pid > 0)
>             {
>                 swWorker *exit_worker;
>                 //task worker
>                 if (SwooleGS->task_workers.map)
>                 {
>                     exit_worker = swHashMap_find_int(SwooleGS->task_workers.map, pid);
>                     if (exit_worker != NULL)
>                     {
>                         swManager_check_exit_status(serv, exit_worker->id, pid, status);
>                         if (exit_worker->deleted == 1)  //主动回收不重启
>                         {
>                             exit_worker->deleted = 0;
>                         }
>                         else
>                         {
>                             swProcessPool_spawn(exit_worker);
>                         }
>                     }
>                 }
>                 //user process
>                 if (serv->user_worker_map != NULL)
>                 {
>                     swManager_wait_user_worker(&SwooleGS->event_workers, pid);
>                 }
>             }
>         }
>         //reload worker
>         kill_worker: if (ManagerProcess.reloading == 1)
>         {
>             //reload finish
>             if (reload_worker_i >= reload_worker_num)
>             {
>                 ManagerProcess.reloading = 0;
>                 reload_worker_i = 0;
>                 continue;
>             }
>             ret = kill(reload_workers[reload_worker_i].pid, SIGTERM);
>             if (ret < 0)
>             {
>                 swSysError("kill(%d, SIGTERM) failed.", reload_workers[reload_worker_i].pid);
>             }
>             reload_worker_i++;
>         }
>     }
> 
>     sw_free(reload_workers);
> 
>     //kill all child process
>     for (i = 0; i < serv->worker_num; i++)
>     {
>         swTrace("[Manager]kill worker processor");
>         kill(serv->workers[i].pid, SIGTERM);
>     }
> 
>     //wait child process
>     for (i = 0; i < serv->worker_num; i++)
>     {
>         if (swWaitpid(serv->workers[i].pid, &status, 0) < 0)
>         {
>             swSysError("waitpid(%d) failed.", serv->workers[i].pid);
>         }
>     }
> 
>     //kill and wait task process
>     if (SwooleG.task_worker_num > 0)
>     {
>         swProcessPool_shutdown(&SwooleGS->task_workers);
>     }
> 
>     if (serv->user_worker_map)
>     {
>         swWorker* user_worker;
>         uint64_t key;
> 
>         //kill user process
>         while (1)
>         {
>             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
>             //hashmap empty
>             if (user_worker == NULL)
>             {
>                 break;
>             }
>             kill(user_worker->pid, SIGTERM);
>         }
> 
>         //wait user process
>         while (1)
>         {
>             user_worker = swHashMap_each_int(serv->user_worker_map, &key);
>             //hashmap empty
>             if (user_worker == NULL)
>             {
>                 break;
>             }
>             if (swWaitpid(user_worker->pid, &status, 0) < 0)
>             {
>                 swSysError("waitpid(%d) failed.", serv->workers[i].pid);
>             }
>         }
>     }
> 
>     if (serv->onManagerStop)
>     {
>         serv->onManagerStop(serv);
>     }
> 
>     return SW_OK;
> }
> 
> static pid_t swManager_spawn_worker(swFactory *factory, int worker_id)
> {
>     pid_t pid;
>     int ret;
> 
>     pid = fork();
> 
>     //fork() failed
>     if (pid < 0)
>     {
>         swWarn("Fork Worker failed. Error: %s [%d]", strerror(errno), errno);
>         return SW_ERR;
>     }
>     //worker child processor
>     else if (pid == 0)
>     {
>         ret = swWorker_loop(factory, worker_id);
>         exit(ret);
>     }
>     //parent,add to writer
>     else
>     {
>         return pid;
>     }
> }
> 
> static void swManager_signal_handle(int sig)
> {
>     switch (sig)
>     {
>     case SIGTERM:
>         SwooleG.running = 0;
>         break;
>         /**
>          * reload all workers
>          */
>     case SIGUSR1:
>         if (ManagerProcess.reloading == 0)
>         {
>             ManagerProcess.reloading = 1;
>             ManagerProcess.reload_event_worker = 1;
>         }
>         break;
>         /**
>          * only reload task workers
>          */
>     case SIGUSR2:
>         if (ManagerProcess.reloading == 0)
>         {
>             ManagerProcess.reloading = 1;
>             ManagerProcess.reload_task_worker = 1;
>         }
>         break;
>     default:
>         break;
>     }
> }
> 
> int swManager_wait_user_worker(swProcessPool *pool, pid_t pid)
> {
>     swServer *serv = SwooleG.serv;
>     swWorker *exit_worker = swHashMap_find_int(serv->user_worker_map, pid);
>     if (exit_worker != NULL)
>     {
>         return swManager_spawn_user_worker(serv, exit_worker);
>     }
>     else
>     {
>         return SW_ERR;
>     }
> }
> 
> pid_t swManager_spawn_user_worker(swServer *serv, swWorker* worker)
> {
>     pid_t pid = fork();
> 
>     if (pid < 0)
>     {
>         swWarn("Fork Worker failed. Error: %s [%d]", strerror(errno), errno);
>         return SW_ERR;
>     }
>     //child
>     else if (pid == 0)
>     {
>         serv->onUserWorkerStart(serv, worker);
>         exit(0);
>     }
>     //parent
>     else
>     {
>         if (worker->pid)
>         {
>             swHashMap_del_int(serv->user_worker_map, worker->pid);
>         }
>         worker->pid = pid;
>         swHashMap_add_int(serv->user_worker_map, pid, worker);
>         return pid;
>     }
> }
diff -r ./zan-extension/src/network/Port.c ../swoole-1.8.5-stable/src/network/Port.c
17,25c17,21
< #include "swServer.h"
< #include "swReactor.h"
< #include "list.h"
< #include "swExecutor.h"
< #include "swProtocol/http.h"
< #include "swProtocol/http2.h"
< #include "swProtocol/websocket.h"
< #include "swProtocol/mqtt.h"
< #include "swPort.h"
---
> #include "Server.h"
> #include "http.h"
> #include "http2.h"
> #include "websocket.h"
> #include "mqtt.h"
63c59
<     if (SwooleG.reuse_port && setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &option, sizeof(int)) < 0)
---
>     if (SwooleG.reuse_port)
65,66c61,65
< 		swSysError("setsockopt(SO_REUSEPORT) failed.");
< 		SwooleG.reuse_port = 0;
---
>         if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &option, sizeof(int)) < 0)
>         {
>             swSysError("setsockopt(SO_REUSEPORT) failed.");
>             SwooleG.reuse_port = 0;
>         }
113c112
<     if (ls->ssl && (!ls->ssl_cert_file || !ls->ssl_key_file))
---
>     if (ls->ssl)
115,116c114,123
< 		swWarn("need to set [ssl_cert_file] or [ssl_key_file] option.");
< 		return SW_ERR;
---
>         if (!ls->ssl_cert_file)
>         {
>             swWarn("need to set [ssl_cert_file] option.");
>             return SW_ERR;
>         }
>         if (!ls->ssl_key_file)
>         {
>             swWarn("need to set [ssl_key_file] option.");
>             return SW_ERR;
>         }
128,129c135
<     if (ls->tcp_defer_accept && setsockopt(sock, IPPROTO_TCP, TCP_DEFER_ACCEPT,
<     								(const void*) &ls->tcp_defer_accept, sizeof(int)) < 0)
---
>     if (ls->tcp_defer_accept)
131c137,140
<         swSysError("setsockopt(TCP_DEFER_ACCEPT) failed.");
---
>         if (setsockopt(sock, IPPROTO_TCP, TCP_DEFER_ACCEPT, (const void*) &ls->tcp_defer_accept, sizeof(int)) < 0)
>         {
>             swSysError("setsockopt(TCP_DEFER_ACCEPT) failed.");
>         }
136,137c145
<     if (ls->tcp_fastopen && setsockopt(sock, IPPROTO_TCP, TCP_FASTOPEN,
<     		(const void*) &ls->tcp_fastopen, sizeof(int)) < 0)
---
>     if (ls->tcp_fastopen)
139c147,150
<         swSysError("setsockopt(TCP_FASTOPEN) failed.");
---
>         if (setsockopt(sock, IPPROTO_TCP, TCP_FASTOPEN, (const void*) &ls->tcp_fastopen, sizeof(int)) < 0)
>         {
>             swSysError("setsockopt(TCP_FASTOPEN) failed.");
>         }
170c181
<     char buf[128] = {0};
---
>     char buf[128];
265a277
>     int ret = 0, n;
268d279
<     memset(&task, 0, sizeof(task));
271,272c282
<     int ret = 0;
<     int n = swConnection_recv(conn, task.data.data, SW_BUFFER_SIZE, 0);
---
>     n = swConnection_recv(conn, task.data.data, SW_BUFFER_SIZE, 0);
312d321
< 
343a353
> 
352d361
< 
363,364d371
<     char *buf = NULL;
<     int buf_len = 0;
365a373,375
>     char *buf;
>     int buf_len;
> 
383d392
<      //alloc memory failed.
384a394
>         //alloc memory failed.
394c404
< recv_data:
---
>     recv_data:
421a432
> 
424d434
<         	/// 数据没有接收全，继续接收
440,441c450,483
<         //support method:get post put delete patch head options   
<         if ((request->method > 0 && request->method <= HTTP_PATCH) || request->method == HTTP_OPTIONS)
---
>         //DELETE
>         if (request->method == HTTP_DELETE)
>         {
>             if (request->content_length == 0 && swHttpRequest_have_content_length(request) == SW_FALSE)
>             {
>                 goto http_no_entity;
>             }
>             else
>             {
>                 goto http_entity;
>             }
>         }
>         //GET HEAD OPTIONS
>         else if (request->method == HTTP_GET || request->method == HTTP_HEAD || request->method == HTTP_OPTIONS)
>         {
>             http_no_entity:
>             if (memcmp(buffer->str + buffer->length - 4, "\r\n\r\n", 4) == 0)
>             {
>                 swReactorThread_dispatch(conn, buffer->str, buffer->length);
>                 swHttpRequest_free(conn);
>             }
>             else if (buffer->size == buffer->length)
>             {
>                 swWarn("http header is too long.");
>                 goto close_fd;
>             }
>             //wait more data
>             else
>             {
>                 goto recv_data;
>             }
>         }
>         //POST PUT HTTP_PATCH
>         else if (request->method == HTTP_POST || request->method == HTTP_PUT || request->method == HTTP_PATCH)
443,504c485,545
<         	//receive data of http header
< 			if (request->header_length == 0)
< 			{
< 				if (swHttpRequest_get_header_length(request) < 0)
< 				{
< 					if (buffer->size == buffer->length)
< 					{
< 						swWarn("http header is too long.");
< 						goto close_fd;
< 					}
< 					else
< 					{
< 						goto recv_data;
< 					}
< 				}
< 			}
< 			//handle http body
< 			if (request->content_length == 0)
< 			{
< 				//http_no_entity
< 				if (swHttpRequest_get_content_length(request) < 0)
< 				{
< 					if (memcmp(buffer->str + buffer->length - 4, "\r\n\r\n", 4) == 0)
< 					{
< 						swReactorThread_dispatch(conn, buffer->str, buffer->length);
< 						swHttpRequest_free(conn);
< 						return SW_OK;
< 					}
< 					else if (buffer->size == buffer->length)
< 					{
< 						swWarn("http header is too long.");
< 						goto close_fd;
< 					}
< 					else
< 					{
< 						goto recv_data;
< 					}
< 				}
< 				//content_length overflow
< 				else if (request->content_length > (protocol->package_max_length - SW_HTTP_HEADER_MAX_SIZE))
< 				{
< 					swWarn("Content-Length more than the package_max_length[%d].", protocol->package_max_length - SW_HTTP_HEADER_MAX_SIZE);
< 					goto close_fd;
< 				}
< 			}
< 			//http_entity
< 			uint32_t request_size = request->content_length + request->header_length;
< 			int needExtentBuf = request_size > buffer->size;
< 			if (needExtentBuf && swString_extend(buffer, request_size) < 0)
< 			{
< 				goto close_fd;
< 			}
< 
< 			//discard the redundant data
< 			buffer->length = (buffer->length > request_size)? request_size:buffer->length;
< 			if (buffer->length == request_size)
< 			{
< 				swReactorThread_dispatch(conn, buffer->str, buffer->length);
< 				swHttpRequest_free(conn);
< 			}
< 			else
< 			{
---
>             http_entity:
>             if (request->content_length == 0)
>             {
>                 if (swHttpRequest_get_content_length(request) < 0)
>                 {
>                     if (buffer->size == buffer->length)
>                     {
>                         swWarn("http header is too long.");
>                         goto close_fd;
>                     }
>                     else
>                     {
>                         goto recv_data;
>                     }
>                 }
>                 else if (request->content_length > protocol->package_max_length)
>                 {
>                     swWarn("content-length more than the package_max_length[%d].", protocol->package_max_length);
>                     goto close_fd;
>                 }
>             }
> 
>             uint32_t request_size = 0;
> 
>             //http header is not the end
>             if (request->header_length == 0)
>             {
>                 if (buffer->size == buffer->length)
>                 {
>                     swWarn("http header is too long.");
>                     goto close_fd;
>                 }
>                 if (swHttpRequest_get_header_length(request) < 0)
>                 {
>                     goto recv_data;
>                 }
>                 request_size = request->content_length + request->header_length;
>             }
>             else
>             {
>                 request_size = request->content_length + request->header_length;
>             }
> 
>             if (request_size > buffer->size && swString_extend(buffer, request_size) < 0)
>             {
>                 goto close_fd;
>             }
> 
>             //discard the redundant data
>             if (buffer->length > request_size)
>             {
>                 buffer->length = request_size;
>             }
> 
>             if (buffer->length == request_size)
>             {
>                 swReactorThread_dispatch(conn, buffer->str, buffer->length);
>                 swHttpRequest_free(conn);
>             }
>             else
>             {
506,535c547,576
< 				//Expect: 100-continue
< 				if (swHttpRequest_has_expect_header(request))
< 				{
< 					swSendData _send;
< 					_send.data = "HTTP/1.1 100 Continue\r\n\r\n";
< 					_send.length = strlen(_send.data);
< 
< 					int send_times = 0;
< 					direct_send:
< 					n = swConnection_send(conn, _send.data, _send.length, 0);
< 					if (n < _send.length)
< 					{
< 						_send.data += n;
< 						_send.length -= n;
< 						send_times++;
< 						if (send_times < 10)
< 						{
< 							goto direct_send;
< 						}
< 						else
< 						{
< 							swWarn("send http header failed");
< 						}
< 					}
< 				}
< 				else
< 				{
< 					swTrace("PostWait: request->content_length=%d, buffer->length=%zd, request->header_length=%d\n",
< 							request->content_length, buffer->length, request->header_length);
< 				}
---
>                 //Expect: 100-continue
>                 if (swHttpRequest_has_expect_header(request))
>                 {
>                     swSendData _send;
>                     _send.data = "HTTP/1.1 100 Continue\r\n\r\n";
>                     _send.length = strlen(_send.data);
> 
>                     int send_times = 0;
>                     direct_send:
>                     n = swConnection_send(conn, _send.data, _send.length, 0);
>                     if (n < _send.length)
>                     {
>                         _send.data += n;
>                         _send.length -= n;
>                         send_times++;
>                         if (send_times < 10)
>                         {
>                             goto direct_send;
>                         }
>                         else
>                         {
>                             swWarn("send http header failed");
>                         }
>                     }
>                 }
>                 else
>                 {
>                     swTrace("PostWait: request->content_length=%d, buffer->length=%zd, request->header_length=%d\n",
>                             request->content_length, buffer->length, request->header_length);
>                 }
537,538c578,579
< 				goto recv_data;
< 			}
---
>                 goto recv_data;
>             }
550d590
< 
562d601
< 
Only in ../swoole-1.8.5-stable/src/network: ProcessPool.c
Only in ./zan-extension/src/network: ReactorAccept.c
diff -r ./zan-extension/src/network/ReactorProcess.c ../swoole-1.8.5-stable/src/network/ReactorProcess.c
17,21c17
< #include "swSignal.h"
< #include "swServer.h"
< #include "list.h"
< #include "swWork.h"
< #include "swExecutor.h"
---
> #include "Server.h"
55a52,55
> /**
>  * base模式
>  * 在worker进程中直接accept连接
>  */
57a58,86
>     swListenPort *ls;
>     if (serv->onStart != NULL)
>     {
>         serv->onStart(serv);
>     }
> 
>     //listen TCP
>     if (serv->have_tcp_sock == 1)
>     {
>         LL_FOREACH(serv->listen_list, ls)
>         {
>             if (swSocket_is_dgram(ls->type))
>             {
>                 continue;
>             }
> #ifdef HAVE_REUSEPORT
>             if (SwooleG.reuse_port)
>             {
>                 continue;
>             }
> #endif
>             //listen server socket
>             if (swPort_set_option(ls) < 0)
>             {
>                 return SW_ERR;
>             }
>         }
>     }
> 
69,70c98
<     if (serv->worker_num == 1 && SwooleG.task_worker_num == 0 &&
<     		serv->max_request == 0 && serv->user_worker_list == NULL)
---
>     if (serv->worker_num == 1 && SwooleG.task_worker_num == 0 && serv->max_request == 0 && serv->user_worker_list == NULL)
80,81c108,115
<         key_t key = (SwooleG.task_ipc_mode == SW_IPC_MSGQUEUE)? serv->message_queue_key:0;
<         int create_pipe = (SwooleG.task_ipc_mode != SW_IPC_UNSOCK)? 0:1;
---
>         key_t key = 0;
>         int create_pipe = 1;
> 
>         if (SwooleG.task_ipc_mode == SW_IPC_MSGQUEUE)
>         {
>             key = serv->message_queue_key;
>             create_pipe = 0;
>         }
114d147
< 
117d149
< 
130,131c162
< 
< //    swServer_signal_init();
---
>     swServer_signal_init();
134,139d164
<     
<     if (serv->onStart)
<     {
<         serv->onStart(serv);
<     }
< 
195,200d219
<     //init reactor
<     if (swReactor_init(reactor, SW_REACTOR_MAXEVENTS) < 0)
<     {
<         swWarn("ReactorProcess create failed.");
<         return SW_ERR;
<     }
210c229,232
<     SwooleTG.update_time = (worker->id == 0)? 1:SwooleTG.update_time;
---
>     if (worker->id == 0)
>     {
>         SwooleTG.update_time = 1;
>     }
221c243
<     int i = 0;
---
>     int i;
232c254,261
<     swListenPort *ls = NULL;
---
>     //create reactor
>     if (swReactor_create(reactor, SW_REACTOR_MAXEVENTS) < 0)
>     {
>         swWarn("ReactorProcess create failed.");
>         return SW_ERR;
>     }
> 
>     swListenPort *ls;
235c264
<     //add the all listened tcp port to reactor
---
>     //listen the all tcp port
239c268
<         if (fdtype == SW_FD_UDP && swPort_set_option(ls) < 0)
---
>         if (fdtype == SW_FD_UDP)
241c270,273
<             continue; 
---
>             if (swPort_set_option(ls) < 0)
>             {
>                 continue;
>             }
245c277
<         if (fdtype == SW_FD_LISTEN && SwooleG.reuse_port && swPort_set_option(ls) < 0)
---
>         if (fdtype == SW_FD_LISTEN && SwooleG.reuse_port)
247c279,282
<             return SW_ERR;
---
>             if (swPort_set_option(ls) < 0)
>             {
>                 return SW_ERR;
>             }
250d284
< 
252a287
>     SwooleG.main_reactor = reactor;
256d290
<     SwooleG.main_reactor = reactor;
294,295c328,329
<         swSetNonBlock(worker->pipe_worker,1);
<         swSetNonBlock(worker->pipe_master,1);
---
>         swSetNonBlock(worker->pipe_worker);
>         swSetNonBlock(worker->pipe_master);
315c349
<                 swSetNonBlock(pfd,1);
---
>                 swSetNonBlock(pfd);
diff -r ./zan-extension/src/network/ReactorThread.c ../swoole-1.8.5-stable/src/network/ReactorThread.c
18,25c18,19
< #include "list.h"
< #include "swWork.h"
< #include "swSignal.h"
< #include "swServer.h"
< #include "swBaseOperator.h"
< #include "swProtocol/websocket.h"
< #include "swFactory.h"
< #include "swExecutor.h"
---
> #include "Server.h"
> #include "websocket.h"
29,30d22
< 
< static int swTCPThread_start(swServer *serv);
32,34d23
< 
< static void swHeartbeatThread_loop(swThreadParam *param);
< 
42,265c31,32
< static int swUDPThread_start(swServer *serv)
< {
<     swThreadParam *param = NULL;
<     pthread_t thread_id;
<     swListenPort *ls = NULL;
<     int index = serv->reactor_num;
< 
<     LL_FOREACH(serv->listen_list, ls)
<     {
<         param = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swThreadParam));
< 
<         if (swSocket_is_dgram(ls->type))
<         {
<             if (ls->type == SW_SOCK_UDP)
<             {
<                 serv->connection_list[ls->sock].info.addr.inet_v4.sin_port = htons(ls->port);
<             }
<             else
<             {
<                 serv->connection_list[ls->sock].info.addr.inet_v6.sin6_port = htons(ls->port);
<             }
< 
<             serv->connection_list[ls->sock].fd = ls->sock;
<             serv->connection_list[ls->sock].socket_type = ls->type;
<             serv->connection_list[ls->sock].object = ls;
< 
<             param->object = ls;
<             param->pti = index++;
< 
<             if (pthread_create(&thread_id, NULL, (void * (*)(void *)) swReactorThread_loop_dgram, (void *) param) < 0)
<             {
<                 swWarn("pthread_create[udp_listener] fail");
<                 return SW_ERR;
<             }
< 
<             ls->thread_id = thread_id;
<         }
<     }
< 
<     return SW_OK;
< }
< 
< /**
<  * udp listener thread
<  */
< static int swReactorThread_loop_dgram(swThreadParam *param)
< {
<     swEvent event;
<     swListenPort *ls = param->object;
< 
<     int fd = ls->sock;
< 
<     SwooleTG.factory_lock_target = 0;
<     SwooleTG.factory_target_worker = -1;
<     SwooleTG.id = param->pti;
<     SwooleTG.type = SW_THREAD_UDP;
< 
<     swSignal_none();
< 
<     //blocking
<     swSetNonBlock(fd,0);
<     event.fd = fd;
< 
<     while (SwooleG.running == 1)
<     {
<         swReactorThread_onPackage(NULL, &event);
<     }
< 
<     pthread_exit(0);
<     return 0;
< }
< 
< static int swTCPThread_start(swServer *serv)
< {  
<     swListenPort *ls = NULL;
<     LL_FOREACH(serv->listen_list, ls)
<     {
<         if (!swSocket_is_dgram(ls->type))
<         {
<         	SwooleG.main_reactor->add(SwooleG.main_reactor, ls->sock, SW_FD_LISTEN);
<         }
<     }
< 
< #ifdef HAVE_PTHREAD_BARRIER
<     //init thread barrier
<     pthread_barrier_init(&serv->barrier, NULL, serv->reactor_num + 1);
< #endif
< 
<     swThreadParam *param = NULL;
<     swReactorThread *thread = NULL;
<     pthread_t pidt;
<     int index = 0;
<     //create reactor thread
<     for (index = 0; index < serv->reactor_num; index++)
<     {
<         thread = &(serv->reactor_threads[index]);
<         param = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swThreadParam));
<         if (param == NULL)
<         {
<             swError("malloc failed");
<             return SW_ERR;
<         }
< 
<         param->object = serv;
<         param->pti = index;
< 
<         if (pthread_create(&pidt, NULL, (void * (*)(void *)) swReactorThread_loop_stream, (void *) param) < 0)
<         {
<             swError("pthread_create[tcp_reactor] failed. Error: %s[%d]", strerror(errno), errno);
<         }
<         else{
<             thread->thread_id = pidt;
<         }
<     }
< #ifdef HAVE_PTHREAD_BARRIER
<     //wait reactor thread
<     pthread_barrier_wait(&serv->barrier);
< #else
<     SW_START_SLEEP;
< #endif
< 
<     return SW_OK;
< }
< /**
<  * ReactorThread tcp reactor Loop
<  */
< static int swReactorThread_loop_stream(swThreadParam *param)
< {
<     swServer *serv = SwooleG.serv;
<     int reactor_id = param->pti;
< 
<     SwooleTG.factory_lock_target = 0;
<     SwooleTG.factory_target_worker = -1;
<     SwooleTG.id = reactor_id;
<     SwooleTG.type = SW_THREAD_REACTOR;
< 
<     swReactorThread *thread = swServer_get_thread(serv, reactor_id);
<     swReactor *reactor = &thread->reactor;
< 
<     swoole_cpu_setAffinity(reactor_id,serv);
< 
<     if (swReactor_init(reactor, SW_REACTOR_MAXEVENTS) < 0)
<     {
<         return SW_ERR;
<     }
< 
<     swSignal_none();
< 
<     reactor->ptr = serv;
<     reactor->id = reactor_id;
<     reactor->thread = 1;
<     reactor->socket_list = serv->connection_list;
<     reactor->max_socket = serv->max_connection;
< 
<     reactor->onFinish = NULL;
<     reactor->onTimeout = NULL;
<     reactor->close = swReactorThread_close;
< 
<     reactor->setHandle(reactor, SW_FD_CLOSE, swReactorThread_onClose);
<     reactor->setHandle(reactor, SW_FD_PIPE | SW_EVENT_READ, swReactorThread_onPipeReceive);
<     reactor->setHandle(reactor, SW_FD_PIPE | SW_EVENT_WRITE, swReactorThread_onPipeWrite);
< 
<     //set protocol function point
<     swReactorThread_set_protocol(serv, reactor);
< 
<     if (serv->factory_mode == SW_MODE_PROCESS)
<     {
< #ifdef SW_USE_RINGBUFFER
<         int j = 0;
<         thread->pipe_read_list = sw_calloc(serv->reactor_pipe_num, sizeof(int));
<         if (thread->pipe_read_list == NULL)
<         {
<             swSysError("thread->buffer_pipe create failed");
<             return SW_ERR;
<         }
< #endif
<         int index = 0, pipe_fd = -1;
<         for (index = 0; index < serv->worker_num; index++)
<         {
<             if ((index % serv->reactor_num) == reactor_id)
<             {
<                 pipe_fd = serv->workers[index].pipe_master;
< 
<                 //for request
<                 swBuffer *buffer = swBuffer_new(sizeof(swEventData));
<                 if (!buffer)
<                 {
<                     swWarn("create buffer failed.");
<                     break;
<                 }
<                 serv->connection_list[pipe_fd].in_buffer = buffer;
< 
<                 //for response
<                 swSetNonBlock(pipe_fd,1);
<                 reactor->add(reactor, pipe_fd, SW_FD_PIPE);
< 
<                 /**
<                  * mapping reactor_id and worker pipe
<                  */
<                 serv->connection_list[pipe_fd].from_id = reactor_id;
<                 serv->connection_list[pipe_fd].fd = pipe_fd;
<                 serv->connection_list[pipe_fd].object = sw_malloc(sizeof(swLock));
< 
<                 /**
<                  * create pipe lock
<                  */
<                 if (swMutex_create(serv->connection_list[pipe_fd].object, 0) < 0)
<                 {
<                     swWarn("create pipe mutex lock failed.");
<                     break;
<                 }
< 
< #ifdef SW_USE_RINGBUFFER
<                 thread->pipe_read_list[j++] = pipe_fd;
< #endif
<             }
<         }
<     }
< 
<     //wait other thread
< #ifdef HAVE_PTHREAD_BARRIER
<     pthread_barrier_wait(&serv->barrier);
< #else
<     SW_START_SLEEP;
---
> #if 0
> static int swReactorThread_dispatch_array_buffer(swReactorThread *thread, swConnection *conn);
268,367d34
<     struct timeval tm={5,0};
<     //main loop
<     reactor->wait(reactor, &tm);
<     //shutdown
<     reactor->free(reactor);
<     pthread_exit(0);
<     return SW_OK;
< }
< 
< static void swHeartbeatThread_start(swServer *serv)
< {
<     swThreadParam *param;
<     pthread_t thread_id;
<     param = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swThreadParam));
<     if (param == NULL)
<     {
<         swError("heartbeat_param malloc fail\n");
<         return;
<     }
< 
<     param->object = serv;
<     param->pti = 0;
< 
<     if (pthread_create(&thread_id, NULL, (void * (*)(void *)) swHeartbeatThread_loop, (void *) param) < 0)
<     {
<         swWarn("pthread_create[hbcheck] fail");
<     }
<     SwooleG.heartbeat_pidt = thread_id;
< }
< 
< static void swHeartbeatThread_loop(swThreadParam *param)
< {
<     swSignal_none();
< 
<     swServer *serv = param->object;
<     swDataHead notify_ev;
<     swConnection *conn;
<     swReactor *reactor;
< 
<     int fd;
<     int serv_max_fd;
<     int serv_min_fd;
<     int checktime;
< 
<     SwooleTG.type = SW_THREAD_HEARTBEAT;
< 
<     bzero(&notify_ev, sizeof(notify_ev));
<     notify_ev.type = SW_EVENT_CLOSE;
< 
<     while (SwooleG.running)
<     {
<         serv_max_fd = swServer_get_maxfd(serv);
<         serv_min_fd = swServer_get_minfd(serv);
< 
<         checktime = (int) time(NULL) - serv->heartbeat_idle_time;
< 
<         //遍历到最大fd
<         for (fd = serv_min_fd; fd <= serv_max_fd; fd++)
<         {
<             swTrace("check fd=%d", fd);
<             conn = swServer_connection_get(serv, fd);
< 
<             if (conn != NULL && conn->active == 1 && conn->fdtype == SW_FD_TCP)
<             {
<                 if (conn->protect || conn->last_time > checktime)
<                 {
<                     continue;
<                 }
< 
<                 notify_ev.fd = fd;
<                 notify_ev.from_id = conn->from_id;
< 
<                 conn->close_force = 1;
<                 conn->close_notify = 1;
<                 conn->close_wait = 1;
< 
<                 if (serv->factory_mode != SW_MODE_PROCESS)
<                 {
<                     if (serv->factory_mode == SW_MODE_SINGLE)
<                     {
<                         reactor = SwooleG.main_reactor;
<                     }
<                     else
<                     {
<                         reactor = &serv->reactor_threads[conn->from_id].reactor;
<                     }
<                 }
<                 else
<                 {
<                     reactor = &serv->reactor_threads[conn->from_id].reactor;
<                 }
<                 //notify to reactor thread
<                 reactor->set(reactor, fd, SW_FD_TCP | SW_EVENT_WRITE);
<             }
<         }
<         sleep(serv->heartbeat_check_interval);
<     }
<     pthread_exit(0);
< }
< 
398d64
< 
466c132
<     int ret = -1;
---
>     int ret;
495c161
<     char packet[SW_BUFFER_SIZE_UDP] = {0};
---
>     char packet[SW_BUFFER_SIZE_UDP];
496a163
> 
594,849c261
<  * [ReactorThread] worker pipe can write.
<  */
< static int swReactorThread_onPipeWrite(swReactor *reactor, swEvent *ev)
< {
<     int ret = 0;
< 
<     swBuffer_trunk *trunk = NULL;
<     swEventData *send_data = NULL;
<     swConnection *conn = NULL;
<     swServer *serv = reactor->ptr;
<     swBuffer *buffer = serv->connection_list[ev->fd].in_buffer;
<     swLock *lock = serv->connection_list[ev->fd].object;
< 
<     //lock thread
<     lock->lock(lock);
< 
<     while (!swBuffer_empty(buffer))
<     {
<         trunk = swBuffer_get_trunk(buffer);
<         send_data = trunk->store.ptr;
< 
<         //server active close, discard data.
<         if (swEventData_is_stream(send_data->info.type))
<         {
<             //send_data->info.fd is session_id
<             conn = swServer_connection_verify(serv, send_data->info.fd);
<             if (conn == NULL || conn->closed)
<             {
< #ifdef SW_USE_RINGBUFFER
<                 swReactorThread *thread = swServer_get_thread(SwooleG.serv, SwooleTG.id);
<                 swPackage package;
<                 memcpy(&package, send_data->data, sizeof(package));
<                 thread->buffer_input->free(thread->buffer_input, package.data);
< #endif
<                 if (conn && conn->closed)
<                 {
<                     swoole_error_log(SW_LOG_NOTICE, SW_ERROR_SESSION_CLOSED_BY_SERVER, "Session#%d is closed by server.", send_data->info.fd);
<                 }
<                 swBuffer_pop_trunk(buffer, trunk);
<                 continue;
<             }
<         }
< 
<         ret = write(ev->fd, trunk->store.ptr, trunk->length);
<         if (ret < 0)
<         {
<             //release lock
<             lock->unlock(lock);
< #ifdef HAVE_KQUEUE
<             return (errno == EAGAIN || errno == ENOBUFS) ? SW_OK : SW_ERR;
< #else
<             return errno == EAGAIN ? SW_OK : SW_ERR;
< #endif
<         }
<         else
<         {
<             swBuffer_pop_trunk(buffer, trunk);
<         }
<     }
< 
<     //remove EPOLLOUT event
<     if (swBuffer_empty(buffer))
<     {
<         if (SwooleG.serv->connection_list[ev->fd].from_id == SwooleTG.id)
<         {
<             ret = reactor->set(reactor, ev->fd, SW_FD_PIPE | SW_EVENT_READ);
<         }
<         else
<         {
<             ret = reactor->del(reactor, ev->fd);
<         }
<         if (ret < 0)
<         {
<             swSysError("reactor->set(%d) failed.", ev->fd);
<         }
<     }
< 
<     //release lock
<     lock->unlock(lock);
< 
<     return SW_OK;
< }
< 
< /**
<  * receive data from worker process pipe
<  */
< static int swReactorThread_onPipeReceive(swReactor *reactor, swEvent *ev)
< {
<     int n;
<     swEventData resp;
<     swSendData _send;
< 
<     swPackage_response pkg_resp;
<     swWorker *worker;
< 
< #ifdef SW_REACTOR_RECV_AGAIN
<     while (1)
< #endif
<     {
<         n = read(ev->fd, &resp, sizeof(resp));
<         if (n > 0)
<         {
<             memcpy(&_send.info, &resp.info, sizeof(resp.info));
<             if (_send.info.type == SW_EVENT_DENY_REQUEST) {
<                 swServer* serv = SwooleG.serv;
<                 int target_worker_id = _send.info.worker_id;
<                 serv->workers[target_worker_id].deny_request = 1;
<                 swWarn("[Master] set worker exit.[work_id=%d]", target_worker_id);
<                 return SW_OK;
<             } else if(_send.info.type == SW_EVENT_DENY_EXIT) {
<                 swServer* serv = SwooleG.serv;
<                 int target_worker_id = _send.info.worker_id;
<                 serv->workers[target_worker_id].deny_request = 0;
<                 swWarn("[Master] set worker idle.[work_id=%d]", target_worker_id);
<                 return SW_OK;
<             }
< 
<             if (_send.info.from_fd == SW_RESPONSE_SMALL)
<             {
<                 _send.data = resp.data;
<                 _send.length = resp.info.len;
<                 swReactorThread_send(&_send);
<             }
<             else
<             {
<                 memcpy(&pkg_resp, resp.data, sizeof(pkg_resp));
<                 worker = swServer_get_worker(SwooleG.serv, pkg_resp.worker_id);
< 
<                 _send.data = worker->send_shm;
<                 _send.length = pkg_resp.length;
< 
<                 swReactorThread_send(&_send);
<                 worker->lock.unlock(&worker->lock);
<             }
<         }
<         else if (errno == EAGAIN)
<         {
<             return SW_OK;
<         }
<         else
<         {
<             swWarn("read(worker_pipe) failed. Error: %s[%d]", strerror(errno), errno);
<             return SW_ERR;
<         }
<     }
< 
<     return SW_OK;
< }
< 
< static int swReactorThread_onRead(swReactor *reactor, swEvent *event)
< {
< 	if (event->socket->from_fd == 0)
< 	{
< 		return SW_OK;
< 	}
< 
<     swServer *serv = reactor->ptr;
<     swListenPort *port = swServer_get_port(serv, event->fd);
< 
< #ifdef SW_USE_OPENSSL
<     if (swReactorThread_verify_ssl_state(port, event->socket) < 0)
<     {
<         return swReactorThread_close(reactor, event->fd);
<     }
< #endif
<     event->socket->last_time = SwooleGS->now;
<     return port->onRead(reactor, port, event);
< }
< 
< static int swReactorThread_onWrite(swReactor *reactor, swEvent *ev)
< {
<     int ret;
<     swServer *serv = SwooleG.serv;
<     int fd = ev->fd;
< 
<     assert(fd % serv->reactor_num == reactor->id);
<     assert(fd % serv->reactor_num == SwooleTG.id);
< 
<     swConnection *conn = swServer_connection_get(serv, fd);
<     if (conn->active == 0)
<     {
<         return SW_OK;
<     }
<     //notify worker process
<     else if (conn->connect_notify)
<     {
<         swServer_connection_ready(serv, fd, reactor->id);
<         conn->connect_notify = 0;
<         return reactor->set(reactor, fd, SW_EVENT_TCP | SW_EVENT_READ);
<     }
<     else if (conn->close_notify)
<     {
<         swDataHead close_event;
<         close_event.type = SW_EVENT_CLOSE;
<         close_event.from_id = reactor->id;
<         close_event.fd = fd;
< 
<         if (serv->factory.notify(&serv->factory, &close_event) < 0)
<         {
<             swWarn("send notification [fd=%d] failed.", fd);
<         }
<         conn->close_notify = 0;
<         return SW_OK;
<     }
<     else if (serv->disable_notify && conn->close_force)
<     {
<         return swReactorThread_close(reactor, fd);
<     }
< 
<     swBuffer_trunk *chunk = NULL;
<     while (!swBuffer_empty(conn->out_buffer))
<     {
<         chunk = swBuffer_get_trunk(conn->out_buffer);
<         if (chunk->type == SW_CHUNK_CLOSE)
<         {
<             close_fd: 
<             reactor->close(reactor, fd);
<             return SW_OK;
<         }
<         else if (chunk->type == SW_CHUNK_SENDFILE)
<         {
<             ret = swConnection_onSendfile(conn, chunk);
<         }
<         else
<         {
<             ret = swConnection_buffer_send(conn);
<         }
< 
<         if (ret < 0)
<         {
<             if (conn->close_wait)
<             {
<                 goto close_fd;
<             }
<             else if (conn->send_wait)
<             {
<                 return SW_OK;
<             }
<         }
<     }
< 
<     if (conn->overflow && conn->out_buffer->length < SwooleG.socket_buffer_size)
<     {
<         conn->overflow = 0;
<     }
< 
<     //remove EPOLLOUT event
<     if (swBuffer_empty(conn->out_buffer))
<     {
<         reactor->set(reactor, fd, SW_FD_TCP | SW_EVENT_READ);
<     }
<     return SW_OK;
< }
< 
< /**
<  * close connection
---
>  * close connection
876a289,295
> #ifdef SW_USE_OPENSSL
>     if (conn->ssl)
>     {
>         swSSL_close(conn);
>     }
> #endif
> 
903a323,336
> #if 0
>     //立即关闭socket，清理缓存区
>     if (0)
>     {
>         struct linger linger;
>         linger.l_onoff = 1;
>         linger.l_linger = 0;
>         if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &linger, sizeof(struct linger)) == -1)
>         {
>             swWarn("setsockopt(SO_LINGER) failed. Error: %s[%d]", strerror(errno), errno);
>         }
>     }
> #endif
> 
971c404,407
< int swReactorThread_send2worker(void *data, int len, uint16_t target_worker_id)
---
> /**
>  * receive data from worker process pipe
>  */
> static int swReactorThread_onPipeReceive(swReactor *reactor, swEvent *ev)
973c409,411
<     swServer *serv = SwooleG.serv;
---
>     int n;
>     swEventData resp;
>     swSendData _send;
975c413,471
<     int ret = -1;
---
>     swPackage_response pkg_resp;
>     swWorker *worker;
> 
> #ifdef SW_REACTOR_RECV_AGAIN
>     while (1)
> #endif
>     {
>         n = read(ev->fd, &resp, sizeof(resp));
>         if (n > 0)
>         {
>             memcpy(&_send.info, &resp.info, sizeof(resp.info));
>             if (_send.info.from_fd == SW_RESPONSE_SMALL)
>             {
>                 _send.data = resp.data;
>                 _send.length = resp.info.len;
>                 swReactorThread_send(&_send);
>             }
>             else
>             {
>                 memcpy(&pkg_resp, resp.data, sizeof(pkg_resp));
>                 worker = swServer_get_worker(SwooleG.serv, pkg_resp.worker_id);
> 
>                 _send.data = worker->send_shm;
>                 _send.length = pkg_resp.length;
> 
> #if 0
>                 struct
>                 {
>                     uint32_t worker;
>                     uint32_t index;
>                     uint32_t serid;
>                 } pkg_header;
> 
>                 memcpy(&pkg_header, _send.data + 4, sizeof(pkg_header));
>                 swWarn("fd=%d, worker=%d, index=%d, serid=%d", _send.info.fd, pkg_header.worker, pkg_header.index, pkg_header.serid);
> #endif
>                 swReactorThread_send(&_send);
>                 worker->lock.unlock(&worker->lock);
>             }
>         }
>         else if (errno == EAGAIN)
>         {
>             return SW_OK;
>         }
>         else
>         {
>             swWarn("read(worker_pipe) failed. Error: %s[%d]", strerror(errno), errno);
>             return SW_ERR;
>         }
>     }
> 
>     return SW_OK;
> }
> 
> int swReactorThread_send2worker(void *data, int len, uint16_t target_worker_id)
> {
>     swServer *serv = SwooleG.serv;
> 
>     int ret = -1;
1061,1062c557,566
<     swReactor *reactor = (serv->factory_mode == SW_MODE_SINGLE)?
<                          &(serv->reactor_threads[0].reactor):&(serv->reactor_threads[conn->from_id].reactor);
---
>     swReactor *reactor;
> 
>     if (serv->factory_mode == SW_MODE_SINGLE)
>     {
>         reactor = &(serv->reactor_threads[0].reactor);
>     }
>     else
>     {
>         reactor = &(serv->reactor_threads[conn->from_id].reactor);
>     }
1094c598
<         direct_send:
---
>             direct_send:
1143c647
<         swConnection_sendfile_async(conn, _send_data);
---
>         swConnection_sendfile(conn, _send_data);
1148,1149c652,1102
<         //connection is closed
<         if (conn->removed)
---
>         //connection is closed
>         if (conn->removed)
>         {
>             swWarn("connection#%d is closed by client.", fd);
>             return SW_ERR;
>         }
>         //connection output buffer overflow
>         if (conn->out_buffer->length >= serv->buffer_output_size)
>         {
>             swoole_error_log(SW_LOG_WARNING, SW_ERROR_OUTPUT_BUFFER_OVERFLOW, "connection#%d output buffer overflow.", fd);
>             conn->overflow = 1;
>         }
> 
>         int _length = _send_length;
>         void* _pos = _send_data;
>         int _n;
> 
>         //buffer enQueue
>         while (_length > 0)
>         {
>             _n = _length >= SW_BUFFER_SIZE_BIG ? SW_BUFFER_SIZE_BIG : _length;
>             swBuffer_append(conn->out_buffer, _pos, _n);
>             _pos += _n;
>             _length -= _n;
>         }
>     }
> 
>     //listen EPOLLOUT event
>     if (reactor->set(reactor, fd, SW_EVENT_TCP | SW_EVENT_WRITE | SW_EVENT_READ) < 0
>             && (errno == EBADF || errno == ENOENT))
>     {
>         goto close_fd;
>     }
> 
>     return SW_OK;
> }
> 
> /**
>  * [ReactorThread] worker pipe can write.
>  */
> static int swReactorThread_onPipeWrite(swReactor *reactor, swEvent *ev)
> {
>     int ret;
> 
>     swBuffer_trunk *trunk = NULL;
>     swEventData *send_data;
>     swConnection *conn;
>     swServer *serv = reactor->ptr;
>     swBuffer *buffer = serv->connection_list[ev->fd].in_buffer;
>     swLock *lock = serv->connection_list[ev->fd].object;
> 
>     //lock thread
>     lock->lock(lock);
> 
>     while (!swBuffer_empty(buffer))
>     {
>         trunk = swBuffer_get_trunk(buffer);
>         send_data = trunk->store.ptr;
> 
>         //server active close, discard data.
>         if (swEventData_is_stream(send_data->info.type))
>         {
>             //send_data->info.fd is session_id
>             conn = swServer_connection_verify(serv, send_data->info.fd);
>             if (conn == NULL || conn->closed)
>             {
> #ifdef SW_USE_RINGBUFFER
>                 swReactorThread *thread = swServer_get_thread(SwooleG.serv, SwooleTG.id);
>                 swPackage package;
>                 memcpy(&package, send_data->data, sizeof(package));
>                 thread->buffer_input->free(thread->buffer_input, package.data);
> #endif
>                 if (conn && conn->closed)
>                 {
>                     swoole_error_log(SW_LOG_NOTICE, SW_ERROR_SESSION_CLOSED_BY_SERVER, "Session#%d is closed by server.", send_data->info.fd);
>                 }
>                 swBuffer_pop_trunk(buffer, trunk);
>                 continue;
>             }
>         }
> 
>         ret = write(ev->fd, trunk->store.ptr, trunk->length);
>         if (ret < 0)
>         {
>             //release lock
>             lock->unlock(lock);
> #ifdef HAVE_KQUEUE
>             return (errno == EAGAIN || errno == ENOBUFS) ? SW_OK : SW_ERR;
> #else
>             return errno == EAGAIN ? SW_OK : SW_ERR;
> #endif
>         }
>         else
>         {
>             swBuffer_pop_trunk(buffer, trunk);
>         }
>     }
> 
>     //remove EPOLLOUT event
>     if (swBuffer_empty(buffer))
>     {
>         if (SwooleG.serv->connection_list[ev->fd].from_id == SwooleTG.id)
>         {
>             ret = reactor->set(reactor, ev->fd, SW_FD_PIPE | SW_EVENT_READ);
>         }
>         else
>         {
>             ret = reactor->del(reactor, ev->fd);
>         }
>         if (ret < 0)
>         {
>             swSysError("reactor->set(%d) failed.", ev->fd);
>         }
>     }
> 
>     //release lock
>     lock->unlock(lock);
> 
>     return SW_OK;
> }
> 
> void swReactorThread_set_protocol(swServer *serv, swReactor *reactor)
> {
>     //UDP Packet
>     reactor->setHandle(reactor, SW_FD_UDP, swReactorThread_onPackage);
>     //Write
>     reactor->setHandle(reactor, SW_FD_TCP | SW_EVENT_WRITE, swReactorThread_onWrite);
>     //Read
>     reactor->setHandle(reactor, SW_FD_TCP | SW_EVENT_READ, swReactorThread_onRead);
> 
>     swListenPort *ls;
>     //listen the all tcp port
>     LL_FOREACH(serv->listen_list, ls)
>     {
>         if (swSocket_is_dgram(ls->type))
>         {
>             continue;
>         }
>         swPort_set_protocol(ls);
>     }
> }
> 
> static int swReactorThread_onRead(swReactor *reactor, swEvent *event)
> {
>     swServer *serv = reactor->ptr;
>     swListenPort *port = swServer_get_port(serv, event->fd);
> 
> #ifdef SW_USE_OPENSSL
>     if (swReactorThread_verify_ssl_state(port, event->socket) < 0)
>     {
>         return swReactorThread_close(reactor, event->fd);
>     }
> #endif
>     event->socket->last_time = SwooleGS->now;
>     return port->onRead(reactor, port, event);
> }
> 
> static int swReactorThread_onWrite(swReactor *reactor, swEvent *ev)
> {
>     int ret;
>     swServer *serv = SwooleG.serv;
>     int fd = ev->fd;
> 
>     assert(fd % serv->reactor_num == reactor->id);
>     assert(fd % serv->reactor_num == SwooleTG.id);
> 
>     swConnection *conn = swServer_connection_get(serv, fd);
>     if (conn->active == 0)
>     {
>         return SW_OK;
>     }
>     //notify worker process
>     else if (conn->connect_notify)
>     {
>         swServer_connection_ready(serv, fd, reactor->id);
>         conn->connect_notify = 0;
>         return reactor->set(reactor, fd, SW_EVENT_TCP | SW_EVENT_READ);
>     }
>     else if (conn->close_notify)
>     {
>         swDataHead close_event;
>         close_event.type = SW_EVENT_CLOSE;
>         close_event.from_id = reactor->id;
>         close_event.fd = fd;
> 
>         if (serv->factory.notify(&serv->factory, &close_event) < 0)
>         {
>             swWarn("send notification [fd=%d] failed.", fd);
>         }
>         conn->close_notify = 0;
>         return SW_OK;
>     }
>     else if (serv->disable_notify && conn->close_force)
>     {
>         return swReactorThread_close(reactor, fd);
>     }
> 
>     swBuffer_trunk *chunk;
> 
>     while (!swBuffer_empty(conn->out_buffer))
>     {
>         chunk = swBuffer_get_trunk(conn->out_buffer);
>         if (chunk->type == SW_CHUNK_CLOSE)
>         {
>             close_fd: reactor->close(reactor, fd);
>             return SW_OK;
>         }
>         else if (chunk->type == SW_CHUNK_SENDFILE)
>         {
>             ret = swConnection_onSendfile(conn, chunk);
>         }
>         else
>         {
>             ret = swConnection_buffer_send(conn);
>         }
> 
>         if (ret < 0)
>         {
>             if (conn->close_wait)
>             {
>                 goto close_fd;
>             }
>             else if (conn->send_wait)
>             {
>                 return SW_OK;
>             }
>         }
>     }
> 
>     if (conn->overflow && conn->out_buffer->length < SwooleG.socket_buffer_size)
>     {
>         conn->overflow = 0;
>     }
> 
>     //remove EPOLLOUT event
>     if (swBuffer_empty(conn->out_buffer))
>     {
>         reactor->set(reactor, fd, SW_FD_TCP | SW_EVENT_READ);
>     }
>     return SW_OK;
> }
> 
> int swReactorThread_create(swServer *serv)
> {
>     int ret = 0;
>     /**
>      * init reactor thread pool
>      */
>     serv->reactor_threads = SwooleG.memory_pool->alloc(SwooleG.memory_pool, (serv->reactor_num * sizeof(swReactorThread)));
>     if (serv->reactor_threads == NULL)
>     {
>         swError("calloc[reactor_threads] fail.alloc_size=%d", (int )(serv->reactor_num * sizeof(swReactorThread)));
>         return SW_ERR;
>     }
> 
>     /**
>      * alloc the memory for connection_list
>      */
>     if (serv->factory_mode == SW_MODE_PROCESS)
>     {
>         serv->connection_list = sw_shm_calloc(serv->max_connection, sizeof(swConnection));
>     }
>     else
>     {
>         serv->connection_list = sw_calloc(serv->max_connection, sizeof(swConnection));
>     }
>     if (serv->connection_list == NULL)
>     {
>         swError("calloc[1] failed");
>         return SW_ERR;
>     }
> 
>     //create factry object
>     if (serv->factory_mode == SW_MODE_THREAD)
>     {
>         if (serv->worker_num < 1)
>         {
>             swError("Fatal Error: serv->worker_num < 1");
>             return SW_ERR;
>         }
>         ret = swFactoryThread_create(&(serv->factory), serv->worker_num);
>     }
>     else if (serv->factory_mode == SW_MODE_PROCESS)
>     {
>         if (serv->worker_num < 1)
>         {
>             swError("Fatal Error: serv->worker_num < 1");
>             return SW_ERR;
>         }
>         ret = swFactoryProcess_create(&(serv->factory), serv->worker_num);
>     }
>     else
>     {
>         ret = swFactory_create(&(serv->factory));
>     }
> 
>     if (ret < 0)
>     {
>         swError("create factory failed");
>         return SW_ERR;
>     }
>     return SW_OK;
> }
> 
> int swReactorThread_start(swServer *serv, swReactor *main_reactor_ptr)
> {
>     swThreadParam *param;
>     swReactorThread *thread;
>     pthread_t pidt;
>     int i;
> 
>     swServer_store_listen_socket(serv);
> 
>     //listen UDP
>     if (serv->have_udp_sock == 1)
>     {
>         if (swUDPThread_start(serv) < 0)
>         {
>             swError("udp thread start failed.");
>             return SW_ERR;
>         }
>     }
> 
> #ifdef HAVE_REUSEPORT
>     SwooleG.reuse_port = 0;
> #endif
> 
>     //listen TCP
>     if (serv->have_tcp_sock == 1)
>     {
>         swListenPort *ls;
>         LL_FOREACH(serv->listen_list, ls)
>         {
>             if (ls->type == SW_SOCK_UDP || ls->type == SW_SOCK_UDP6 || ls->type == SW_SOCK_UNIX_DGRAM)
>             {
>                 continue;
>             }
>             main_reactor_ptr->add(main_reactor_ptr, ls->sock, SW_FD_LISTEN);
>         }
> 
> #ifdef HAVE_PTHREAD_BARRIER
>         //init thread barrier
>         pthread_barrier_init(&serv->barrier, NULL, serv->reactor_num + 1);
> #endif
> 
>         //create reactor thread
>         for (i = 0; i < serv->reactor_num; i++)
>         {
>             thread = &(serv->reactor_threads[i]);
>             param = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swThreadParam));
>             if (param == NULL)
>             {
>                 swError("malloc failed");
>                 return SW_ERR;
>             }
> 
>             param->object = serv;
>             param->pti = i;
> 
>             if (pthread_create(&pidt, NULL, (void * (*)(void *)) swReactorThread_loop_stream, (void *) param) < 0)
>             {
>                 swError("pthread_create[tcp_reactor] failed. Error: %s[%d]", strerror(errno), errno);
>             }
>             thread->thread_id = pidt;
>         }
> #ifdef HAVE_PTHREAD_BARRIER
>         //wait reactor thread
>         pthread_barrier_wait(&serv->barrier);
> #else
>         SW_START_SLEEP;
> #endif
>     }
> 
>     return SW_OK;
> }
> 
> /**
>  * ReactorThread main Loop
>  */
> static int swReactorThread_loop_stream(swThreadParam *param)
> {
>     swServer *serv = SwooleG.serv;
>     int ret;
>     int reactor_id = param->pti;
> 
>     SwooleTG.factory_lock_target = 0;
>     SwooleTG.factory_target_worker = -1;
>     SwooleTG.id = reactor_id;
>     SwooleTG.type = SW_THREAD_REACTOR;
> 
>     swReactorThread *thread = swServer_get_thread(serv, reactor_id);
>     swReactor *reactor = &thread->reactor;
> 
> #ifdef HAVE_CPU_AFFINITY
>     //cpu affinity setting
>     if (serv->open_cpu_affinity)
>     {
>         cpu_set_t cpu_set;
>         CPU_ZERO(&cpu_set);
> 
>         if (serv->cpu_affinity_available_num)
>         {
>             CPU_SET(serv->cpu_affinity_available[reactor_id % serv->cpu_affinity_available_num], &cpu_set);
>         }
>         else
>         {
>             CPU_SET(reactor_id % SW_CPU_NUM, &cpu_set);
>         }
> 
>         if (0 != pthread_setaffinity_np(pthread_self(), sizeof(cpu_set), &cpu_set))
>         {
>             swSysError("pthread_setaffinity_np() failed");
>         }
>     }
> #endif
> 
>     ret = swReactor_create(reactor, SW_REACTOR_MAXEVENTS);
>     if (ret < 0)
>     {
>         return SW_ERR;
>     }
> 
>     swSignal_none();
> 
>     reactor->ptr = serv;
>     reactor->id = reactor_id;
>     reactor->thread = 1;
>     reactor->socket_list = serv->connection_list;
>     reactor->max_socket = serv->max_connection;
> 
>     reactor->onFinish = NULL;
>     reactor->onTimeout = NULL;
>     reactor->close = swReactorThread_close;
> 
>     reactor->setHandle(reactor, SW_FD_CLOSE, swReactorThread_onClose);
>     reactor->setHandle(reactor, SW_FD_PIPE | SW_EVENT_READ, swReactorThread_onPipeReceive);
>     reactor->setHandle(reactor, SW_FD_PIPE | SW_EVENT_WRITE, swReactorThread_onPipeWrite);
> 
>     //set protocol function point
>     swReactorThread_set_protocol(serv, reactor);
> 
>     int i = 0, pipe_fd;
> #ifdef SW_USE_RINGBUFFER
>     int j = 0;
> #endif
> 
>     if (serv->factory_mode == SW_MODE_PROCESS)
>     {
> #ifdef SW_USE_RINGBUFFER
>         thread->pipe_read_list = sw_calloc(serv->reactor_pipe_num, sizeof(int));
>         if (thread->pipe_read_list == NULL)
1151c1104
<             swWarn("connection#%d is closed by client.", fd);
---
>             swSysError("thread->buffer_pipe create failed");
1154,1155c1107,1109
<         //connection output buffer overflow
<         if (conn->out_buffer->length >= serv->buffer_output_size)
---
> #endif
> 
>         for (i = 0; i < serv->worker_num; i++)
1157,1159c1111,1113
<             swoole_error_log(SW_LOG_WARNING, SW_ERROR_OUTPUT_BUFFER_OVERFLOW, "connection#%d output buffer overflow.", fd);
<             conn->overflow = 1;
<         }
---
>             if (i % serv->reactor_num == reactor_id)
>             {
>                 pipe_fd = serv->workers[i].pipe_master;
1161,1163c1115,1122
<         int _length = _send_length;
<         void* _pos = _send_data;
<         int _n;
---
>                 //for request
>                 swBuffer *buffer = swBuffer_new(sizeof(swEventData));
>                 if (!buffer)
>                 {
>                     swWarn("create buffer failed.");
>                     break;
>                 }
>                 serv->connection_list[pipe_fd].in_buffer = buffer;
1165,1173c1124,1126
<         //buffer enQueue
<         while (_length > 0)
<         {
<             _n = _length >= SW_BUFFER_SIZE_BIG ? SW_BUFFER_SIZE_BIG : _length;
<             swBuffer_append(conn->out_buffer, _pos, _n);
<             _pos += _n;
<             _length -= _n;
<         }
<     }
---
>                 //for response
>                 swSetNonBlock(pipe_fd);
>                 reactor->add(reactor, pipe_fd, SW_FD_PIPE);
1175,1179c1128,1150
<     //listen EPOLLOUT event
<     if (reactor->set(reactor, fd, SW_EVENT_TCP | SW_EVENT_WRITE | SW_EVENT_READ) < 0
<             && (errno == EBADF || errno == ENOENT))
<     {
<         goto close_fd;
---
>                 /**
>                  * mapping reactor_id and worker pipe
>                  */
>                 serv->connection_list[pipe_fd].from_id = reactor_id;
>                 serv->connection_list[pipe_fd].fd = pipe_fd;
>                 serv->connection_list[pipe_fd].object = sw_malloc(sizeof(swLock));
> 
>                 /**
>                  * create pipe lock
>                  */
>                 if (serv->connection_list[pipe_fd].object == NULL)
>                 {
>                     swWarn("create pipe mutex lock failed.");
>                     break;
>                 }
>                 swMutex_create(serv->connection_list[pipe_fd].object, 0);
> 
> #ifdef SW_USE_RINGBUFFER
>                 thread->pipe_read_list[j] = pipe_fd;
>                 j++;
> #endif
>             }
>         }
1181a1153,1163
>     //wait other thread
> #ifdef HAVE_PTHREAD_BARRIER
>     pthread_barrier_wait(&serv->barrier);
> #else
>     SW_START_SLEEP;
> #endif
>     //main loop
>     reactor->wait(reactor, NULL);
>     //shutdown
>     reactor->free(reactor);
>     pthread_exit(0);
1185c1167
< void swReactorThread_set_protocol(swServer *serv, swReactor *reactor)
---
> static int swUDPThread_start(swServer *serv)
1187,1192c1169,1172
<     //UDP Packet
<     reactor->setHandle(reactor, SW_FD_UDP, swReactorThread_onPackage);
<     //Write
<     reactor->setHandle(reactor, SW_FD_TCP | SW_EVENT_WRITE, swReactorThread_onWrite);
<     //Read
<     reactor->setHandle(reactor, SW_FD_TCP | SW_EVENT_READ, swReactorThread_onRead);
---
>     swThreadParam *param;
>     pthread_t thread_id;
>     swListenPort *ls;
>     int index = serv->reactor_num;
1194,1195d1173
<     swListenPort *ls = NULL;
<     //listen the all tcp port
1198,1203c1176
<         if (!swSocket_is_dgram(ls->type))
<         {
<         	swPort_set_protocol(ls);
<         }
<     }
< }
---
>         param = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swThreadParam));
1205,1214c1178,1187
< int swReactorThread_create(swServer *serv)
< {
<     
<     ///init reactor thread pool
<     serv->reactor_threads = SwooleG.memory_pool->alloc(SwooleG.memory_pool, (serv->reactor_num * sizeof(swReactorThread)));
<     if (!serv->reactor_threads)
<     {
<         swError("calloc[reactor_threads] fail.alloc_size=%d", (int )(serv->reactor_num * sizeof(swReactorThread)));
<         return SW_ERR;
<     }
---
>         if (ls->type == SW_SOCK_UDP || ls->type == SW_SOCK_UDP6 || ls->type == SW_SOCK_UNIX_DGRAM)
>         {
>             if (ls->type == SW_SOCK_UDP)
>             {
>                 serv->connection_list[ls->sock].info.addr.inet_v4.sin_port = htons(ls->port);
>             }
>             else
>             {
>                 serv->connection_list[ls->sock].info.addr.inet_v6.sin6_port = htons(ls->port);
>             }
1216,1227c1189,1191
<     /**
<      * alloc the memory for connection_list
<      */
<     serv->connection_list = (serv->factory_mode == SW_MODE_PROCESS)?
<                         sw_shm_calloc(serv->max_connection, sizeof(swConnection)):
<                         sw_calloc(serv->max_connection, sizeof(swConnection));
<                         
<     if (!serv->connection_list)
<     {
<         swError("calloc[1] failed");
<         return SW_ERR;
<     }
---
>             serv->connection_list[ls->sock].fd = ls->sock;
>             serv->connection_list[ls->sock].socket_type = ls->type;
>             serv->connection_list[ls->sock].object = ls;
1229,1233c1193,1194
<     //create factry object
<     int ret = (serv->factory_mode == SW_MODE_THREAD)?
<               swFactoryThread_create(&(serv->factory), serv->worker_num):
<               ((serv->factory_mode == SW_MODE_PROCESS)? swFactoryProcess_create(&(serv->factory), serv->worker_num):
<               swFactory_create(&(serv->factory)));
---
>             param->object = ls;
>             param->pti = index++;
1235,1237c1196,1202
<     if (ret < 0)
<     {
<         swError("create factory failed");
---
>             if (pthread_create(&thread_id, NULL, (void * (*)(void *)) swReactorThread_loop_dgram, (void *) param) < 0)
>             {
>                 swWarn("pthread_create[udp_listener] fail");
>                 return SW_ERR;
>             }
>             ls->thread_id = thread_id;
>         }
1239,1240c1204
< 
<     return ret < 0? SW_ERR:SW_OK;
---
>     return SW_OK;
1244,1245c1208
<  * proxy模式
<  * 在单独的n个线程中接受维持TCP连接
---
>  * udp listener thread
1247c1210
< int swReactorThread_start(swServer *serv)
---
> static int swReactorThread_loop_dgram(swThreadParam *param)
1249,1279c1212,1213
<     swReactor *main_reactor = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swReactor));
<     if (swReactor_init(main_reactor, SW_REACTOR_MAXEVENTS) < 0)
<     {
<         swWarn("Reactor create failed");
<         return SW_ERR;
<     }
< 
<     /**
<     * master thread loop
<     */
<     SwooleTG.type = SW_THREAD_MASTER;
<     SwooleTG.factory_target_worker = -1;
<     SwooleTG.factory_lock_target = 0;
<     SwooleTG.id = 0;
<     SwooleTG.update_time = 1;
< 
<     SwooleG.main_reactor = main_reactor;
<     SwooleG.pid = getpid();
<     SwooleG.process_type = SW_PROCESS_MASTER;
< 
<     main_reactor->thread = 1;
<     main_reactor->socket_list = serv->connection_list;    
<     main_reactor->disable_accept = 0;
<     main_reactor->enable_accept = swServer_enable_accept;
< 
< #ifdef HAVE_SIGNALFD
<     if (SwooleG.use_signalfd)
<     {
<         swSignalfd_setup(main_reactor);
<     }
< #endif
---
>     swEvent event;
>     swListenPort *ls = param->object;
1281c1215
<     swServer_store_listen_socket(serv);
---
>     int fd = ls->sock;
1283,1288c1217,1220
<     //listen UDP, 一个端口一个线程监听
<     if (serv->have_udp_sock == 1 && swUDPThread_start(serv) < 0)
<     {
<         swError("udp thread start failed.");
<         return SW_ERR;
<     }
---
>     SwooleTG.factory_lock_target = 0;
>     SwooleTG.factory_target_worker = -1;
>     SwooleTG.id = param->pti;
>     SwooleTG.type = SW_THREAD_UDP;
1290,1292c1222
< #ifdef HAVE_REUSEPORT
<     SwooleG.reuse_port = 0;
< #endif
---
>     swSignal_none();
1294,1299c1224,1226
<     //listen TCP 
<     if (serv->have_tcp_sock == 1 && swTCPThread_start(serv) < 0)
<     {
<         swError("tcp thread start failed.");
<         return SW_ERR;
<     }
---
>     //blocking
>     swSetBlock(fd);
>     event.fd = fd;
1301,1304c1228
<     /**
<      * heartbeat thread
<      */
<     if (serv->heartbeat_check_interval >= 1 && serv->heartbeat_check_interval <= serv->heartbeat_idle_time)
---
>     while (SwooleG.running == 1)
1306,1307c1230
<         swTrace("hb timer start, time: %d live time:%d", serv->heartbeat_check_interval, serv->heartbeat_idle_time);
<         swHeartbeatThread_start(serv);
---
>         swReactorThread_onPackage(NULL, &event);
1309,1325c1232,1233
<     
<     /**
<      * set a special id
<      */
<     main_reactor->id = serv->reactor_num;
<     main_reactor->ptr = serv;
<     main_reactor->setHandle(main_reactor, SW_FD_LISTEN, swServer_master_onAccept);
< 
<     if (serv->onStart)
<     {
<         serv->onStart(serv);
<     }
<     
<     struct timeval tmo;
<     tmo.tv_sec = 1; //for seconds timer
<     tmo.tv_usec = 0;
<     return main_reactor->wait(main_reactor, &tmo);;
---
>     pthread_exit(0);
>     return 0;
1332d1239
<     memset(&task, 0, sizeof(task));
1413a1321,1406
> #if 0
> int swReactorThread_dispatch_array_buffer(swReactorThread *thread, swConnection *conn)
> {
>     swDispatchData task;
>     swFactory *factory = SwooleG.factory;
> 
>     task.data.info.fd = conn->fd;
>     task.data.info.from_id = conn->from_id;
> 
>     swBuffer *buffer = conn->in_buffer;
>     swBuffer_trunk *trunk = swBuffer_get_trunk(buffer);
> 
> #ifdef SW_USE_RINGBUFFER
>     swServer *serv = SwooleG.serv;
>     uint16_t target_worker_id = swServer_worker_schedule(serv, conn->fd);
>     swPackage package;
> 
>     package.length = 0;
>     package.data = swReactorThread_alloc(thread, buffer->length);
> 
>     task.data.info.type = SW_EVENT_PACKAGE;
> 
>     while (trunk != NULL)
>     {
>         task.data.info.len = trunk->length;
>         memcpy(package.data + package.length, trunk->store.ptr, trunk->length);
>         package.length += trunk->length;
> 
>         swBuffer_pop_trunk(buffer, trunk);
>         trunk = swBuffer_get_trunk(buffer);
>     }
>     task.data.info.len = sizeof(package);
>     task.target_worker_id = target_worker_id;
>     memcpy(task.data.data, &package, sizeof(package));
>     //swWarn("[ReactorThread] copy_n=%d", package.length);
>     //dispatch failed, free the memory.
>     if (factory->dispatch(factory, &task) < 0)
>     {
>         thread->buffer_input->free(thread->buffer_input, package.data);
>     }
>     else
>     {
>         return SW_OK;
>     }
> #else
>     int ret;
>     task.data.info.type = SW_EVENT_PACKAGE_START;
>     task.target_worker_id = -1;
> 
>     /**
>      * lock target
>      */
>     SwooleTG.factory_lock_target = 1;
> 
>     while (trunk != NULL)
>     {
>         task.data.info.fd = conn->fd;
>         task.data.info.len = trunk->length;
>         memcpy(task.data.data, trunk->store.ptr, task.data.info.len);
>         //package end
>         if (trunk->next == NULL)
>         {
>             task.data.info.type = SW_EVENT_PACKAGE_END;
>         }
>         ret = factory->dispatch(factory, &task);
>         //TODO: 处理数据失败，数据将丢失
>         if (ret < 0)
>         {
>             swWarn("factory->dispatch() failed.");
>         }
>         swBuffer_pop_trunk(buffer, trunk);
>         trunk = swBuffer_get_trunk(buffer);
> 
>         swTrace("send2worker[trunk_num=%d][type=%d]", buffer->trunk_num, task.data.info.type);
>     }
>     /**
>      * unlock
>      */
>     SwooleTG.factory_target_worker = -1;
>     SwooleTG.factory_lock_target = 0;
> 
> #endif
>     return SW_OK;
> }
> #endif
> 
1415a1409,1411
>     int i;
>     swReactorThread *thread;
> 
1423,1424d1418
<     	int i = 0;
<     	swReactorThread *thread = NULL;
1430,1434c1424
<             if (thread->thread_id && pthread_cancel(thread->thread_id) != 0)
<             {
<             	swSysError("pthread_cancel(%ld) failed.",(long)thread->thread_id);
<             }
< 
---
>             pthread_cancel(thread->thread_id);
1436c1426
<             if (thread->thread_id && pthread_join(thread->thread_id, NULL) != 0)
---
>             if (pthread_join(thread->thread_id, NULL))
1438c1428
<                 swWarn("pthread_join(%ld) failed. Error: %s[%d]", (long)thread->thread_id,strerror(errno), errno);
---
>                 swWarn("pthread_join() failed. Error: %s[%d]", strerror(errno), errno);
1440d1429
< 
1454c1443
<             if (swSocket_is_dgram(ls->type))
---
>             if (ls->type == SW_SOCK_UDP || ls->type == SW_SOCK_UDP6 || ls->type == SW_SOCK_UNIX_DGRAM)
1456,1461c1445,1446
<                 if (ls->thread_id && pthread_cancel(ls->thread_id) != 0)
<                 {
<                 	swSysError("pthread_cancel(%ld) failed.",(long)ls->thread_id);
<                 }
< 
<                 if (ls->thread_id && pthread_join(ls->thread_id, NULL) != 0)
---
>                 pthread_cancel(ls->thread_id);
>                 if (pthread_join(ls->thread_id, NULL))
1463c1448
<                     swWarn("pthread_join(%ld) failed. Error: %s[%d]", (long)ls->thread_id,strerror(errno), errno);
---
>                     swWarn("pthread_join() failed. Error: %s[%d]", strerror(errno), errno);
diff -r ./zan-extension/src/network/Server.c ../swoole-1.8.5-stable/src/network/Server.c
17,35c17,19
< #include "list.h"
< #include "swServer.h"
< #include "swWork.h"
< #include "swError.h"
< #include "swSignal.h"
< #include "swLog.h"
< #include "swExecutor.h"
< #include "swProtocol/http.h"
< #include "swConnection.h"
< #include "swBaseOperator.h"
< #include "swGlobalVars.h"
< 
< 
< swServerG SwooleG;			/// 超全局本地变量，此全局变量子进程中修改，其它进程不感知
< swServerGS *SwooleGS;		/// 超全局共享变量，此全局变量是基于共享内存的，修改字段，其它进程可感知
< swWorkerG SwooleWG;			/// 进程内全局变量，此全局变量在worker进程内初始化
< swServerStats *SwooleStats;
< __thread swThreadG SwooleTG;   /// 线程独立变量
< 
---
> #include "Server.h"
> #include "http.h"
> #include "Connection.h"
41c25
<     int index = 0, event_num = serv->reactor_threads[0].reactor.event_num;
---
>     int i, event_num = serv->reactor_threads[0].reactor.event_num;
43c27
<     for (index = 1; index < serv->reactor_num; index++)
---
>     for (i = 1; i < serv->reactor_num; i++)
45c29
<         if (serv->reactor_threads[index].reactor.event_num < event_num)
---
>         if (serv->reactor_threads[i].reactor.event_num < event_num)
47,48c31,32
<             serv->reactor_next_i = index;
<             event_num = serv->reactor_threads[index].reactor.event_num;
---
>             serv->reactor_next_i = i;
>             event_num = serv->reactor_threads[i].reactor.event_num;
52d35
< 
56,57d38
< 
< static void swServer_signal_init(void);
58a40,44
> static int swServer_start_proxy(swServer *serv);
> static void swServer_disable_accept(swReactor *reactor);
> 
> static void swHeartbeatThread_start(swServer *serv);
> static void swHeartbeatThread_loop(swThreadParam *param);
63,65c49,213
< static void (*onConnect_callback)(swServer *, int, int);
< static int (*onReceive_callback)(swServer *, char *, int, int, int);
< static void (*onClose_callback)(swServer *, int, int);
---
> static swConnection* swServer_connection_new(swServer *serv, swListenPort *ls, int fd, int from_fd, int reactor_id);
> 
> swServerG SwooleG;
> swServerGS *SwooleGS;
> swWorkerG SwooleWG;
> swServerStats *SwooleStats;
> __thread swThreadG SwooleTG;
> 
> int16_t sw_errno;
> char sw_error[SW_ERROR_MSG_SIZE];
> 
> static void swServer_disable_accept(swReactor *reactor)
> {
>     swListenPort *ls;
> 
>     LL_FOREACH(SwooleG.serv->listen_list, ls)
>     {
>         //UDP
>         if (ls->type == SW_SOCK_UDP || ls->type == SW_SOCK_UDP6 || ls->type == SW_SOCK_UNIX_DGRAM)
>         {
>             continue;
>         }
>         reactor->del(reactor, ls->sock);
>     }
> }
> 
> void swServer_enable_accept(swReactor *reactor)
> {
>     swListenPort *ls;
> 
>     LL_FOREACH(SwooleG.serv->listen_list, ls)
>     {
>         //UDP
>         if (ls->type == SW_SOCK_UDP || ls->type == SW_SOCK_UDP6 || ls->type == SW_SOCK_UNIX_DGRAM)
>         {
>             continue;
>         }
>         reactor->add(reactor, ls->sock, SW_FD_LISTEN);
>     }
> }
> 
> int swServer_master_onAccept(swReactor *reactor, swEvent *event)
> {
>     swServer *serv = reactor->ptr;
>     swReactor *sub_reactor;
>     swSocketAddress client_addr;
>     socklen_t client_addrlen = sizeof(client_addr);
>     swListenPort *listen_host = serv->connection_list[event->fd].object;
> 
>     int new_fd = 0, ret, reactor_id = 0, i;
> 
>     //SW_ACCEPT_AGAIN
>     for (i = 0; i < SW_ACCEPT_MAX_COUNT; i++)
>     {
> #ifdef HAVE_ACCEPT4
>         new_fd = accept4(event->fd, (struct sockaddr *) &client_addr, &client_addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);
> #else
>         new_fd = accept(event->fd, (struct sockaddr *) &client_addr, &client_addrlen);
> #endif
>         if (new_fd < 0)
>         {
>             switch (errno)
>             {
>             case EAGAIN:
>                 return SW_OK;
>             case EINTR:
>                 continue;
>             default:
>                 if (errno == EMFILE || errno == ENFILE)
>                 {
>                     swServer_disable_accept(reactor);
>                     reactor->disable_accept = 1;
>                 }
>                 swoole_error_log(SW_LOG_ERROR, SW_ERROR_SYSTEM_CALL_FAIL, "accept() failed. Error: %s[%d]", strerror(errno), errno);
>                 return SW_OK;
>             }
>         }
> #ifndef HAVE_ACCEPT4
>         else
>         {
>             swSetNonBlock(new_fd);
>         }
> #endif
> 
>         swTrace("[Master] Accept new connection. maxfd=%d|reactor_id=%d|conn=%d", swServer_get_maxfd(serv), reactor->id, new_fd);
> 
>         //too many connection
>         if (new_fd >= serv->max_connection)
>         {
>             swoole_error_log(SW_LOG_WARNING, SW_ERROR_SERVER_TOO_MANY_SOCKET, "Too many connections [now: %d].", new_fd);
>             close(new_fd);
>             return SW_OK;
>         }
> 
>         if (serv->factory_mode == SW_MODE_SINGLE)
>         {
>             reactor_id = 0;
>         }
>         else
>         {
>             reactor_id = new_fd % serv->reactor_num;
>         }
> 
>         //add to connection_list
>         swConnection *conn = swServer_connection_new(serv, listen_host, new_fd, event->fd, reactor_id);
>         memcpy(&conn->info.addr, &client_addr, sizeof(client_addr));
>         sub_reactor = &serv->reactor_threads[reactor_id].reactor;
>         conn->socket_type = listen_host->type;
> 
> #ifdef SW_USE_OPENSSL
>         if (listen_host->ssl)
>         {
>             if (swSSL_create(conn, listen_host->ssl_context, 0) < 0)
>             {
>                 bzero(conn, sizeof(swConnection));
>                 close(new_fd);
>                 return SW_OK;
>             }
>         }
>         else
>         {
>             conn->ssl = NULL;
>         }
> #endif
>         /*
>          * [!!!] new_connection function must before reactor->add
>          */
>         if (serv->factory_mode == SW_MODE_PROCESS)
>         {
>             int events;
>             if (serv->onConnect && !listen_host->ssl)
>             {
>                 conn->connect_notify = 1;
>                 events = SW_EVENT_WRITE;
>             }
>             else
>             {
>                 events = SW_EVENT_READ;
>             }
>             ret = sub_reactor->add(sub_reactor, new_fd, SW_FD_TCP | events);
>         }
>         else
>         {
>             ret = sub_reactor->add(sub_reactor, new_fd, SW_FD_TCP | SW_EVENT_READ);
>             if (ret >= 0 && serv->onConnect && !listen_host->ssl)
>             {
>                 swServer_connection_ready(serv, new_fd, reactor->id);
>             }
>         }
> 
>         if (ret < 0)
>         {
>             bzero(conn, sizeof(swConnection));
>             close(new_fd);
>             return SW_OK;
>         }
> 
> #ifdef SW_ACCEPT_AGAIN
>         continue;
> #else
>         break;
> #endif
>     }
>     return SW_OK;
> }
74d221
< 
80d226
< 
86d231
< 
103c248
<         if (serv->onTask == NULL || serv->onFinish == NULL)
---
>         if (serv->onTask == NULL)
105c250,255
<             swWarn("onTask or onFinsh is null");
---
>             swWarn("onTask is null");
>             return SW_ERR;
>         }
>         if (serv->onFinish == NULL)
>         {
>             swWarn("onFinish is null");
109d258
< 
111,119c260,272
<     serv->reactor_num  = (serv->reactor_num > SW_CPU_NUM * SW_MAX_THREAD_NCPU)? 
<                             (SW_CPU_NUM * SW_MAX_THREAD_NCPU):serv->reactor_num;
<    
<     serv->worker_num  = (serv->worker_num > SW_CPU_NUM * SW_MAX_THREAD_NCPU)? 
<                             (SW_CPU_NUM * SW_MAX_THREAD_NCPU):serv->worker_num;
< 
<     serv->reactor_num = (serv->worker_num < serv->reactor_num)? serv->worker_num:
<                                 serv->reactor_num;
<                                 
---
>     if (serv->reactor_num > SW_CPU_NUM * SW_MAX_THREAD_NCPU)
>     {
>         serv->reactor_num = SW_CPU_NUM * SW_MAX_THREAD_NCPU;
>     }
>     if (serv->worker_num > SW_CPU_NUM * SW_MAX_WORKER_NCPU)
>     {
>         swWarn("serv->worker_num > %d, Too many processes, the system will be slow", SW_CPU_NUM * SW_MAX_WORKER_NCPU);
>         serv->worker_num = SW_CPU_NUM * SW_MAX_WORKER_NCPU;
>     }
>     if (serv->worker_num < serv->reactor_num)
>     {
>         serv->reactor_num = serv->worker_num;
>     }
125d277
< 
131d282
< 
136c287,291
< static void swServer_signal_init(void)
---
> /**
>  * proxy模式
>  * 在单独的n个线程中接受维持TCP连接
>  */
> static int swServer_start_proxy(swServer *serv)
138,151c293,294
<     swSignal_add(SIGPIPE, NULL);
<     swSignal_add(SIGHUP, NULL);
<     swSignal_add(SIGCHLD, swServer_signal_hanlder);
<     swSignal_add(SIGUSR1, swServer_signal_hanlder);
<     swSignal_add(SIGUSR2, swServer_signal_hanlder);
<     swSignal_add(SIGTERM, swServer_signal_hanlder);
< #ifdef SIGRTMIN
<     swSignal_add(SIGRTMIN, swServer_signal_hanlder);
< #endif
<     swSignal_add(SIGALRM, swSystemTimer_signal_handler);
<     //for test
<     swSignal_add(SIGVTALRM, swServer_signal_hanlder);
<     swServer_set_minfd(SwooleG.serv, SwooleG.signal_fd);
< }
---
>     int ret;
>     swReactor *main_reactor = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swReactor));
153,156c296,297
< static void swServer_signal_hanlder(int sig)
< {
<     int status;
<     switch (sig)
---
>     ret = swReactor_create(main_reactor, SW_REACTOR_MINEVENTS);
>     if (ret < 0)
158,212c299,301
<     case SIGTERM:
<         if (SwooleG.main_reactor)
<         {
<             SwooleG.main_reactor->running = 0;
<         }
<         else
<         {
<             SwooleG.running = 0;
<         }
<         swNotice("Server is shutdown now.");
<         break;
<     case SIGALRM:
<         swSystemTimer_signal_handler(SIGALRM);
<         break;
<     case SIGCHLD:
<     	/// 需要看看在信号处理函数中 调用swWaitpid；若有问题还是要调用原始接口swWaitpid
<         if (swWaitpid(SwooleGS->manager_pid, &status, WNOHANG) > 0 && SwooleG.running > 0)
<         {
<             swWarn("Fatal Error: manager process exit. status=%d, signal=%d.", WEXITSTATUS(status), WTERMSIG(status));
<         }
<         break;
<         /**
<          * for test
<          */
<     case SIGVTALRM:
<         swWarn("SIGVTALRM coming");
<         break;
<         /**
<          * proxy the restart signal
<          */
<     case SIGUSR1:
<     case SIGUSR2:
<         if (SwooleG.serv->factory_mode == SW_MODE_SINGLE)
<         {
<             SwooleGS->event_workers.reloading = 1;
<             SwooleGS->event_workers.reload_flag = 0;
<         }
<         else
<         {
<         	/// 需要看看在信号处理函数中 调用swKill；若有问题还是要调用原始接口kill
<             swKill(SwooleGS->manager_pid, sig);
<         }
<         break;
<     default:
< #ifdef SIGRTMIN
<         if (sig == SIGRTMIN)
<         {
<             int index;
<             swWorker *worker = NULL;
<             for (index = 0; index < SwooleG.serv->worker_num + SwooleG.task_worker_num +
<             									SwooleG.serv->user_worker_num; index++)
<             {
<                 worker = swServer_get_worker(SwooleG.serv, index);
<                 swKill(worker->pid, SIGRTMIN);
<             }
---
>         swWarn("Reactor create failed");
>         return SW_ERR;
>     }
214,217c303,306
<             if (SwooleG.serv->factory_mode == SW_MODE_PROCESS)
<             {
<                 swKill(SwooleGS->manager_pid, SIGRTMIN);
<             }
---
>     main_reactor->thread = 1;
>     main_reactor->socket_list = serv->connection_list;    
>     main_reactor->disable_accept = 0;
>     main_reactor->enable_accept = swServer_enable_accept;
219,220c308,312
<             swServer_reopen_log_file(SwooleG.serv);
<         }
---
> #ifdef HAVE_SIGNALFD
>     if (SwooleG.use_signalfd)
>     {
>         swSignalfd_setup(main_reactor);
>     }
222c314,322
<         break;
---
> 
>     /**
>      * create reactor thread
>      */
>     ret = swReactorThread_start(serv, main_reactor);
>     if (ret < 0)
>     {
>         swWarn("ReactorThread start failed");
>         return SW_ERR;
224d323
< }
226,232c325,332
< /**
<  * only tcp
<  */
< static int swServer_send1(swServer *serv, swSendData *resp)
< {
<     return swWrite(resp->info.fd, resp->data, resp->info.len);
< }
---
>     /**
>      * heartbeat thread
>      */
>     if (serv->heartbeat_check_interval >= 1 && serv->heartbeat_check_interval <= serv->heartbeat_idle_time)
>     {
>         swTrace("hb timer start, time: %d live time:%d", serv->heartbeat_check_interval, serv->heartbeat_idle_time);
>         swHeartbeatThread_start(serv);
>     }
234,240c334,345
< /**
<  * for udp + tcp
<  */
< static int swServer_send2(swServer *serv, swSendData *resp)
< {
<     int ret = (resp->info.from_id >= serv->reactor_num)? swServer_udp_send(serv, resp):
<     								swWrite(resp->info.fd, resp->data, resp->info.len);
---
>     /**
>      * master thread loop
>      */
>     SwooleTG.type = SW_THREAD_MASTER;
>     SwooleTG.factory_target_worker = -1;
>     SwooleTG.factory_lock_target = 0;
>     SwooleTG.id = 0;
>     SwooleTG.update_time = 1;
> 
>     SwooleG.main_reactor = main_reactor;
>     SwooleG.pid = getpid();
>     SwooleG.process_type = SW_PROCESS_MASTER;
242c347,354
<     if (ret < 0)
---
>     /**
>      * set a special id
>      */
>     main_reactor->id = serv->reactor_num;
>     main_reactor->ptr = serv;
>     main_reactor->setHandle(main_reactor, SW_FD_LISTEN, swServer_master_onAccept);
> 
>     if (serv->onStart != NULL)
244c356
<         swWarn("[Writer]sendto client failed. errno=%d", errno);
---
>         serv->onStart(serv);
247c359,362
<     return ret;
---
>     struct timeval tmo;
>     tmo.tv_sec = 1; //for seconds timer
>     tmo.tv_usec = 0;
>     return main_reactor->wait(main_reactor, &tmo);
252c367
<     swListenPort *ls = NULL;
---
>     swListenPort *ls;
299,300c414,432
<     /// 设置cpu 亲和性
<     swoole_cpu_setAffinity(SwooleWG.id,serv);
---
> #ifdef HAVE_CPU_AFFINITY
>     if (serv->open_cpu_affinity)
>     {
>         cpu_set_t cpu_set;
>         CPU_ZERO(&cpu_set);
>         if (serv->cpu_affinity_available_num)
>         {
>             CPU_SET(serv->cpu_affinity_available[SwooleWG.id % serv->cpu_affinity_available_num], &cpu_set);
>         }
>         else
>         {
>             CPU_SET(SwooleWG.id % SW_CPU_NUM, &cpu_set);
>         }
>         if (sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set) < 0)
>         {
>             swSysError("sched_setaffinity() failed.");
>         }
>     }
> #endif
302,306c434,443
<     int buffer_input_size = (serv->listen_list->open_eof_check || 
<                                 serv->listen_list->open_length_check || 
<                                 serv->listen_list->open_http_protocol)? 
<                                 serv->listen_list->protocol.package_max_length:
<                                 SW_BUFFER_SIZE_BIG;
---
>     int i;
>     int buffer_input_size;
>     if (serv->listen_list->open_eof_check || serv->listen_list->open_length_check || serv->listen_list->open_http_protocol)
>     {
>         buffer_input_size = serv->listen_list->protocol.package_max_length;
>     }
>     else
>     {
>         buffer_input_size = SW_BUFFER_SIZE_BIG;
>     }
308,309c445,453
<     int buffer_num = (serv->factory_mode != SW_MODE_PROCESS)? 1:
<                     serv->reactor_num + serv->dgram_port_num;
---
>     int buffer_num;
>     if (serv->factory_mode != SW_MODE_PROCESS)
>     {
>         buffer_num = 1;
>     }
>     else
>     {
>         buffer_num = serv->reactor_num + serv->dgram_port_num;
>     }
312c456
<     if (!SwooleWG.buffer_input)
---
>     if (SwooleWG.buffer_input == NULL)
318,319c462
<     int index = 0;
<     for (index = 0; index < buffer_num; index++)
---
>     for (i = 0; i < buffer_num; i++)
321,322c464,465
<         SwooleWG.buffer_input[index] = swString_new(buffer_input_size);
<         if (!SwooleWG.buffer_input[index])
---
>         SwooleWG.buffer_input[i] = swString_new(buffer_input_size);
>         if (SwooleWG.buffer_input[i] == NULL)
345,405d487
< /**
<  * initializing server config, set default
<  */
< void swServer_init(swServer *serv)
< {
< 	bzero(serv, sizeof(swServer));
< 
<     swoole_init();
<     serv->factory_mode = SW_MODE_BASE;
< 
<     serv->reactor_num = SW_REACTOR_NUM > SW_REACTOR_MAX_THREAD ? SW_REACTOR_MAX_THREAD : SW_REACTOR_NUM;
< 
<     serv->dispatch_mode = SW_DISPATCH_FDMOD;
<     serv->ringbuffer_size = SW_QUEUE_SIZE;
< 
<     serv->timeout_sec = SW_REACTOR_TIMEO_SEC;
<     serv->timeout_usec = SW_REACTOR_TIMEO_USEC;  //300ms;
< 
<     serv->worker_num = SW_CPU_NUM;
<     serv->max_connection = SwooleG.max_sockets;
<     serv->max_request = 0;
< 
<     serv->http_parse_post = 1;
< 
<     //heartbeat check
<     serv->heartbeat_idle_time = SW_HEARTBEAT_IDLE;
<     serv->heartbeat_check_interval = SW_HEARTBEAT_CHECK;
< 
<     serv->buffer_input_size = SW_BUFFER_INPUT_SIZE;
<     serv->buffer_output_size = SW_BUFFER_OUTPUT_SIZE;
< 
<     serv->pipe_buffer_size = SW_PIPE_BUFFER_SIZE;
< 
<     SwooleG.serv = serv;
< }
< 
< int swServer_create(swServer *serv)
< {
<     if (SwooleG.main_reactor)
<     {
<         swoole_error_log(SW_LOG_ERROR, SW_ERROR_SERVER_MUST_CREATED_BEFORE_CLIENT, "The swoole_server must create before client");
<         return SW_ERR;
<     }
< 
<     SwooleG.factory = &serv->factory;
<     serv->factory.ptr = serv;
< 
< #ifdef SW_REACTOR_USE_SESSION
<     serv->session_list = sw_shm_calloc(SW_SESSION_LIST_SIZE, sizeof(swSession));
<     if (!serv->session_list)
<     {
<         swError("sw_shm_calloc(%ld) for session_list failed", SW_SESSION_LIST_SIZE * sizeof(swSession));
<         return SW_ERR;
<     }
< #endif
< 
<     return (serv->factory_mode == SW_MODE_SINGLE)? 
<                 swReactorProcess_create(serv):
<                 swReactorThread_create(serv); 
< }
< 
408c490,494
<     if (swServer_start_check(serv) < 0)
---
>     swFactory *factory = &serv->factory;
>     int ret;
> 
>     ret = swServer_start_check(serv);
>     if (ret < 0)
415c501
<         char path_buf[128] = {0};
---
>         char path_buf[128];
419d504
< 
425d509
< 
427,454c511,549
<     if (serv->daemonize){
< 		/**
< 			* redirect STDOUT to log file
< 		*/
<     	if (SwooleG.log_fd > STDOUT_FILENO)
< 		{
< 			swoole_redirect_stdout(SwooleG.log_fd);
< 		}
< 		/**
< 		 * redirect STDOUT_FILENO/STDERR_FILENO to /dev/null
< 		 */
< 		else
< 		{
< 			SwooleG.null_fd = open("/dev/null", O_WRONLY);
< 			if (SwooleG.null_fd > 0)
< 			{
< 				swoole_redirect_stdout(SwooleG.null_fd);
< 			}
< 			else
< 			{
< 				swoole_error_log(SW_LOG_ERROR, SW_ERROR_SYSTEM_CALL_FAIL, "open(/dev/null) failed. Error: %s[%d]", strerror(errno), errno);
< 			}
< 		}
< 
< 		if (swoole_daemon(0, 1) < 0)
< 		{
< 			return SW_ERR;
< 		}
---
>     if (serv->daemonize > 0)
>     {
>         /**
>          * redirect STDOUT to log file
>          */
>         if (SwooleG.log_fd > STDOUT_FILENO)
>         {
>             if (dup2(SwooleG.log_fd, STDOUT_FILENO) < 0)
>             {
>                 swoole_error_log(SW_LOG_ERROR, SW_ERROR_SYSTEM_CALL_FAIL, "dup2() failed. Error: %s[%d]", strerror(errno), errno);
>             }
>         }
>         /**
>          * redirect STDOUT_FILENO/STDERR_FILENO to /dev/null
>          */
>         else
>         {
>             SwooleG.null_fd = open("/dev/null", O_WRONLY);
>             if (SwooleG.null_fd > 0)
>             {
>                 if (dup2(SwooleG.null_fd, STDOUT_FILENO) < 0)
>                 {
>                     swoole_error_log(SW_LOG_ERROR, SW_ERROR_SYSTEM_CALL_FAIL, "dup2(STDOUT_FILENO) failed. Error: %s[%d]", strerror(errno), errno);
>                 }
>                 if (dup2(SwooleG.null_fd, STDERR_FILENO) < 0)
>                 {
>                     swoole_error_log(SW_LOG_ERROR, SW_ERROR_SYSTEM_CALL_FAIL, "dup2(STDERR_FILENO) failed. Error: %s[%d]", strerror(errno), errno);
>                 }
>             }
>             else
>             {
>                 swoole_error_log(SW_LOG_ERROR, SW_ERROR_SYSTEM_CALL_FAIL, "open(/dev/null) failed. Error: %s[%d]", strerror(errno), errno);
>             }
>         }
> 
>         if (daemon(0, 1) < 0)
>         {
>             return SW_ERR;
>         }
462,464c557,565
<     serv->send = (serv->have_udp_sock == 1 && serv->factory_mode != SW_MODE_PROCESS)?
<                     swServer_send2:swServer_send1;
<     
---
>     if (serv->have_udp_sock == 1 && serv->factory_mode != SW_MODE_PROCESS)
>     {
>         serv->send = swServer_send2;
>     }
>     else
>     {
>         serv->send = swServer_send1;
>     }
> 
466c567
<     if (!serv->workers)
---
>     if (serv->workers == NULL)
479,480c580,581
<     int index = 0;
<     for (index = 0; index < serv->worker_num; index++)
---
>     int i;
>     for (i = 0; i < serv->worker_num; i++)
482c583
<         SwooleGS->event_workers.workers[index].pool = &SwooleGS->event_workers;
---
>         SwooleGS->event_workers.workers[i].pool = &SwooleGS->event_workers;
486c587
<     for (index = 0; index < serv->reactor_num; index++)
---
>     for (i = 0; i < serv->reactor_num; i++)
503c604
<         for (index = 0; index < serv->worker_num; index++)
---
>         for (i = 0; i < serv->worker_num; i++)
505c606
<             if (swPipeNotify_auto(&SwooleG.task_notify[index], 1, 0))
---
>             if (swPipeNotify_auto(&SwooleG.task_notify[i], 1, 0))
517,518c618,619
<         swUserWorker_node *user_worker = NULL;
<         index = 0;
---
>         swUserWorker_node *user_worker;
>         i = 0;
521c622,623
<             user_worker->worker->id = serv->worker_num + SwooleG.task_worker_num + (index++);
---
>             user_worker->worker->id = serv->worker_num + SwooleG.task_worker_num + i;
>             i++;
526c628
<     swListenPort *ls = NULL;
---
>     swListenPort *ls;
529,532c631
<         if (swPort_set_option(ls) < 0)
<         {
<         	return SW_ERR;
<         }
---
>         swPort_set_option(ls);
534d632
< 
536,537c634
<     swFactory *factory = &serv->factory;
<     if (!factory || factory->start(factory) < 0)
---
>     if (factory->start(factory) < 0)
541d637
< 
545,547c641,648
<     int ret = (serv->factory_mode == SW_MODE_SINGLE)?
<                 swReactorProcess_start(serv):swReactorThread_start(serv);  
< 
---
>     if (serv->factory_mode == SW_MODE_SINGLE)
>     {
>         ret = swReactorProcess_start(serv);
>     }
>     else
>     {
>         ret = swServer_start_proxy(serv);
>     }
552d652
< 
557c657,660
< void swServer_reopen_log_file(swServer *serv)
---
> /**
>  * initializing server config, set default
>  */
> void swServer_init(swServer *serv)
559,575c662,663
<     if (!SwooleG.log_file)
<     {
<         return;
<     }
<     /**
<      * reopen log file
<      */
<     close(SwooleG.log_fd);
<     swLog_init(SwooleG.log_file);
<     /**
<      * redirect STDOUT & STDERR to log file
<      */
<     if (serv->daemonize)
<     {
<         swoole_redirect_stdout(SwooleG.log_fd);
<     }
< }
---
>     swoole_init();
>     bzero(serv, sizeof(swServer));
577,583c665
< swWorker* swServer_get_worker(swServer *serv, uint16_t worker_id)
< {
<     //Event Worker
<     if (worker_id < serv->worker_num)
<     {
<         return &(SwooleGS->event_workers.workers[worker_id]);
<     }
---
>     serv->factory_mode = SW_MODE_BASE;
585,590c667
<     //Task Worker
<     uint16_t task_worker_max = SwooleG.task_worker_num + serv->worker_num;
<     if (worker_id < task_worker_max)
<     {
<         return &(SwooleGS->task_workers.workers[worker_id - serv->worker_num]);
<     }
---
>     serv->reactor_num = SW_REACTOR_NUM > SW_REACTOR_MAX_THREAD ? SW_REACTOR_MAX_THREAD : SW_REACTOR_NUM;
592,597c669,683
<     //User Worker
<     uint16_t user_worker_max = task_worker_max + serv->user_worker_num;
<     if (worker_id < user_worker_max)
<     {
<         return serv->user_workers[worker_id - task_worker_max];
<     }
---
>     serv->dispatch_mode = SW_DISPATCH_FDMOD;
>     serv->ringbuffer_size = SW_QUEUE_SIZE;
> 
>     serv->timeout_sec = SW_REACTOR_TIMEO_SEC;
>     serv->timeout_usec = SW_REACTOR_TIMEO_USEC;  //300ms;
> 
>     serv->worker_num = SW_CPU_NUM;
>     serv->max_connection = SwooleG.max_sockets;
>     serv->max_request = 0;
> 
>     serv->http_parse_post = 1;
> 
>     //heartbeat check
>     serv->heartbeat_idle_time = SW_HEARTBEAT_IDLE;
>     serv->heartbeat_check_interval = SW_HEARTBEAT_CHECK;
599,601c685,690
<     //Unkown worker_id
<     swWarn("worker#%d is not exist.", worker_id);
<     return NULL;
---
>     serv->buffer_input_size = SW_BUFFER_INPUT_SIZE;
>     serv->buffer_output_size = SW_BUFFER_OUTPUT_SIZE;
> 
>     serv->pipe_buffer_size = SW_PIPE_BUFFER_SIZE;
> 
>     SwooleG.serv = serv;
604c693
< uint32_t swServer_worker_schedule(swServer *serv, uint32_t schedule_key)
---
> int swServer_create(swServer *serv)
606,609c695
<     uint32_t target_worker_id = 0;
< 
<     //polling mode or fd touch access to hash
<     if (serv->dispatch_mode == SW_DISPATCH_ROUND || serv->dispatch_mode == SW_DISPATCH_FDMOD)
---
>     if (SwooleG.main_reactor)
611,613c697,698
<         target_worker_id = (serv->dispatch_mode == SW_DISPATCH_ROUND )?
<         							sw_atomic_fetch_add(&serv->worker_round_id, 1) % serv->worker_num:
<         							schedule_key % serv->worker_num;
---
>         swoole_error_log(SW_LOG_ERROR, SW_ERROR_SERVER_MUST_CREATED_BEFORE_CLIENT, "The swoole_server must create before client");
>         return SW_ERR;
615,616c700,707
<     //Using the IP touch access to hash
<     else if (serv->dispatch_mode == SW_DISPATCH_IPMOD)
---
> 
>     SwooleG.factory = &serv->factory;
> 
>     serv->factory.ptr = serv;
> 
> #ifdef SW_REACTOR_USE_SESSION
>     serv->session_list = sw_shm_calloc(SW_SESSION_LIST_SIZE, sizeof(swSession));
>     if (serv->session_list == NULL)
618,634c709,710
<         swConnection *conn = swServer_connection_get(serv, schedule_key);
<         //UDP or tcp ipv4
<         if (!conn || SW_SOCK_TCP == conn->socket_type)
<         {
<             target_worker_id = (!conn)? schedule_key % serv->worker_num :
<             				conn->info.addr.inet_v4.sin_addr.s_addr % serv->worker_num;
<         }
<         //IPv6
<         else
<         {
< #ifdef HAVE_KQUEUE
<             uint32_t ipv6_last_int = *(((uint32_t *) &conn->info.addr.inet_v6.sin6_addr) + 3);
<             target_worker_id = ipv6_last_int % serv->worker_num;
< #else
<             target_worker_id = conn->info.addr.inet_v6.sin6_addr.s6_addr32[3] % serv->worker_num;
< #endif
<         }
---
>         swError("sw_shm_calloc(%ld) for session_list failed", SW_SESSION_LIST_SIZE * sizeof(swSession));
>         return SW_ERR;
636c712,714
<     else if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)
---
> #endif
> 
>     if (serv->factory_mode == SW_MODE_SINGLE)
638,640c716
<         swConnection *conn = swServer_connection_get(serv, schedule_key);
<         target_worker_id = (!conn)? (schedule_key % serv->worker_num):
<         					((conn->uid)? conn->uid % serv->worker_num:schedule_key % serv->worker_num);
---
>         return swReactorProcess_create(serv);
642d717
<     //Preemptive distribution
645,666c720
<         int index = 0;
<         for (index = 0; index < serv->worker_num + 1; index++)
<         {
<             target_worker_id = sw_atomic_fetch_add(&serv->worker_round_id, 1) % serv->worker_num;
<             if (serv->workers[target_worker_id].status == SW_WORKER_IDLE)
<             {
<                 break;
<             }
<         }
<         //swWarn("schedule=%d|round=%d\n", target_worker_id, *round);
<     }
< 
<     /// target worker id 校正
<     int index = 0;
<     while (serv->workers[target_worker_id].deny_request) {
<         target_worker_id = (target_worker_id + 1) % serv->worker_num;
<     //    swWarn("target_work_id increased %d", target_worker_id);
<         if (++index > serv->worker_num) {
<             target_worker_id = 0;
<             //swWarn("target_work_id is null %d", target_worker_id);
<             break;
<         }
---
>         return swReactorThread_create(serv);
668,669d721
< 
<     return target_worker_id;
688d739
< 
697c748
<     
---
> 
739a791,798
> /**
>  * only tcp
>  */
> static int swServer_send1(swServer *serv, swSendData *resp)
> {
>     return swWrite(resp->info.fd, resp->data, resp->info.len);
> }
> 
820,875d878
< int swServer_tcp_deny_request(swServer *serv, long nWorkerId)
< {
<     swWarn("swServer_tcp_deny_request");
<     swEventData ev_data;
<     ev_data.info.fd = 0;
<     ev_data.info.worker_id = nWorkerId;
<     ev_data.info.type = SW_EVENT_DENY_REQUEST;
<     //copy data
<     memcpy(ev_data.data, "0", 1);
<     
<     ev_data.info.len = 1;
<     ev_data.info.from_fd = SW_RESPONSE_SMALL;
<     ev_data.info.from_id = 0;
<     int sendn = ev_data.info.len + sizeof(swDataHead);
<     
<     swWorker *worker = swServer_get_worker(serv, nWorkerId);
<     int ret = 0;
<     if (SwooleG.main_reactor)
<     {
<         ret = SwooleG.main_reactor->write(SwooleG.main_reactor, worker->pipe_worker, &ev_data, sendn);
<     }
<     else
<     {
<         ret = swSocket_write_blocking(worker->pipe_worker, &ev_data, sendn);
<     }
<     return ret;
< }
< 
< int swServer_tcp_deny_exit(swServer *serv, long nWorkerId)
< {
<     swTrace("swServer_tcp_deny_exit");
< 
<     swEventData ev_data;
<     ev_data.info.fd = 0;
<     ev_data.info.worker_id = nWorkerId;
<     ev_data.info.type = SW_EVENT_DENY_EXIT;
<     //copy data
<     memcpy(ev_data.data, "0", 1);
<     
<     ev_data.info.len = 1;
<     ev_data.info.from_fd = SW_RESPONSE_SMALL;
<     ev_data.info.from_id = 0;
<     int sendn = ev_data.info.len + sizeof(swDataHead);
<     
<     swWorker *worker = swServer_get_worker(serv, nWorkerId);
<     if (!worker){
<         return SW_ERR;
<     }
< 
<     int ret = (SwooleG.main_reactor)? 
<                 SwooleG.main_reactor->write(SwooleG.main_reactor, worker->pipe_worker, &ev_data, sendn):
<                 swSocket_write_blocking(worker->pipe_worker, &ev_data, sendn);   
< 
<     return ret;
< }
< 
889c892
<     char buffer[SW_BUFFER_SIZE] = {0};
---
>     char buffer[SW_BUFFER_SIZE];
927a931,967
> /**
>  * for udp + tcp
>  */
> static int swServer_send2(swServer *serv, swSendData *resp)
> {
>     int ret;
> 
>     //UDP
>     if (resp->info.from_id >= serv->reactor_num)
>     {
>         ret = swServer_udp_send(serv, resp);
>     }
>     else
>     {
>         ret = swWrite(resp->info.fd, resp->data, resp->info.len);
>     }
>     if (ret < 0)
>     {
>         swWarn("[Writer]sendto client failed. errno=%d", errno);
>     }
>     return ret;
> }
> 
> void swServer_signal_init(void)
> {
>     swSignal_add(SIGPIPE, NULL);
>     swSignal_add(SIGHUP, NULL);
>     swSignal_add(SIGCHLD, swServer_signal_hanlder);
>     swSignal_add(SIGUSR1, swServer_signal_hanlder);
>     swSignal_add(SIGUSR2, swServer_signal_hanlder);
>     swSignal_add(SIGTERM, swServer_signal_hanlder);
>     swSignal_add(SIGALRM, swSystemTimer_signal_handler);
>     //for test
>     swSignal_add(SIGVTALRM, swServer_signal_hanlder);
>     swServer_set_minfd(SwooleG.serv, SwooleG.signal_fd);
> }
> 
942c982
<         serv->user_worker_map = swHashMap_create(SW_HASHMAP_INIT_BUCKET_N, NULL);
---
>         serv->user_worker_map = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, NULL);
993c1033
<     int sock = swSocket_create(ls->type,NULL,NULL);
---
>     int sock = swSocket_create(ls->type);
997,999d1036
< 
< create_error:
<         SwooleG.memory_pool->free(SwooleG.memory_pool,ls);
1005,1006c1042
<     	close(sock);
<         goto create_error;
---
>         return NULL;
1008d1043
< 
1012c1047
<         swSetNonBlock(sock,1);
---
>         swSetNonBlock(sock);
1059d1093
< 
1062a1097,1320
> static void swServer_signal_hanlder(int sig)
> {
>     int status;
>     switch (sig)
>     {
>     case SIGTERM:
>         if (SwooleG.main_reactor)
>         {
>             SwooleG.main_reactor->running = 0;
>         }
>         else
>         {
>             SwooleG.running = 0;
>         }
>         swNotice("Server is shutdown now.");
>         break;
>     case SIGALRM:
>         swSystemTimer_signal_handler(SIGALRM);
>         break;
>     case SIGCHLD:
>         if (waitpid(SwooleGS->manager_pid, &status, WNOHANG) >= 0 && SwooleG.running > 0)
>         {
>             swWarn("Fatal Error: manager process exit. status=%d, signal=%d.", WEXITSTATUS(status), WTERMSIG(status));
>         }
>         break;
>         /**
>          * for test
>          */
>     case SIGVTALRM:
>         swWarn("SIGVTALRM coming");
>         break;
>         /**
>          * proxy the restart signal
>          */
>     case SIGUSR1:
>     case SIGUSR2:
>         if (SwooleG.serv->factory_mode == SW_MODE_SINGLE)
>         {
>             SwooleGS->event_workers.reloading = 1;
>             SwooleGS->event_workers.reload_flag = 0;
>         }
>         else
>         {
>             kill(SwooleGS->manager_pid, sig);
>         }
>         break;
>     default:
>         break;
>     }
> }
> 
> static void swHeartbeatThread_start(swServer *serv)
> {
>     swThreadParam *param;
>     pthread_t thread_id;
>     param = SwooleG.memory_pool->alloc(SwooleG.memory_pool, sizeof(swThreadParam));
>     if (param == NULL)
>     {
>         swError("heartbeat_param malloc fail\n");
>         return;
>     }
> 
>     param->object = serv;
>     param->pti = 0;
> 
>     if (pthread_create(&thread_id, NULL, (void * (*)(void *)) swHeartbeatThread_loop, (void *) param) < 0)
>     {
>         swWarn("pthread_create[hbcheck] fail");
>     }
>     SwooleG.heartbeat_pidt = thread_id;
> }
> 
> static void swHeartbeatThread_loop(swThreadParam *param)
> {
>     swSignal_none();
> 
>     swServer *serv = param->object;
>     swDataHead notify_ev;
>     swConnection *conn;
>     swReactor *reactor;
> 
>     int fd;
>     int serv_max_fd;
>     int serv_min_fd;
>     int checktime;
> 
>     SwooleTG.type = SW_THREAD_HEARTBEAT;
> 
>     bzero(&notify_ev, sizeof(notify_ev));
>     notify_ev.type = SW_EVENT_CLOSE;
> 
>     while (SwooleG.running)
>     {
>         serv_max_fd = swServer_get_maxfd(serv);
>         serv_min_fd = swServer_get_minfd(serv);
> 
>         checktime = (int) time(NULL) - serv->heartbeat_idle_time;
> 
>         //遍历到最大fd
>         for (fd = serv_min_fd; fd <= serv_max_fd; fd++)
>         {
>             swTrace("check fd=%d", fd);
>             conn = swServer_connection_get(serv, fd);
> 
>             if (conn != NULL && conn->active == 1 && conn->fdtype == SW_FD_TCP)
>             {
>                 if (conn->protect || conn->last_time > checktime)
>                 {
>                     continue;
>                 }
> 
>                 notify_ev.fd = fd;
>                 notify_ev.from_id = conn->from_id;
> 
>                 conn->close_force = 1;
>                 conn->close_notify = 1;
>                 conn->close_wait = 1;
> 
>                 if (serv->factory_mode != SW_MODE_PROCESS)
>                 {
>                     if (serv->factory_mode == SW_MODE_SINGLE)
>                     {
>                         reactor = SwooleG.main_reactor;
>                     }
>                     else
>                     {
>                         reactor = &serv->reactor_threads[conn->from_id].reactor;
>                     }
>                 }
>                 else
>                 {
>                     reactor = &serv->reactor_threads[conn->from_id].reactor;
>                 }
>                 //notify to reactor thread
>                 reactor->set(reactor, fd, SW_FD_TCP | SW_EVENT_WRITE);
>             }
>         }
>         sleep(serv->heartbeat_check_interval);
>     }
>     pthread_exit(0);
> }
> 
> /**
>  * new connection
>  */
> static swConnection* swServer_connection_new(swServer *serv, swListenPort *ls, int fd, int from_fd, int reactor_id)
> {
>     swConnection* connection = NULL;
> 
>     SwooleStats->accept_count++;
>     sw_atomic_fetch_add(&SwooleStats->connection_num, 1);
> 
>     if (fd > swServer_get_maxfd(serv))
>     {
>         swServer_set_maxfd(serv, fd);
>     }
> 
>     connection = &(serv->connection_list[fd]);
>     bzero(connection, sizeof(swConnection));
> 
>     //TCP Nodelay
>     if (ls->open_tcp_nodelay)
>     {
>         int sockopt = 1;
>         if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &sockopt, sizeof(sockopt)) < 0)
>         {
>             swSysError("setsockopt(TCP_NODELAY) failed.");
>         }
>         connection->tcp_nodelay = 1;
>     }
> 
> #ifdef HAVE_TCP_NOPUSH
>     //TCP NOPUSH
>     if (ls->open_tcp_nopush)
>     {
>         connection->tcp_nopush = 1;
>     }
> #endif
> 
>     connection->fd = fd;
>     connection->from_id = serv->factory_mode == SW_MODE_SINGLE ? SwooleWG.id : reactor_id;
>     connection->from_fd = from_fd;
>     connection->connect_time = SwooleGS->now;
>     connection->last_time = SwooleGS->now;
>     connection->active = 1;
> 
> #ifdef SW_REACTOR_SYNC_SEND
>     if (serv->factory_mode != SW_MODE_THREAD && !ls->ssl)
>     {
>         connection->direct_send = 1;
>     }
> #endif
> 
> #ifdef SW_REACTOR_USE_SESSION
>     uint32_t session_id = 1;
>     swSession *session;
>     sw_spinlock(&SwooleGS->spinlock);
>     int i;
>     //get session id
>     for (i = 0; i < serv->max_connection; i++)
>     {
>         session_id = SwooleGS->session_round++;
>         if (session_id == 0)
>         {
>             session_id = 1;
>             SwooleGS->session_round = 1;
>         }
>         session = swServer_get_session(serv, session_id);
>         //vacancy
>         if (session->fd == 0)
>         {
>             session->fd = fd;
>             session->id = session_id;
>             session->reactor_id = connection->from_id;
>             break;
>         }
>     }
>     sw_spinlock_release(&SwooleGS->spinlock);
>     connection->session_id = session_id;
> #endif
> 
>     return connection;
> }
> 
1081a1340,1343
> static void (*onConnect_callback)(swServer *, int, int);
> static int (*onReceive_callback)(swServer *, char *, int, int, int);
> static void (*onClose_callback)(swServer *, int, int);
> 
1113c1375
< }
\ No newline at end of file
---
> }
Only in ./zan-extension/src/network: Socket.c
diff -r ./zan-extension/src/network/TaskWorker.c ../swoole-1.8.5-stable/src/network/TaskWorker.c
17,22c17,18
< 
< #include "swServer.h"
< #include "swWork.h"
< #include "swSignal.h"
< #include "swBaseOperator.h"
< 
---
> #include "swoole.h"
> #include "Server.h"
57c53
<     int n = 0;
---
>     int n;
124,126d119
< #ifdef SIGRTMIN
<     swSignal_set(SIGRTMIN, swWorker_signal_handler, 1, 0);
< #endif
156c149
< 
---
>     swEventData buf;
166,167c159
<     int ret = 0;
<     swEventData buf;
---
>     int ret;
234c226
<             if (ret < 0 && errno == EAGAIN)
---
>             if (errno == EAGAIN)
Only in ../swoole-1.8.5-stable/src/network: ThreadPool.c
Only in ../swoole-1.8.5-stable/src/network: Timer.c
diff -r ./zan-extension/src/network/Worker.c ../swoole-1.8.5-stable/src/network/Worker.c
18,20c18
< #include "swSignal.h"
< #include "swServer.h"
< #include "swWork.h"
---
> #include "Server.h"
32,35d29
< 	if (!worker){
< 		return SW_ERR;
< 	}
< 
66,68d59
< #ifdef SIGRTMIN
<     swSignal_set(SIGRTMIN, swWorker_signal_handler, 1, 0);
< #endif
76d66
<         swWarn("signal SIGTERM coming");
87d76
<         swWarn("signal SIGALRM coming");
94c83
<         swWarn("signal SIGVTALRM coming");
---
>         swWarn("SIGVTALRM coming");
97d85
<         swWarn("signal SIGUSR1 coming");
127c115
<         break;
---
>         break;    
129d116
<         swWarn("signal SIGUSR2 coming.");
132,141d118
< #ifdef SIGRTMIN
<         if (signo == SIGRTMIN)
<         {
<             swServer_reopen_log_file(SwooleG.serv);
<         }
<         else
< #endif
<         {
<         	swWarn("recv other signal: %d.", signo);
<         }
192c169
<     swDgramPacket *header = NULL;
---
>     swDgramPacket *header;
195c172
<     swConnection *conn = NULL;
---
>     swConnection *conn;
325c302
<     swWorker *worker = NULL;
---
>     swWorker *worker;
327c304,311
<     SwooleG.process_type = (SwooleWG.id >= serv->worker_num)? SW_PROCESS_TASKWORKER:SW_PROCESS_WORKER;
---
>     if (SwooleWG.id >= serv->worker_num)
>     {
>         SwooleG.process_type = SW_PROCESS_TASKWORKER;
>     }
>     else
>     {
>         SwooleG.process_type = SW_PROCESS_WORKER;
>     }
328a313
>     int is_root = !geteuid();
331c316,317
<     if (!geteuid())
---
> 
>     if (is_root)
379,380c365,366
<     int index = 0;
<     for (index = 0; index < serv->worker_num + SwooleG.task_worker_num; index++)
---
>     int i;
>     for (i = 0; i < serv->worker_num + SwooleG.task_worker_num; i++)
382,383c368,369
<         worker = swServer_get_worker(serv, index);
<         if (SwooleWG.id == index)
---
>         worker = swServer_get_worker(serv, i);
>         if (SwooleWG.id == i)
393c379
<             swSetNonBlock(worker->pipe_master,1);
---
>             swSetNonBlock(worker->pipe_master);
414a401
>     int i;
416,418c403,405
<     swWorker *worker = NULL;
<     int index = 0;
<     for (index = 0; index < serv->worker_num + SwooleG.task_worker_num; index++)
---
>     swWorker *worker;
> 
>     for (i = 0; i < serv->worker_num + SwooleG.task_worker_num; i++)
420c407
<         worker = swServer_get_worker(serv, index);
---
>         worker = swServer_get_worker(serv, i);
457c444,450
<     if (swReactor_init(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) < 0)
---
>     if (SwooleG.main_reactor == NULL)
>     {
>         swError("[Worker] malloc for reactor failed.");
>         return SW_ERR;
>     }
> 
>     if (swReactor_create(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) < 0)
463a457
> 
466c460
<     swSetNonBlock(pipe_worker,1);
---
>     swSetNonBlock(pipe_worker);
475,477c469,471
<     int index = 0;
<     swConnection *pipe_socket = NULL;
<     for (index = 0; index < serv->worker_num + SwooleG.task_worker_num; index++)
---
>     int i;
>     swConnection *pipe_socket;
>     for (i = 0; i < serv->worker_num + SwooleG.task_worker_num; i++)
479c473
<         worker = swServer_get_worker(serv, index);
---
>         worker = swServer_get_worker(serv, i);
507a502
>     int ret;
521c516
<     int ret = -1;
---
> 
530d524
< 
542c536,538
<     int ret = 0;
---
>     int ret;
> 
>     read_from_pipe:
544d539
< read_from_pipe:
572c567,577
<     int pipefd = (flag & SW_PIPE_MASTER)? dst_worker->pipe_master:dst_worker->pipe_worker;
---
>     int pipefd, ret;
> 
>     if (flag & SW_PIPE_MASTER)
>     {
>         pipefd = dst_worker->pipe_master;
>     }
>     else
>     {
>         pipefd = dst_worker->pipe_worker;
>     }
> 
588d592
<     int ret = 0;
Only in ./zan-extension/src/os: AsyncIO.c
Only in ../swoole-1.8.5-stable/src/os: base.c
Only in ../swoole-1.8.5-stable/src/os: dl.c
diff -r ./zan-extension/src/os/gcc_aio.c ../swoole-1.8.5-stable/src/os/gcc_aio.c
17c17,18
< 
---
> #include "swoole.h"
> #include "async.h"
21,22d21
< #include "swoole.h"
< #include "swAsyncIO.h"
127d125
< 
128a127
> 
152d150
< 
185c183
<     if (aio_write(&aiocb->aiocb) < 0)
---
>     if (aio_write(&aiocb->aiocb) == -1)
190d187
< 
diff -r ./zan-extension/src/os/linux_aio.c ../swoole-1.8.5-stable/src/os/linux_aio.c
16a17,18
> #include "swoole.h"
> #include "async.h"
20,22d21
< #include "swoole.h"
< #include "swAsyncIO.h"
< 
106,113c105
<                 if ((int) events[i].res < 0){
<                 	aio_ev.error = abs((int) events[i].res);
<                 	aio_ev.ret = -1;
<                 }
<                 else{
<                 	aio_ev.ret = (int) events[i].res;
<                 }
< 
---
>                 aio_ev.ret = (int) events[i].res;
119d110
<                 aio_ev.task_id = aiocb->aio_reqprio;
132d122
< 	SwooleG.main_reactor->del(SwooleG.main_reactor,swoole_aio_eventfd);
134d123
< 
151d139
<     iocbp.aio_reqprio = SwooleAIO.current_id++;
158c146
<         return iocbp.aio_reqprio;
---
>         return SW_OK;
182d169
<     iocbp->aio_reqprio = SwooleAIO.current_id++;
189c176
<         return iocbp->aio_reqprio;
---
>         return SW_OK;
Only in ../swoole-1.8.5-stable/src/os: msg_queue.c
Only in ../swoole-1.8.5-stable/src/os: sendfile.c
Only in ../swoole-1.8.5-stable/src/os: signal.c
Only in ../swoole-1.8.5-stable/src/os: timer.c
Only in ./zan-extension/src/pipe: Channel.c
Only in ./zan-extension/src/pipe: Msgqueue.c
diff -r ./zan-extension/src/pipe/PipeBase.c ../swoole-1.8.5-stable/src/pipe/PipeBase.c
17,18c17
< #include "swLog.h"
< #include "swPipe.h"
---
> #include "swoole.h"
22a22
> static int swPipeBase_close(swPipe *p);
31,34c31
< 	if (!p){
< 		return SW_ERR;
< 	}
< 
---
>     int ret;
38c35
<         return SW_ERR;
---
>         return -1;
40,41c37,39
< 
<     if (pipe(object->pipes) < 0)
---
>     p->blocking = blocking;
>     ret = pipe(object->pipes);
>     if (ret < 0)
43d40
<     	sw_free(object);
45c42
<         return SW_ERR;
---
>         return -1;
47,67c44,56
< 
< 	swSetNonBlock(object->pipes[0],!blocking);
< 	swSetNonBlock(object->pipes[1],!blocking);
< 	p->blocking = blocking;
< 	p->timeout = -1;
< 	p->object = object;
< 	p->read = swPipeBase_read;
< 	p->write = swPipeBase_write;
< 	p->getFd = swPipeBase_getFd;
< 	p->close = swPipeBase_close;
< 
<     return SW_OK;
< }
< 
< int swPipeBase_close(swPipe *p)
< {
<     swPipeBase *this = p->object;
<     int ret1 = close(this->pipes[0]);
<     int ret2 = close(this->pipes[1]);
<     sw_free(this);
<     return 0 - ret1 - ret2;
---
>     else
>     {
>         //Nonblock
>         swSetNonBlock(object->pipes[0]);
>         swSetNonBlock(object->pipes[1]);
>         p->timeout = -1;
>         p->object = object;
>         p->read = swPipeBase_read;
>         p->write = swPipeBase_write;
>         p->getFd = swPipeBase_getFd;
>         p->close = swPipeBase_close;
>     }
>     return 0;
73c62
<     if (p->blocking && p->timeout > 0 && swSocket_wait(object->pipes[0], p->timeout * 1000, SW_EVENT_READ) < 0)
---
>     if (p->blocking == 1 && p->timeout > 0)
75c64,67
<         return SW_ERR;
---
>         if (swSocket_wait(object->pipes[0], p->timeout * 1000, SW_EVENT_READ) < 0)
>         {
>             return SW_ERR;
>         }
77d68
< 
92a84,92
> static int swPipeBase_close(swPipe *p)
> {
>     int ret1, ret2;
>     swPipeBase *this = p->object;
>     ret1 = close(this->pipes[0]);
>     ret2 = close(this->pipes[1]);
>     sw_free(this);
>     return 0 - ret1 - ret2;
> }
diff -r ./zan-extension/src/pipe/PipeEventfd.c ../swoole-1.8.5-stable/src/pipe/PipeEventfd.c
17,18d16
< 
< 
20,23d17
< #include "swPipe.h"
< #include "swLog.h"
< #include "swMemory/memoryPool.h"
< 
30a25
> static int swPipeEventfd_close(swPipe *p);
38a34,35
>     int efd;
>     int flag = 0;
42c39
<         return SW_ERR;
---
>         return -1;
45,46c42,44
<     int flag = EFD_NONBLOCK;
<     if (blocking)
---
>     flag = EFD_NONBLOCK;
> 
>     if (blocking == 1)
48,49c46,54
<     	p->timeout = (timeout > 0)? -1:timeout;
<     	flag = (timeout > 0)? 0:flag;
---
>         if (timeout > 0)
>         {
>             flag = 0;
>             p->timeout = -1;
>         }
>         else
>         {
>             p->timeout = timeout;
>         }
53c58,61
<     flag |= (semaphore == 1)? EFD_SEMAPHORE:1;
---
>     if (semaphore == 1)
>     {
>         flag |= EFD_SEMAPHORE;
>     }
56c64,65
<     int efd = eventfd(0, flag);
---
>     p->blocking = blocking;
>     efd = eventfd(0, flag);
60,61c69
<         sw_free(object);
<         return SW_ERR;
---
>         return -1;
66d73
<         p->blocking = blocking;
73,82c80
< 
<     return SW_OK;
< }
< 
< int swPipeEventfd_close(swPipe *p)
< {
<     int ret = 0;
<     ret = close(((swPipeEventfd *) (p->object))->event_fd);
<     sw_free(p->object);
<     return ret;
---
>     return 0;
86a85
>     int ret = -1;
90c89
<     if (p->blocking && p->timeout > 0 && swSocket_wait(object->event_fd, p->timeout * 1000, SW_EVENT_READ) < 0)
---
>     if (p->blocking == 1 && p->timeout > 0)
92c91,94
<         return SW_ERR;
---
>         if (swSocket_wait(object->event_fd, p->timeout * 1000, SW_EVENT_READ) < 0)
>         {
>             return SW_ERR;
>         }
95d96
<     int ret = -1;
103d103
< 
106d105
< 
111a111
>     int ret;
113d112
<     int ret = -1;
117c116
<         if (ret < 0 && errno == EINTR)
---
>         if (ret < 0)
119c118,121
<             continue;
---
>             if (errno == EINTR)
>             {
>                 continue;
>             }
121d122
< 
124d124
< 
132a133,140
> static int swPipeEventfd_close(swPipe *p)
> {
>     int ret;
>     ret = close(((swPipeEventfd *) (p->object))->event_fd);
>     sw_free(p->object);
>     return ret;
> }
> 
diff -r ./zan-extension/src/pipe/PipeUnsock.c ../swoole-1.8.5-stable/src/pipe/PipeUnsock.c
18,21c18
< #include "swPipe.h"
< #include "swLog.h"
< #include "swMemory/buffer.h"
< #include "swGlobalVars.h"
---
> #include "buffer.h"
27a25
> static int swPipeUnsock_close(swPipe *p);
34c32
< int swPipeUnsock_create(swPipe *p, int blocking, int protocol)
---
> static int swPipeUnsock_getFd(swPipe *p, int isWriteFd)
36,38c34,41
<     if (!p){
<     	return SW_ERR;
<     }
---
>     swPipeUnsock *this = p->object;
>     return isWriteFd == 1 ? this->socks[1] : this->socks[0];
> }
> 
> static int swPipeUnsock_close(swPipe *p)
> {
>     int ret1, ret2;
>     swPipeUnsock *object = p->object;
39a43,53
>     ret1 = close(object->socks[0]);
>     ret2 = close(object->socks[1]);
> 
>     sw_free(object);
> 
>     return 0 - ret1 - ret2;
> }
> 
> int swPipeUnsock_create(swPipe *p, int blocking, int protocol)
> {
>     int ret;
46,47c60,62
< 
<     if (socketpair(AF_UNIX, protocol, 0, object->socks) < 0)
---
>     p->blocking = blocking;
>     ret = socketpair(AF_UNIX, protocol, 0, object->socks);
>     if (ret < 0)
50d64
<         sw_free(object);
56c70
<         if (!blocking)
---
>         if (blocking == 0)
58,59c72,73
<             swSetNonBlock(object->socks[0],1);
<             swSetNonBlock(object->socks[1],1);
---
>             swSetNonBlock(object->socks[0]);
>             swSetNonBlock(object->socks[1]);
66d79
<         p->blocking = blocking;
73,86c86
< 
<     return SW_OK;
< }
< 
< int swPipeUnsock_close(swPipe *p)
< {
<     swPipeUnsock *object = p->object;
< 
<     int ret1 = close(object->socks[0]);
<     int ret2 = close(object->socks[1]);
< 
<     sw_free(object);
< 
<     return 0 - ret1 - ret2;
---
>     return 0;
98,103d97
< 
< static int swPipeUnsock_getFd(swPipe *p, int isWriteFd)
< {
<     swPipeUnsock *this = p->object;
<     return isWriteFd? this->socks[1] : this->socks[0];
< }
diff -r ./zan-extension/src/protocol/Base.c ../swoole-1.8.5-stable/src/protocol/Base.c
20,25c20
< #include "swLog.h"
< #include "swConnection.h"
< #include "swGlobalVars.h"
< #include "swBaseOperator.h"
< #include "swProtocol/protocol.h"
< 
---
> #include "Connection.h"
46,48c41
<     	char addr[SW_IP_MAX_LENGTH] = {0};
<     	swConnection_get_ip(conn,addr,SW_IP_MAX_LENGTH);
<         swWarn("invalid package, remote_addr=%s:%d, length=%d, size=%d.",addr, swConnection_get_port(conn), body_length, size);
---
>         swWarn("invalid package, remote_addr=%s:%d, length=%d, size=%d.", swConnection_get_ip(conn), swConnection_get_port(conn), body_length, size);
57c50,53
< 
---
> #if 0
>     static count;
>     count ++;
> #endif
128,130c124,126
<     char *recvbuf = NULL;
<     int ret = 0;
<     uint32_t recvbuf_size = 0;
---
>     char *recvbuf;
>     int ret;
>     uint32_t recvbuf_size;
186,188c182
<             	char addr[SW_IP_MAX_LENGTH] = {0};
<             	swConnection_get_ip(conn,addr,SW_IP_MAX_LENGTH);
<                 swWarn("package is too big, remote_addr=%s:%d, length=%d.", addr, swConnection_get_port(conn), package_length);
---
>                 swWarn("package is too big, remote_addr=%s:%d, length=%d.", swConnection_get_ip(conn), swConnection_get_port(conn), package_length);
194c188
<                 if (buffer->size < package_length && swString_extend(buffer, package_length) < 0)
---
>                 if (buffer->size < package_length)
196c190,193
<                     return SW_ERR;
---
>                     if (swString_extend(buffer, package_length) < 0)
>                     {
>                         return SW_ERR;
>                     }
198d194
< 
222,223c218
<     int buf_size = 0;
<     int n = 0;
---
>     int buf_size;
228,229c223,228
<     buf_size = (buf_size > SW_BUFFER_SIZE)? SW_BUFFER_SIZE:buf_size;
<     n = swConnection_recv(conn, buf_ptr, buf_size, 0);
---
>     if (buf_size > SW_BUFFER_SIZE)
>     {
>         buf_size = SW_BUFFER_SIZE;
>     }
> 
>     int n = swConnection_recv(conn, buf_ptr, buf_size, 0);
268,269c267
<         else if (memcmp(buffer->str + buffer->length - protocol->package_eof_len,
<         					protocol->package_eof, protocol->package_eof_len) == 0)
---
>         else if (memcmp(buffer->str + buffer->length - protocol->package_eof_len, protocol->package_eof, protocol->package_eof_len) == 0)
290,291c288,291
<                 extend_size = (extend_size > protocol->package_max_length)? protocol->package_max_length:extend_size;
< 
---
>                 if (extend_size > protocol->package_max_length)
>                 {
>                     extend_size = protocol->package_max_length;
>                 }
304d303
< 
diff -r ./zan-extension/src/protocol/Base64.c ../swoole-1.8.5-stable/src/protocol/Base64.c
3c3
< #include "swProtocol/base64.h"
---
> #include "base64.h"
diff -r ./zan-extension/src/protocol/Http.c ../swoole-1.8.5-stable/src/protocol/Http.c
17,19c17,18
< #include "swProtocol/http.h"
< #include "swProtocol/http2.h"
< #include "swBaseOperator.h"
---
> #include "http.h"
> #include "http2.h"
156,157c155
<     /// note: hantf fix #1030; need to check
<     char *pe = buf + len - 2;
---
>     char *pe = buf + len;
159c157
<     char *eol;
---
>     char state = 0;
165,188c163,185
<         	buffer->offset = p - buffer->str;
< 			if (strncasecmp(p + 2, SW_STRL("Content-Length") - 1) == 0)
< 			{
< 				p += 2 + (sizeof("Content-Length:") - 1);
< 				eol = strstr(p,"\r\n");
< 				if (NULL == eol)
< 				{
< 					return SW_ERR;
< 				}
< 
< 				while (isspace(*p) && p != eol)
< 				{
< 					p++;
< 				}
< 
< 				if (p == eol)
< 				{
< 					return SW_ERR;
< 				}
< 
< 				request->content_length = atoi(p);
< 				buffer->offset = eol - buffer->str;
< 				return SW_OK;
< 			}
---
>             if (state == 0)
>             {
>                 if (strncasecmp(p + 2, SW_STRL("Content-Length") - 1) == 0)
>                 {
>                     p += sizeof("Content-Length: ");
>                     request->content_length = atoi(p);
>                     state = 1;
>                 }
>                 else
>                 {
>                     p++;
>                 }
>             }
>             else
>             {
>                 if (memcmp(p + 2, SW_STRL("\r\n") - 1) == 0)
>                 {
>                     //strlen(header) + sizeof("\r\n\r\n")
>                     request->header_length = p - buffer->str + sizeof("\r\n\r\n") - 1;
>                     buffer->offset = request->header_length;
>                     return SW_OK;
>                 }
>             }
194a192,217
> int swHttpRequest_have_content_length(swHttpRequest *request)
> {
>     swString *buffer = request->buffer;
>     char *buf = buffer->str + buffer->offset;
>     int len = buffer->length - buffer->offset;
> 
>     char *pe = buf + len;
>     char *p;
> 
>     for (p = buf; p < pe; p++)
>     {
>         if (*p == '\r' && *(p + 1) == '\n')
>         {
>             if (strncasecmp(p + 2, SW_STRL("Content-Length") - 1) == 0)
>             {
>                 return SW_TRUE;
>             }
>             else
>             {
>                 p++;
>             }
>         }
>     }
>     return SW_FALSE;
> }
> 
246,248c269,274
< 
<     request->header_length = n + 4;
<     return SW_OK;
---
>     else
>     {
>         //strlen(header) + sizeof("\r\n\r\n")
>         request->header_length = n + 4;
>         return SW_OK;
>     }
diff -r ./zan-extension/src/protocol/Http2.c ../swoole-1.8.5-stable/src/protocol/Http2.c
18,19c18,19
< #include "swConnection.h"
< #include "swProtocol/http2.h"
---
> #include "Connection.h"
> #include "http2.h"
24c24
<     int package_length = 0;
---
>     int package_length;
diff -r ./zan-extension/src/protocol/Mqtt.c ../swoole-1.8.5-stable/src/protocol/Mqtt.c
19c19
< #include "swProtocol/mqtt.h"
---
> #include "mqtt.h"
Only in ./zan-extension/src/protocol: Nova.c
diff -r ./zan-extension/src/protocol/SSL.c ../swoole-1.8.5-stable/src/protocol/SSL.c
17,18d16
< 
< 
20,23c18
< #include "swLog.h"
< #include "swError.h"
< #include "swConnection.h"
< #include "swProtocol/ssl.h"
---
> #include "Connection.h"
27d21
< 
30d23
< 
340,342c333
<     	char addr[SW_IP_MAX_LENGTH] = {0};
<     	swConnection_get_ip(conn,addr,SW_IP_MAX_LENGTH);
<         swWarn("bad SSL client[%s:%d].", addr, swConnection_get_port(conn));
---
>         swWarn("bad SSL client[%s:%d].", swConnection_get_ip(conn), swConnection_get_port(conn));
403,409c394
<         case SSL_ERROR_SSL:
<         	{
< 				int reason = ERR_GET_REASON(ERR_peek_error());
< 				swWarn("SSL_read(%d, %ld) failed, Reason: %s[%d].", conn->fd, __n, ERR_reason_error_string(reason), reason);
< 				errno = SW_ERROR_SSL_BAD_CLIENT;
< 				return SW_ERR;
<         	}
---
> 
431a417
>             break;
437,443c423
<         case SSL_ERROR_SSL:
<         	{
< 				 int reason = ERR_GET_REASON(ERR_peek_error());
< 				 swWarn("SSL_write(%d, %ld) failed, Reason: %s[%d].", conn->fd, __n, ERR_reason_error_string(reason), reason);
< 				 errno = SW_ERROR_SSL_BAD_CLIENT;
< 				 return SW_ERR;
<         	}
---
> 
diff -r ./zan-extension/src/protocol/Sha1.c ../swoole-1.8.5-stable/src/protocol/Sha1.c
18c18
< #include "swProtocol/sha1.h"
---
> #include "sha1.h"
diff -r ./zan-extension/src/protocol/WebSocket.c ../swoole-1.8.5-stable/src/protocol/WebSocket.c
18,21c18,19
< #include "swLog.h"
< #include "swConnection.h"
< #include "swBaseOperator.h"
< #include "swProtocol/websocket.h"
---
> #include "websocket.h"
> #include "Connection.h"
83d80
< 
diff -r ./zan-extension/src/reactor/ReactorBase.c ../swoole-1.8.5-stable/src/reactor/ReactorBase.c
18,23c18,19
< #include "swLog.h"
< #include "swReactor.h"
< #include "swSignal.h"
< #include "swConnection.h"
< #include "swAsyncIO.h"
< #include "list.h"
---
> #include "Connection.h"
> #include "async.h"
29,31d24
< static int swReactor_setHandle(swReactor *reactor, int _fdtype, swReactor_handle handle);
< static int swReactor_write(swReactor *reactor, int fd, void *buf, int n);
< static void handle_defer_call(swReactor* reactor);
33c26
< int swReactor_init(swReactor *reactor, int max_event)
---
> int swReactor_create(swReactor *reactor, int max_event)
35,40c28,29
< 	if (!reactor)
< 	{
< 		return SW_ERR;
< 	}
< 
< 	bzero(reactor, sizeof(swReactor));
---
>     int ret;
>     bzero(reactor, sizeof(swReactor));
42c31,42
< 	int ret = 0;
---
>     //event less than SW_REACTOR_MINEVENTS, use poll/select
>     if (max_event <= SW_REACTOR_MINEVENTS)
>     {
> #ifdef SW_MAINREACTOR_USE_POLL
>         ret = swReactorPoll_create(reactor, SW_REACTOR_MINEVENTS);
> #else
>         ret = swReactorSelect_create(reactor);
> #endif
>     }
>     //use epoll or kqueue
>     else
>     {
44c44
< 	ret = swReactorEpoll_create(reactor, max_event);
---
>         ret = swReactorEpoll_create(reactor, max_event);
46c46
< 	ret = swReactorKqueue_create(reactor, max_event);
---
>         ret = swReactorKqueue_create(reactor, max_event);
48c48
< 	ret = swReactorPoll_create(reactor, max_event);
---
>         ret = swReactorPoll_create(reactor, max_event);
50c50
< 	ret = swReactorSelect_create(reactor);
---
>         ret = swReactorSelect_create(reactor);
52,56c52
< 
< 	if (ret < 0)
< 	{
< 		return SW_ERR;
< 	}
---
>     }
58a55
> 
59a57
> 
61a60
> 
66c65
<     reactor->socket_array = swArray_create(1024, sizeof(swConnection));
---
>     reactor->socket_array = swArray_new(1024, sizeof(swConnection));
70d68
<         reactor->free(reactor);
74c72
<     return SW_OK;
---
>     return ret;
81,82c79
<         return (reactor->write_handle[fdtype] != NULL) ?
<         		reactor->write_handle[fdtype] : reactor->handle[SW_FD_WRITE];
---
>         return (reactor->write_handle[fdtype] != NULL) ? reactor->write_handle[fdtype] : reactor->handle[SW_FD_WRITE];
86,87c83
<         return (reactor->error_handle[fdtype] != NULL) ?
<         		reactor->error_handle[fdtype] : reactor->handle[SW_FD_CLOSE];
---
>         return (reactor->error_handle[fdtype] != NULL) ? reactor->error_handle[fdtype] : reactor->handle[SW_FD_CLOSE];
89d84
< 
93,115c88
< int swReactor_add_event(swReactor *reactor, int fd, enum swEvent_type event_type)
< {
<     swConnection *conn = swReactor_get(reactor, fd);
<     if (!(conn->events & event_type))
<     {
<         return reactor->set(reactor, fd, conn->fdtype | conn->events | event_type);
<     }
< 
<     return SW_OK;
< }
< 
< int swReactor_del_event(swReactor *reactor, int fd, enum swEvent_type event_type)
< {
<     swConnection *conn = swReactor_get(reactor, fd);
<     if (conn->events & event_type)
<     {
<         return reactor->set(reactor, fd, conn->fdtype | (conn->events & (~event_type)));
<     }
< 
<     return SW_OK;
< }
< 
< static int swReactor_setHandle(swReactor *reactor, int _fdtype, swReactor_handle handle)
---
> int swReactor_setHandle(swReactor *reactor, int _fdtype, swReactor_handle handle)
190c163
<     socket->events |= swReactor_events(fdtype);
---
>     socket->events = swReactor_events(fdtype);
229c202
<     if (worker != NULL && SwooleWG.reload)
---
>     if (worker != NULL)
231c204,206
< 		SwooleWG.reload_count++;
---
>         if (SwooleWG.reload == 1)
>         {
>             SwooleWG.reload_count++;
233,236c208,212
< 		if (reactor->event_num <= 2 || SwooleWG.reload_count >= SW_MAX_RELOAD_WAIT)
< 		{
< 			reactor->running = 0;
< 		}
---
>             if (reactor->event_num <= 2 || SwooleWG.reload_count >= SW_MAX_RELOAD_WAIT)
>             {
>                 reactor->running = 0;
>             }
>         }
238d213
< 
258c233
< //    swReactor_onTimeout_and_Finish(reactor);
---
>     swReactor_onTimeout_and_Finish(reactor);
275,277d249
< 
<     swReactor_onTimeout_and_Finish(reactor);
< 
279,300c251,261
<     handle_defer_call(reactor);
< }
< 
< static void handle_defer_call(swReactor* reactor)
< {
< 	reactor->defer_list_backup = reactor->defer_callback_list;
< 	reactor->defer_callback_list = NULL;
< 
< 	swDefer_callback *cb = NULL;
< 	swDefer_callback *tmp = NULL;
< //	LL_FOREACH(reactor->defer_list_backup, cb)
< //	{
< //		cb->callback(cb->data);
< //	}
< 
< 	LL_FOREACH_SAFE(reactor->defer_list_backup, cb, tmp)
< 	{
< 		cb->callback(cb->data);
< 		sw_free(cb);
< 	}
< 
< 	reactor->defer_list_backup = NULL;
---
>     swDefer_callback *cb, *tmp;
>     LL_FOREACH(reactor->defer_callback_list, cb)
>     {
>         cb->callback(cb->data);
>     }
>     LL_FOREACH_SAFE(reactor->defer_callback_list, cb, tmp)
>     {
>         sw_free(cb);
>     }
>     reactor->defer_callback_list = NULL;
>     swReactor_onTimeout_and_Finish(reactor);
306c267
<     if (socket && socket->out_buffer)
---
>     if (socket->out_buffer)
309d269
<         socket->out_buffer = NULL;
311c271
<     if (socket && socket->in_buffer)
---
>     if (socket->in_buffer)
314,326d273
<         socket->in_buffer = NULL;
<     }
< 
< #ifdef SW_USE_OPENSSL
<     if (socket && socket->ssl)
<     {
<         swSSL_close(socket);
<     }
< #endif
< 
<     if (!reactor->thread && socket && !socket->removed)
<     {
<     	reactor->del(reactor,fd);
328,335c275,276
< 
<     if (socket)
<     {
<     	bzero(socket, sizeof(swConnection));
<     	socket->removed = 1;
<     	socket->closed = 1;
<     }
< 
---
>     bzero(socket, sizeof(swConnection));
>     socket->removed = 1;
339,355c280
< int swReactor_error(swReactor *reactor)
< {
<     switch (errno)
<     {
<     case EINTR:
<         if (reactor->singal_no)
<         {
<             swSignal_callback(reactor->singal_no);
<             reactor->singal_no = 0;
<         }
< 
<         return SW_OK;
<     }
<     return SW_ERR;
< }
< 
< static int swReactor_write(swReactor *reactor, int fd, void *buf, int n)
---
> int swReactor_write(swReactor *reactor, int fd, void *buf, int n)
361c286,289
<     socket->fd = (socket->fd == 0)? fd:socket->fd;
---
>     if (socket->fd == 0)
>     {
>         socket->fd = fd;
>     }
363c291,294
<     socket->buffer_size = (socket->buffer_size == 0)? SwooleG.socket_buffer_size:socket->buffer_size;
---
>     if (socket->buffer_size == 0)
>     {
>         socket->buffer_size = SwooleG.socket_buffer_size;
>     }
373a305
> 
387d318
<         
457,458c388
< 
<     return ret;
---
>     return SW_OK;
478c408
<             return SW_ASYNCERR;
---
>             return SW_OK;
532c462
<     	swSetNonBlock(fd,0);
---
>         swSetBlock(fd);
diff -r ./zan-extension/src/reactor/ReactorEpoll.c ../swoole-1.8.5-stable/src/reactor/ReactorEpoll.c
17d16
< 
19,21d17
< #include "swLog.h"
< #include "swError.h"
< #include "swReactor.h"
24d19
< 
26d20
< 
62a57
>         //flag |= (EPOLLRDHUP);
65d59
< 
93d86
<         sw_free(reactor_object);
101,102d93
<         sw_free(reactor_object->events);
<         sw_free(reactor_object);
105d95
< 
158c148
<     if (fd < 0)
---
>     if (fd <= 0)
223c213,220
<     		reactor->timeout_msec = (timeo == NULL)? -1:timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
---
>         if (timeo == NULL)
>         {
>             reactor->timeout_msec = -1;
>         }
>         else
>         {
>             reactor->timeout_msec = timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
>         }
229,231d225
<         /// 等待超时时间矫正，防止有defer 需要执行，但epoll_wait没有唤醒
< //        msec = msec < 0 && reactor->defer_callback_list? 1:msec;
<         msec = reactor->defer_callback_list? 1:msec;
251c245
< //            continue;
---
>             continue;
253d246
< 
260,286d252
<             if (event.socket->fd != event.fd) {
<                 swWarn("EPOLL event.socket->fd != event.fd");
<             }
< 
<             event.socket->event_trigger = 1;
<             //error
< #ifndef NO_EPOLLRDHUP
<             if ((events[i].events & (EPOLLRDHUP | EPOLLERR | EPOLLHUP)) &&
<             		!event.socket->removed && event.socket->event_trigger)
< #else
<             if ((events[i].events & (EPOLLERR | EPOLLHUP)) &&
<             		!event.socket->removed && event.socket->event_trigger)
< #endif
<             {
< 				handle = swReactor_getHandle(reactor, SW_EVENT_ERROR, event.type);
< 				if (handle)
< 				{
< 					ret = handle(reactor, &event);
< 					if (ret < 0)
< 					{
< 						swSysError("EPOLLERR handle failed. fd=%d.", event.fd);
< 					}
< 				}
< 
< 				event.socket->event_trigger = 0;
< 				continue;
<             }
289,290c255
<             if ((events[i].events & EPOLLIN) &&
<             		!event.socket->removed && event.socket->event_trigger)
---
>             if ((events[i].events & EPOLLIN) && !event.socket->removed)
292,300c257,262
< 				handle = swReactor_getHandle(reactor, SW_EVENT_READ, event.type);
< 				if (handle)
< 				{
< 					ret =  handle(reactor, &event);
< 					if (ret < 0)
< 					{
< 						swSysError("EPOLLIN handle failed. fd=%d.", event.fd);
< 					}
< 				}
---
>                 handle = swReactor_getHandle(reactor, SW_EVENT_READ, event.type);
>                 ret = handle(reactor, &event);
>                 if (ret < 0)
>                 {
>                     swSysError("EPOLLIN handle failed. fd=%d.", event.fd);
>                 }
303,304c265
<             if ((events[i].events & EPOLLOUT) &&
<             		!event.socket->removed && event.socket->event_trigger)
---
>             if ((events[i].events & EPOLLOUT) && !event.socket->removed)
306,314c267,286
< 				handle = swReactor_getHandle(reactor, SW_EVENT_WRITE, event.type);
< 				if (handle)
< 				{
< 					ret = handle(reactor, &event);
< 					if (ret < 0)
< 					{
< 						swSysError("EPOLLOUT handle failed. fd=%d.", event.fd);
< 					}
< 				}
---
>                 handle = swReactor_getHandle(reactor, SW_EVENT_WRITE, event.type);
>                 ret = handle(reactor, &event);
>                 if (ret < 0)
>                 {
>                     swSysError("EPOLLOUT handle failed. fd=%d.", event.fd);
>                 }
>             }
>             //error
> #ifndef NO_EPOLLRDHUP
>             if ((events[i].events & (EPOLLRDHUP | EPOLLERR | EPOLLHUP)) && !event.socket->removed)
> #else
>             if ((events[i].events & (EPOLLERR | EPOLLHUP)) && !event.socket->removed)
> #endif
>             {
>                 handle = swReactor_getHandle(reactor, SW_EVENT_ERROR, event.type);
>                 ret = handle(reactor, &event);
>                 if (ret < 0)
>                 {
>                     swSysError("EPOLLERR handle failed. fd=%d.", event.fd);
>                 }
316,317d287
< 
<             event.socket->event_trigger = 0;
diff -r ./zan-extension/src/reactor/ReactorKqueue.c ../swoole-1.8.5-stable/src/reactor/ReactorKqueue.c
17d16
< 
19,21d17
< #include "swReactor.h"
< #include "swLog.h"
< #include "swError.h"
39d34
< 
78d72
<         sw_free(reactor_object);
87,88d80
<         sw_free(reactor_object->events);
<         sw_free(reactor_object);
172d163
<     swConnection *socket = swReactor_get(reactor, fd);
178d168
< 
188c178
<     else if (socket->events & SW_EVENT_READ)
---
>     else
211c201
<     else if (socket->events & SW_EVENT_WRITE)
---
>     else
222d211
< 
280c269,276
<     	reactor->timeout_msec = (timeo == NULL)? -1:timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
---
>         if (timeo == NULL)
>         {
>             reactor->timeout_msec = -1;
>         }
>         else
>         {
>             reactor->timeout_msec = timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
>         }
316c312
<         //    continue;
---
>             continue;
330c326
<                 if (object->events[i].filter == EVFILT_READ )
---
>                 if (object->events[i].filter == EVFILT_READ && !event.socket->removed)
332c328,330
<                     if(!event.socket->removed)
---
>                     handle = swReactor_getHandle(reactor, SW_EVENT_READ, event.type);
>                     ret = handle(reactor, &event);
>                     if (ret < 0)
334,339c332
<                         handle = swReactor_getHandle(reactor, SW_EVENT_READ, event.type);
<                         ret = handle(reactor, &event);
< 						if (ret < 0)
< 						{
< 							swSysError("kqueue event read socket#%d handler failed.", event.fd);
< 						}
---
>                         swSysError("kqueue event read socket#%d handler failed.", event.fd);
343c336
<                 else if (object->events[i].filter == EVFILT_WRITE)
---
>                 else if (object->events[i].filter == EVFILT_WRITE && !event.socket->removed)
345c338,340
<                     if(!event.socket->removed)
---
>                     handle = swReactor_getHandle(reactor, SW_EVENT_WRITE, event.type);
>                     ret = handle(reactor, &event);
>                     if (ret < 0)
347,352c342
<                         handle = swReactor_getHandle(reactor, SW_EVENT_WRITE, event.type);
< 						ret = handle(reactor, &event);
< 						if (ret < 0)
< 						{
< 							swSysError("kqueue event write socket#%d handler failed.", event.fd);
< 						}
---
>                         swSysError("kqueue event write socket#%d handler failed.", event.fd);
diff -r ./zan-extension/src/reactor/ReactorPoll.c ../swoole-1.8.5-stable/src/reactor/ReactorPoll.c
18,23d17
< #include "swLog.h"
< #include "swError.h"
< #include "swReactor.h"
< 
< #ifdef SW_MAINREACTOR_USE_POLL
< 
60d53
<         sw_free(object);
67,68d59
<         sw_free(object->fds);
<         sw_free(object);
89d79
<     sw_free(object->events);
180a171
>         //找到了
215c206,213
<     	reactor->timeout_msec = (timeo == NULL)? -1:timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
---
>         if (timeo == NULL)
>         {
>             reactor->timeout_msec = -1;
>         }
>         else
>         {
>             reactor->timeout_msec = timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
>         }
221,222d218
<         /// 等待超时时间矫正，防止有defer 需要执行，但epoll_wait没有唤醒
< 		msec = reactor->defer_callback_list? 1:msec;
238c234
<         //    continue;
---
>             continue;
250,265d245
<                 event.socket->event_trigger = 1;
<                 //error
< 				if ((object->events[i].revents & (POLLHUP | POLLERR)) &&
< 						!event.socket->removed && event.socket->event_trigger)
< 				{
< 					handle = swReactor_getHandle(reactor, SW_EVENT_ERROR, event.type);
< 					ret = handle(reactor, &event);
< 					if (ret < 0)
< 					{
< 						swWarn("poll[POLLERR] handler failed. fd=%d. Error: %s[%d]", event.fd, strerror(errno), errno);
< 					}
< 
< 					event.socket->event_trigger = 0;
< 					continue;
< 				}
< 
267,268c247
<                 if ((object->events[i].revents & POLLIN) &&
<                 		!event.socket->removed && event.socket->event_trigger)
---
>                 if ((object->events[i].revents & POLLIN) && !event.socket->removed)
278,279c257
<                 if ((object->events[i].revents & POLLOUT) &&
<                 		!event.socket->removed && event.socket->event_trigger)
---
>                 if ((object->events[i].revents & POLLOUT) && !event.socket->removed)
288,289c266,279
< 
<                 event.socket->event_trigger = 0;
---
>                 //error
>                 if ((object->events[i].revents & (POLLHUP | POLLERR)) && !event.socket->removed)
>                 {
>                     handle = swReactor_getHandle(reactor, SW_EVENT_ERROR, event.type);
>                     ret = handle(reactor, &event);
>                     if (ret < 0)
>                     {
>                         swWarn("poll[POLLERR] handler failed. fd=%d. Error: %s[%d]", event.fd, strerror(errno), errno);
>                     }
>                 }
>             }
>             if (reactor->onFinish != NULL)
>             {
>                 reactor->onFinish(reactor);
292,296d281
< 
<         if (reactor->onFinish != NULL)
< 		{
< 			reactor->onFinish(reactor);
< 		}
298d282
< 
315d298
< #endif
diff -r ./zan-extension/src/reactor/ReactorSelect.c ../swoole-1.8.5-stable/src/reactor/ReactorSelect.c
18,20d17
< #include "swLog.h"
< #include "swReactor.h"
< #include "list.h"
59d55
< 
168c164
<     int ret = 0;
---
>     int ret;
172c168,175
<     	reactor->timeout_msec = (timeo == NULL)? -1:timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
---
>         if (timeo == NULL)
>         {
>             reactor->timeout_msec = -1;
>         }
>         else
>         {
>             reactor->timeout_msec = timeo->tv_sec * 1000 + timeo->tv_usec / 1000;
>         }
200,201c203,212
<         timeout.tv_sec = (reactor->timeout_msec < 0)? SW_MAX_UINT:reactor->timeout_msec / 1000;
<         timeout.tv_usec = (reactor->timeout_msec < 0)? 0:reactor->timeout_msec - timeout.tv_sec * 1000;
---
>         if (reactor->timeout_msec < 0)
>         {
>             timeout.tv_sec = SW_MAX_UINT;
>             timeout.tv_usec = 0;
>         }
>         else
>         {
>             timeout.tv_sec = reactor->timeout_msec / 1000;
>             timeout.tv_usec = reactor->timeout_msec - timeout.tv_sec * 1000;
>         }
210d220
< 
219c229
<         //    continue;
---
>             continue;
230,246d239
<                 event.socket->event_trigger = 1;
<                 //error
< 				if (SW_FD_ISSET(ev->fd, &(object->efds)) &&
< 						!event.socket->removed && event.socket->event_trigger)
< 				{
< 					handle = swReactor_getHandle(reactor, SW_EVENT_ERROR, event.type);
< 					ret = handle(reactor, &event);
< 					if (ret < 0)
< 					{
< 						swWarn("[Reactor#%d] select event[type=SW_FD_ERROR] handler fail. fd=%d|errno=%d", reactor->id,
< 								ev->fd, errno);
< 					}
< 
< 					event.socket->event_trigger = 0;
< 					continue;
< 				}
< 
248,249c241
<                 if (SW_FD_ISSET(ev->fd, &(object->rfds)) &&
<                 		!event.socket->removed && event.socket->event_trigger)
---
>                 if (SW_FD_ISSET(ev->fd, &(object->rfds)) && !event.socket->removed)
260,261c252
<                 if (SW_FD_ISSET(ev->fd, &(object->wfds)) &&
<                 		!event.socket->removed && event.socket->event_trigger)
---
>                 if (SW_FD_ISSET(ev->fd, &(object->wfds)) && !event.socket->removed)
271,272c262,276
< 
<                 event.socket->event_trigger = 0;
---
>                 //error
>                 if (SW_FD_ISSET(ev->fd, &(object->efds)) && !event.socket->removed)
>                 {
>                     handle = swReactor_getHandle(reactor, SW_EVENT_ERROR, event.type);
>                     ret = handle(reactor, &event);
>                     if (ret < 0)
>                     {
>                         swWarn("[Reactor#%d] select event[type=SW_FD_ERROR] handler fail. fd=%d|errno=%d", reactor->id,
>                                 ev->fd, errno);
>                     }
>                 }
>             }
>             if (reactor->onFinish != NULL)
>             {
>                 reactor->onFinish(reactor);
275,279d278
< 
<         if (reactor->onFinish != NULL)
< 		{
< 			reactor->onFinish(reactor);
< 		}
Only in ./zan-extension/src: util
diff -r ./zan-extension/swoole.c ../swoole-1.8.5-stable/swoole.c
20,22c20
< #include "swWork.h"
< #include "swError.h"
< #include "swBaseOperator.h"
---
> #include "zend_variables.h"
29,32c27,28
< #if PHP_MAJOR_VERSION < 7
< #include "ext/standard/php_smart_str.h"
< #else
< #include "zend_smart_str.h"
---
> #ifdef HAVE_PCRE
> #include <ext/spl/spl_iterators.h>
34,37d29
< #include <ext/session/php_session.h>
< #include <ext/standard/php_var.h>
< 
< #include "zend_variables.h"
43d34
< 
50,59c41,65
< //arginfo nova
< ZEND_BEGIN_ARG_INFO_EX(arginfo_nova_decode, 0, 0, 8)
<     ZEND_ARG_INFO(0, buf)
<     ZEND_ARG_INFO(1, service_name)
<     ZEND_ARG_INFO(1, method_name)
<     ZEND_ARG_INFO(1, ip)
<     ZEND_ARG_INFO(1, port)
<     ZEND_ARG_INFO(1, seq_no)
<     ZEND_ARG_INFO(1, attach)
<     ZEND_ARG_INFO(1, data)
---
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server__construct, 0, 0, 2)
>     ZEND_ARG_INFO(0, serv_host)
>     ZEND_ARG_INFO(0, serv_port)
>     ZEND_ARG_INFO(0, serv_mode)
>     ZEND_ARG_INFO(0, sock_type)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_set_oo, 0, 0, 1)
>     ZEND_ARG_INFO(0, zset)
> ZEND_END_ARG_INFO()
> 
> //for object style
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_send_oo, 0, 0, 2)
>     ZEND_ARG_INFO(0, conn_fd)
>     ZEND_ARG_INFO(0, send_data)
>     ZEND_ARG_INFO(0, from_id)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendwait, 0, 0, 2)
>     ZEND_ARG_INFO(0, conn_fd)
>     ZEND_ARG_INFO(0, send_data)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_exist, 0, 0, 1)
>     ZEND_ARG_INFO(0, conn_fd)
62,64c68,74
< ZEND_BEGIN_ARG_INFO_EX(arginfo_nova_encode, 0, 0, 8)
<     ZEND_ARG_INFO(0, service_name)
<     ZEND_ARG_INFO(0, method_name)
---
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_protect, 0, 0, 1)
>     ZEND_ARG_INFO(0, conn_fd)
>     ZEND_ARG_INFO(0, is_protected)
> ZEND_END_ARG_INFO()
> 
> //for object style
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendto_oo, 0, 0, 2)
67,68c77,102
<     ZEND_ARG_INFO(0, seq_no)
<     ZEND_ARG_INFO(0, attach)
---
>     ZEND_ARG_INFO(0, send_data)
> ZEND_END_ARG_INFO()
> 
> //for object style
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendfile_oo, 0, 0, 2)
>     ZEND_ARG_INFO(0, conn_fd)
>     ZEND_ARG_INFO(0, filename)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_close_oo, 0, 0, 1)
>     ZEND_ARG_INFO(0, fd)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_on, 0, 0, 2)
>     ZEND_ARG_INFO(0, name)
>     ZEND_ARG_INFO(0, cb)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_listen, 0, 0, 3)
>     ZEND_ARG_INFO(0, host)
>     ZEND_ARG_INFO(0, port)
>     ZEND_ARG_INFO(0, sock_type)
> ZEND_END_ARG_INFO()
> 
> //object style
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_task_oo, 0, 0, 2)
70c104
<     ZEND_ARG_INFO(1, buf)
---
>     ZEND_ARG_INFO(0, worker_id)
73c107
< ZEND_BEGIN_ARG_INFO_EX(arginfo_is_nova_packet, 0, 0, 1)
---
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_taskwait_oo, 0, 0, 1)
74a109,110
>     ZEND_ARG_INFO(0, timeout)
>     ZEND_ARG_INFO(0, worker_id)
77,78c113,124
< //arginfo event
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_event_add, 0, 0, 2)
---
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_finish_oo, 0, 0, 1)
>     ZEND_ARG_INFO(0, data)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_reload_oo, 0, 0, 0)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_heartbeat_oo, 0, 0, 1)
>     ZEND_ARG_INFO(0, from_id)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_bind, 0, 0, 2)
80,82c126
<     ZEND_ARG_INFO(0, read_callback)
<     ZEND_ARG_INFO(0, write_callback)
<     ZEND_ARG_INFO(0, event_flag)
---
>     ZEND_ARG_INFO(0, uid)
85c129,140
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_event_set, 0, 0, 1)
---
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_connection_info_oo, 0, 0, 2)
>     ZEND_ARG_INFO(0, fd)
>     ZEND_ARG_INFO(0, from_id)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_connection_list_oo, 0, 0, 2)
>     ZEND_ARG_INFO(0, start_fd)
>     ZEND_ARG_INFO(0, find_count)
> ZEND_END_ARG_INFO()
> 
> //arginfo event
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_event_add, 0, 0, 2)
87,89c142
<     ZEND_ARG_INFO(0, read)
<     ZEND_ARG_INFO(0, write)
<     ZEND_ARG_INFO(0, events)
---
>     ZEND_ARG_INFO(0, cb)
104a158,172
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_tick, 0, 0, 2)
>     ZEND_ARG_INFO(0, ms)
>     ZEND_ARG_INFO(0, callback)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_after, 0, 0, 2)
>     ZEND_ARG_INFO(0, ms)
>     ZEND_ARG_INFO(0, callback)
>     ZEND_ARG_INFO(0, param)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_clear, 0, 0, 1)
>     ZEND_ARG_INFO(0, timer_id)
> ZEND_END_ARG_INFO()
> 
108a177,187
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_async_readfile, 0, 0, 2)
>     ZEND_ARG_INFO(0, filename)
>     ZEND_ARG_INFO(0, callback)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_async_writefile, 0, 0, 2)
>     ZEND_ARG_INFO(0, filename)
>     ZEND_ARG_INFO(0, content)
>     ZEND_ARG_INFO(0, callback)
> ZEND_END_ARG_INFO()
> 
125,148c204
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_tick, 0, 0, 2)
<     ZEND_ARG_INFO(0, ms)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_after, 0, 0, 2)
<     ZEND_ARG_INFO(0, ms)
<     ZEND_ARG_INFO(0, callback)
<     ZEND_ARG_INFO(0, param)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_clear, 0, 0, 1)
<     ZEND_ARG_INFO(0, timer_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_set, 0, 0, 1)
<     ZEND_ARG_INFO(0, settings)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_exists, 0, 0, 1)
<     ZEND_ARG_INFO(0, timer_id)
---
>     ZEND_ARG_INFO(0, content)
152,154c208,210
<     ZEND_ARG_INFO(1, read_array)
<     ZEND_ARG_INFO(1, write_array)
<     ZEND_ARG_INFO(1, error_array)
---
>     ZEND_ARG_INFO(0, read_array)
>     ZEND_ARG_INFO(0, write_array)
>     ZEND_ARG_INFO(0, error_array)
165a222,234
> #ifdef SW_ASYNC_MYSQL
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_query, 0, 0, 3)
>     ZEND_ARG_INFO(0, db_link)
>     ZEND_ARG_INFO(0, sql)
>     ZEND_ARG_INFO(0, callback)
> ZEND_END_ARG_INFO()
> 
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_get_mysqli_sock, 0, 0, 1)
>     ZEND_ARG_INFO(0, db_link)
> ZEND_END_ARG_INFO()
> 
> #endif
> 
174,182d242
<     
<     /*------nova_packet------*/
<     PHP_FE(nova_decode, arginfo_nova_decode)
<     PHP_FE(nova_encode, arginfo_nova_encode)
<     PHP_FE(is_nova_packet, arginfo_is_nova_packet)
<     PHP_FE(nova_get_sequence, NULL)
<     PHP_FE(nova_get_time, NULL)
<     PHP_FE(nova_get_ip, NULL)
<     
185c245
<     PHP_FE(swoole_event_set, arginfo_swoole_event_set)
---
>     PHP_FE(swoole_event_set, NULL)
194d253
<     PHP_FE(swoole_timer_exists, arginfo_swoole_timer_exists)
196d254
< 	PHP_FE(swoole_timer_set,arginfo_swoole_timer_set)
200a259,260
>     PHP_FE(swoole_async_readfile, arginfo_swoole_async_readfile)
>     PHP_FE(swoole_async_writefile, arginfo_swoole_async_writefile)
202,204c262
<     PHP_FE(swoole_clean_dns_cache,arginfo_swoole_void)
< 
< 	/*------other-----*/
---
>     /*------other-----*/
206a265
>     PHP_FE(swoole_get_local_ip, arginfo_swoole_void)
209c268,274
< 	PHP_FE(swoole_get_local_ip, arginfo_swoole_void)
---
>     /*------async mysql-----*/
> #ifdef SW_ASYNC_MYSQL
>     PHP_FE(swoole_mysql_query, arginfo_swoole_mysql_query)
>     PHP_FE(swoole_get_mysqli_sock, arginfo_swoole_get_mysqli_sock)
> #endif
>     PHP_FE_END /* Must be the last line in swoole_functions[] */
> };
211,215c276,317
< 	PHP_FE(onClientClose,NULL)
< 	PHP_FE(onClientTimeout,NULL)
<     PHP_FE(onClientConnect,NULL)
<     PHP_FE(onClientRecieve,NULL)
<     PHP_FE(onSubClientConnect,NULL)
---
> static zend_function_entry swoole_server_methods[] = {
>     PHP_ME(swoole_server, __construct, arginfo_swoole_server__construct, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
>     PHP_ME(swoole_server, listen, arginfo_swoole_server_listen, ZEND_ACC_PUBLIC)
>     PHP_MALIAS(swoole_server, addlistener, listen, arginfo_swoole_server_listen, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, on, arginfo_swoole_server_on, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, set, arginfo_swoole_server_set_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, start, arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, send, arginfo_swoole_server_send_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, sendto, arginfo_swoole_server_sendto_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, sendwait, arginfo_swoole_server_sendwait, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, exist, arginfo_swoole_server_exist, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, protect, arginfo_swoole_server_protect, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, sendfile, arginfo_swoole_server_sendfile_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, close, arginfo_swoole_server_close_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, task, arginfo_swoole_server_task_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, taskwait, arginfo_swoole_server_taskwait_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, finish, arginfo_swoole_server_finish_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, reload, arginfo_swoole_server_reload_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, shutdown, arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, stop, arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, getLastError, arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, heartbeat, arginfo_swoole_server_heartbeat_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, connection_info, arginfo_swoole_connection_info_oo, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, connection_list, arginfo_swoole_connection_list_oo, ZEND_ACC_PUBLIC)
>     //psr-0 style
>     PHP_MALIAS(swoole_server, getClientInfo, connection_info, arginfo_swoole_connection_info_oo, ZEND_ACC_PUBLIC)
>     PHP_MALIAS(swoole_server, getClientList, connection_list, arginfo_swoole_connection_list_oo, ZEND_ACC_PUBLIC)
>     //timer
>     PHP_FALIAS(after, swoole_timer_after, arginfo_swoole_timer_after)
>     PHP_FALIAS(tick, swoole_timer_tick, arginfo_swoole_timer_tick)
>     PHP_FALIAS(clearTimer, swoole_timer_clear, arginfo_swoole_timer_clear)
>     PHP_FALIAS(defer, swoole_event_defer, arginfo_swoole_event_defer)
>     //process
>     PHP_ME(swoole_server, sendMessage, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, addProcess, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server, stats, NULL, ZEND_ACC_PUBLIC)
> #ifdef SWOOLE_SOCKETS_SUPPORT
>     PHP_ME(swoole_server, getSocket, NULL, ZEND_ACC_PUBLIC)
> #endif
>     PHP_ME(swoole_server, bind, arginfo_swoole_server_bind, ZEND_ACC_PUBLIC)
>     {NULL, NULL, NULL}
> };
217c319,328
<     PHP_FE_END /* Must be the last line in swoole_functions[] */
---
> #ifdef HAVE_PCRE
> static const zend_function_entry swoole_connection_iterator_methods[] =
> {
>     PHP_ME(swoole_connection_iterator, rewind,      arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_connection_iterator, next,        arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_connection_iterator, current,     arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_connection_iterator, key,         arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_connection_iterator, valid,       arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_connection_iterator, count,       arginfo_swoole_void, ZEND_ACC_PUBLIC)
>     PHP_FE_END
218a330
> #endif
219a332,338
> static const zend_function_entry swoole_timer_methods[] =
> {
>     ZEND_FENTRY(tick, ZEND_FN(swoole_timer_tick), arginfo_swoole_timer_after, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
>     ZEND_FENTRY(after, ZEND_FN(swoole_timer_after), arginfo_swoole_timer_tick, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
>     ZEND_FENTRY(clear, ZEND_FN(swoole_timer_clear), arginfo_swoole_timer_clear, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
>     PHP_FE_END
> };
224a344,351
> zend_class_entry swoole_server_ce;
> zend_class_entry *swoole_server_class_entry_ptr;
> 
> zend_class_entry swoole_connection_iterator_ce;
> zend_class_entry *swoole_connection_iterator_class_entry_ptr;
> 
> zend_class_entry swoole_timer_ce;
> zend_class_entry *swoole_timer_class_entry_ptr;
286,301c413,414
< 		uint32_t old_size = swoole_objects.size;
< 		uint32_t new_size = old_size * 2;
< 		new_size = (new_size > SWOOLE_OBJECT_MAX)? SWOOLE_OBJECT_MAX:new_size;
< 
< 		void *old_ptr = swoole_objects.array;
< 		void *new_ptr = realloc(old_ptr, sizeof(void*) * new_size);
< 		if (!new_ptr)
< 		{
< 			swWarn("alloc global memory failed");
< 			return ;
< 		}
< 
< 		bzero(new_ptr + (old_size * sizeof(void*)), (new_size - old_size) * sizeof(void*));
< 		swoole_objects.array = new_ptr;
< 		swoole_objects.size = new_size;
< 	}
---
>         uint32_t old_size = swoole_objects.size;
>         uint32_t new_size = old_size * 2;
303,317c416,417
< 	swoole_objects.array[handle] = ptr;
< 	return ;
< }
< 
< void* swoole_get_object(zval *object)
< {
< #if PHP_MAJOR_VERSION < 7
<     zend_object_handle handle = Z_OBJ_HANDLE_P(object);
< #else
<     int handle = (int)Z_OBJ_HANDLE(*object);
< #endif
< 
<     assert(handle < swoole_objects.size);
<     return swoole_objects.array[handle];
< }
---
>         void *old_ptr = swoole_objects.array;
>         void *new_ptr = NULL;
319,328c419,430
< void* swoole_get_property(zval *object, int property_id)
< {
< #if PHP_MAJOR_VERSION < 7
<     zend_object_handle handle = Z_OBJ_HANDLE_P(object);
< #else
<     int handle = (int) Z_OBJ_HANDLE(*object);
< #endif
<     if (handle >= swoole_objects.property_size[property_id])
<     {
<         return NULL;
---
>         if (new_size > SWOOLE_OBJECT_MAX)
>         {
>             new_size = SWOOLE_OBJECT_MAX;
>         }
>         new_ptr = realloc(old_ptr, sizeof(void*) * new_size);
>         if (!new_ptr)
>         {
>             return;
>         }
>         bzero(new_ptr + (old_size * sizeof(void*)), (new_size - old_size) * sizeof(void*));
>         swoole_objects.array = new_ptr;
>         swoole_objects.size = new_size;
330c432
<     return swoole_objects.property[property_id][handle];
---
>     swoole_objects.array[handle] = ptr;
358,362d459
<             while (new_size < handle)
<             {
<             	new_size = 2*new_size;
<             }
< 
367d463
< 
382d477
< 
403a499
>     REGISTER_LONG_CONSTANT("SWOOLE_THREAD", SW_MODE_THREAD, CONST_CS | CONST_PERSISTENT);
405d500
< 
412a508
>     REGISTER_LONG_CONSTANT("SWOOLE_IPC_CHANNEL", SW_IPC_CHANNEL, CONST_CS | CONST_PERSISTENT);
442,444c538
< 
< 	REGISTER_LONG_CONSTANT("SWOOLE_ASYNC_CONNECT_TIMEOUT", SW_CLIENT_CONNECT_TIMEOUT, CONST_CS | CONST_PERSISTENT);
< 	REGISTER_LONG_CONSTANT("SWOOLE_ASYNC_RECV_TIMEOUT", SW_CLIENT_RECV_TIMEOUT, CONST_CS | CONST_PERSISTENT);
---
>     REGISTER_LONG_CONSTANT("SWOOLE_KEEP", SW_FLAG_KEEP, CONST_CS | CONST_PERSISTENT);
481,482c575,576
<     //swoole init
< 	swoole_init();
---
>     SWOOLE_INIT_CLASS_ENTRY(swoole_server_ce, "swoole_server", "Swoole\\Server", swoole_server_methods);
>     swoole_server_class_entry_ptr = zend_register_internal_class(&swoole_server_ce TSRMLS_CC);
484c578,579
<     swoole_server_init(module_number TSRMLS_CC);
---
>     SWOOLE_INIT_CLASS_ENTRY(swoole_timer_ce, "swoole_timer", "Swoole\\Timer", swoole_timer_methods);
>     swoole_timer_class_entry_ptr = zend_register_internal_class(&swoole_timer_ce TSRMLS_CC);
486c581,585
<     swoole_timer_init(module_number TSRMLS_CC);
---
> #ifdef HAVE_PCRE
>     SWOOLE_INIT_CLASS_ENTRY(swoole_connection_iterator_ce, "swoole_connection_iterator", "Swoole\\ConnectionIterator",  swoole_connection_iterator_methods);
>     swoole_connection_iterator_class_entry_ptr = zend_register_internal_class(&swoole_connection_iterator_ce TSRMLS_CC);
>     zend_class_implements(swoole_connection_iterator_class_entry_ptr TSRMLS_CC, 2, spl_ce_Iterator, spl_ce_Countable);
> #endif
487a587,588
>     //swoole init
>     swoole_init();
490,492c591
< 
<     swoole_connpool_init(module_number TSRMLS_CC);
< 
---
> #ifdef SW_ASYNC_HTTPCLIENT
494c593
< 
---
> #endif
498,499c597
<     
<     swoole_aio_init(module_number TSRMLS_CC);
---
>     swoole_async_init(module_number TSRMLS_CC);
500a599,601
>     swoole_table_init(module_number TSRMLS_CC);
>     swoole_lock_init(module_number TSRMLS_CC);
>     swoole_atomic_init(module_number TSRMLS_CC);
504a606
> #ifdef SW_ASYNC_MYSQL
505a608
> #endif
544d646
<     php_info_print_table_row(2, "YZ-Version", YZ_SWOOLE_VERSION);
580c682
< 
---
> #ifdef SW_ASYNC_HTTPCLIENT
582c684
< 
---
> #endif
657d758
<                     swWarn("PHP_RSHUTDOWN_FUNCTION(swoole).");
670a772
>     SwooleWG.reactor_wait_onexit = 0;
672,674d773
<     /// clean client information
<     swoole_thread_clean();
< 	SwooleWG.reactor_wait_onexit = 0;
693d791
< 
699,702c797,800
< #define STRERROR_MAX_LEN   256
<     long swoole_errno = 0;
<     char error_msg[STRERROR_MAX_LEN] = {0};
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &swoole_errno))
---
>     int swoole_errno = 0;
>     char error_msg[256] = {0};
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &swoole_errno) == FAILURE)
706,708c804,805
< 
<     snprintf(error_msg, STRERROR_MAX_LEN - 1, "%s", strerror(swoole_errno));
<     SW_RETURN_STRING(error_msg,1);
---
>     snprintf(error_msg, sizeof(error_msg) - 1, "%s", strerror(swoole_errno));
>     SW_RETURN_STRING(error_msg, 1);
718c815
<     zval *name = NULL;
---
>     zval *name;
720c817,818
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|l", &name, &size))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|l", &name, &size) == FAILURE)
725c823
<     if (Z_STRLEN_P(name) <= 0 || Z_STRLEN_P(name) > 127)
---
>     if (Z_STRLEN_P(name) == 0)
727d824
<     	php_error_docref(NULL TSRMLS_CC, E_WARNING, "process name max len is 127");
729a827,830
>     else if (Z_STRLEN_P(name) > 127)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "process name is too long,the max len is 127");
>     }
731c832,835
<     size = (size > SwooleG.pagesize)? SwooleG.pagesize:size;
---
>     if (size > SwooleG.pagesize)
>     {
>         size = SwooleG.pagesize;
>     }
734,737c838
<     zval *function = NULL;
<     SW_MAKE_STD_ZVAL(function);
<     SW_ZVAL_STRING(function, "cli_set_process_title", 1);
< 
---
>     zval *retval;
741c842,845
<     zval *retval = NULL;
---
>     zval *function;
>     SW_MAKE_STD_ZVAL(function);
>     SW_ZVAL_STRING(function, "cli_set_process_title", 1);
> 
746d849
< 
756d858
< 
761,762c863,868
<     struct ifaddrs *ipaddrs = NULL;
<     if (getifaddrs(&ipaddrs) != 0 || !ipaddrs)
---
>     struct sockaddr_in *s4;
>     struct ifaddrs *ipaddrs, *ifa;
>     void *in_addr;
>     char ip[64];
> 
>     if (getifaddrs(&ipaddrs) != 0)
767d872
< 
769d873
<     struct ifaddrs *ifa = NULL;
777d880
<         void *in_addr = NULL;
781c884,885
<                 in_addr = &(((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr);
---
>                 s4 = (struct sockaddr_in *)ifa->ifa_addr;
>                 in_addr = &s4->sin_addr;
783,785c887,890
< //            case AF_INET6:
< //                in_addr = &(((struct sockaddr_in6 *)(ifa->ifa_addr))->sin6_addr);
< //                break;
---
>             case AF_INET6:
>                 //struct sockaddr_in6 *s6 = (struct sockaddr_in6 *)ifa->ifa_addr;
>                 //in_addr = &s6->sin6_addr;
>                 continue;
789,790d893
< 
<         char ip[SW_IP_MAX_LENGTH] = {0};
795c898
<         else if (strncmp(ip, "127.",strlen("127.")) != 0)
---
>         else
797c900,905
<           	sw_add_assoc_string(return_value, ifa->ifa_name, ip, 1);
---
>             //if (ifa->ifa_addr->sa_family == AF_INET && ntohl(((struct in_addr *) in_addr)->s_addr) == INADDR_LOOPBACK)
>             if (strcmp(ip, "127.0.0.1") == 0)
>             {
>                 continue;
>             }
>             sw_add_assoc_string(return_value, ifa->ifa_name, ip, 1);
800d907
< 
802a910,918
> 
> /*
>  * Local variables:
>  * tab-width: 4
>  * c-basic-offset: 4
>  * End:
>  * vim600: noet sw=4 ts=4 fdm=marker
>  * vim<600: noet sw=4 ts=4
>  */
diff -r ./zan-extension/swoole_async.c ../swoole-1.8.5-stable/swoole_async.c
20,24d19
< #include "swBaseData.h"
< #include "swBaseOperator.h"
< #include "swDNS.h"
< 
< #include "ext/standard/file.h"
38,39c33,34
<     char *content;
<     uint32_t length;
---
>     char *file_content;
>     uint32_t content_length;
52,54d46
< static swHashMap *php_swoole_open_files;
< static swHashMap *php_swoole_aio_request;
< 
57d48
< static void php_swoole_file_request_free(void *data);
59,61c50,51
< static int swoole_gethost_from_cache(zval* domain,zval* callback);
< static void swoole_aio_dns_complete(swAio_event *event);
< static void swoole_aio_file_complete(swAio_event *event);
---
> static swHashMap *php_swoole_open_files;
> static swHashMap *php_swoole_aio_request;
67c57
<         sw_free(ptr);
---
>         free(ptr);
69c59
<     else if (ptr)
---
>     else
71c61
<         swoole_efree(ptr);
---
>         efree(ptr);
77c67,68
<     void *memory = NULL;
---
>     void *memory;
> 
96c87
< static int swoole_gethost_from_cache(zval* domain,zval* callback)
---
> void swoole_async_init(int module_number TSRMLS_DC)
98,141c89,104
< 	if (SwooleG.disable_dns_cache)
< 	{
< 		return SW_ERR;
< 	}
< 
< 	int flags = AF_INET | SW_DNS_LOOKUP_CACHE_ONLY;
< 	flags |= (SwooleG.dns_lookup_random)? SW_DNS_LOOKUP_RANDOM:0;
< 	char ipaddr[SW_IP_MAX_LENGTH] = {0};
< 	if (swoole_gethostbyname(flags, Z_STRVAL_P(domain),ipaddr,SW_IP_MAX_LENGTH) < 0)
< 	{
< 		return SW_ERR;
< 	}
< 
< 	zval *zcontent = NULL;
< 	SW_MAKE_STD_ZVAL(zcontent);
< 	SW_ZVAL_STRING(zcontent,ipaddr, 1);
< 
< 	zval *zdomain = NULL;
< 	SW_MAKE_STD_ZVAL(zdomain);
< 	SW_ZVAL_STRINGL(zdomain, Z_STRVAL_P(domain), Z_STRLEN_P(domain), 1);
< 
< 	zval **args[2];
< 	args[0] = &zdomain;
< 	args[1] = &zcontent;
< 
< 	zval *retval = NULL;
< 	if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
< 	{
< 		swWarn("swoole_async: onAsyncComplete handler error");
< 	}
< 
< 	if (EG(exception))
< 	{
< 		zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 	}
< 
< 	if (retval)
< 	{
< 		sw_zval_ptr_dtor(&retval);
< 	}
< 
< 	sw_zval_ptr_dtor(&zdomain);
< 	sw_zval_ptr_dtor(&zcontent);
< 	return SW_OK;
---
>     bzero(&SwooleAIO, sizeof(SwooleAIO));
> 
>     REGISTER_LONG_CONSTANT("SWOOLE_AIO_BASE", SW_AIO_BASE, CONST_CS | CONST_PERSISTENT);
>     REGISTER_LONG_CONSTANT("SWOOLE_AIO_GCC", SW_AIO_GCC, CONST_CS | CONST_PERSISTENT);
>     REGISTER_LONG_CONSTANT("SWOOLE_AIO_LINUX", SW_AIO_LINUX, CONST_CS | CONST_PERSISTENT);
> 
>     php_swoole_open_files = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, NULL);
>     if (php_swoole_open_files == NULL)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_ERROR, "create hashmap[1] failed.");
>     }
>     php_swoole_aio_request = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, NULL);
>     if (php_swoole_aio_request == NULL)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_ERROR, "create hashmap[2] failed.");
>     }
146c109
<     if (!SwooleAIO.init)
---
>     if (SwooleAIO.init == 0)
154c117
< static void php_swoole_file_request_free(void *data)
---
> static void php_swoole_aio_onComplete(swAio_event *event)
156,157c119,135
<     file_request *file_req = data;
<     if (file_req->callback)
---
>     int isEOF = SW_FALSE;
>     int64_t ret;
> 
>     zval *retval = NULL, *zcallback = NULL, *zwriten = NULL;
>     zval *zcontent = NULL;
>     zval **args[2];
>     file_request *file_req = NULL;
>     dns_request *dns_req = NULL;
> 
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #else
>     zval _zcontent;
>     zval _zwriten;
> #endif
> 
>     if (event->type == SW_AIO_DNS_LOOKUP)
159,160c137,158
<         sw_zval_ptr_dtor(&file_req->callback);
<         file_req->callback = NULL;
---
>         dns_req = (dns_request *) event->req;
>         if (dns_req->callback == NULL)
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: onAsyncComplete callback not found[0]");
>             return;
>         }
>         zcallback = dns_req->callback;
>     }
>     else
>     {
>         file_req = swHashMap_find_int(php_swoole_aio_request, event->fd);
>         if (!file_req)
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: onAsyncComplete callback not found[1]");
>             return;
>         }
>         if (file_req->callback == NULL && file_req->type == SW_AIO_READ)
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: onAsyncComplete callback not found[2]");
>             return;
>         }
>         zcallback = file_req->callback;
163,164c161,182
<     swoole_aio_free(file_req->content);
<     file_req->content = NULL;
---
>     ret = event->ret;
>     if (ret < 0)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: Aio Error: %s[%d]", strerror(event->error), event->error);
>     }
>     else if (file_req != NULL)
>     {
>         if (ret == 0)
>         {
>             bzero(event->buf, event->nbytes);
>             isEOF = SW_TRUE;
>         }
>         else if (file_req->once == 1 && ret < file_req->content_length)
>         {
>             swoole_php_fatal_error(E_WARNING, "swoole_async: ret_length[%d] < req->length[%d].", (int) ret,
>                     file_req->content_length);
>         }
>         else if (event->type == SW_AIO_READ)
>         {
>             file_req->offset += event->ret;
>         }
>     }
166c184
<     if (file_req->filename)
---
>     if (event->type == SW_AIO_READ)
168,169c186,194
<         sw_zval_ptr_dtor(&file_req->filename);
<     	file_req->filename = NULL;
---
>         args[0] = &file_req->filename;
>         args[1] = &zcontent;
> #if PHP_MAJOR_VERSION < 7
>         SW_MAKE_STD_ZVAL(zcontent);
> #else
>         zcontent = &_zcontent;
> #endif
>         memset(event->buf + ret, 0, 1);
>         SW_ZVAL_STRINGL(zcontent, event->buf, ret, 1);
170a196,205
>     else if (event->type == SW_AIO_WRITE)
>     {
> #if PHP_MAJOR_VERSION < 7
>         SW_MAKE_STD_ZVAL(zwriten);
> #else
>         zwriten = &_zwriten;
> #endif
>         args[0] = &file_req->filename;
>         args[1] = &zwriten;
>         ZVAL_LONG(zwriten, ret);
172,173c207,234
<     swoole_efree(file_req);
< }
---
>         if (file_req->once != 1)
>         {
>             swoole_aio_free(event->buf);
>         }
>     }
>     else if(event->type == SW_AIO_DNS_LOOKUP)
>     {
>         args[0] = &dns_req->domain;
> #if PHP_MAJOR_VERSION < 7
>         SW_MAKE_STD_ZVAL(zcontent);
> #else
>         zcontent = &_zcontent;
> #endif
>         if (ret < 0)
>         {
>             SW_ZVAL_STRING(zcontent, "", 1);
>         }
>         else
>         {
>             SW_ZVAL_STRING(zcontent, event->buf, 1);
>         }
>         args[1] = &zcontent;
>     }
>     else
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: onAsyncComplete unknow event type");
>         return;
>     }
175,177c236,243
< static void php_swoole_aio_onComplete(swAio_event *event)
< {
<     SWOOLE_FETCH_TSRMLS;
---
>     if (zcallback)
>     {
>         if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: onAsyncComplete handler error");
>             return;
>         }
>     }
179c245,246
<     if (event->type == SW_AIO_DNS_LOOKUP)
---
>     //readfile/writefile
>     if (file_req != NULL)
181c248,280
<     	swoole_aio_dns_complete(event);
---
>         if (file_req->once == 1)
>         {
>             close_file:
>             if (file_req->callback)
>             {
>                 sw_zval_ptr_dtor(&file_req->callback);
>             }
>             sw_zval_ptr_dtor(&file_req->filename);
> 
>             swoole_aio_free(event->buf);
>             close(event->fd);
>             swHashMap_del_int(php_swoole_aio_request, event->fd);
>             efree(file_req);
>         }
>         else if(file_req->type == SW_AIO_WRITE)
>         {
>             if (retval != NULL && !Z_BVAL_P(retval))
>             {
>                 swHashMap_del(php_swoole_open_files, Z_STRVAL_P(file_req->filename), Z_STRLEN_P(file_req->filename));
>                 goto close_file;
>             }
>         }
>         else
>         {
>             if (!Z_BVAL_P(retval) || isEOF)
>             {
>                 goto close_file;
>             }
>             else if (SwooleAIO.read(event->fd, event->buf, event->nbytes, file_req->offset) < 0)
>             {
>                 php_error_docref(NULL TSRMLS_CC, E_WARNING, "swoole_async: continue to read failed. Error: %s[%d]", strerror(event->error), event->error);
>             }
>         }
183c282
<     else if (event->type == SW_AIO_READ || event->type == SW_AIO_WRITE)
---
>     else if (dns_req != NULL)
185c284,299
<     	swoole_aio_file_complete(event);
---
>         sw_zval_ptr_dtor(&dns_req->callback);
>         sw_zval_ptr_dtor(&dns_req->domain);
>         efree(dns_req);
>         efree(event->buf);
>     }
>     if (zcontent != NULL)
>     {
>         sw_zval_ptr_dtor(&zcontent);
>     }
>     if (zwriten != NULL)
>     {
>         sw_zval_ptr_dtor(&zwriten);
>     }
>     if (retval != NULL)
>     {
>         sw_zval_ptr_dtor(&retval);
187,385d300
<     else
< 	{
< 		swWarn("swoole_async: onAsyncComplete unknown event type[%d].", event->type);
< 		return;
< 	}
< }
< 
< static void swoole_aio_dns_complete(swAio_event *event)
< {
< 	dns_request *dns_req = (dns_request *) event->req;
< 	if (!dns_req || !dns_req->callback)
< 	{
< 		swWarn("swoole_async: dns complete callback not found[0]");
< 		return;
< 	}
< 
< 	zval *zcallback =  dns_req->callback;
< 
< 	int64_t ret = event->ret;
< 	if (ret < 0)
< 	{
< 		swWarn("swoole_async: file aio Error: %s[%d]", strerror(event->error), event->error);
< 	}
< 
< 	zval*  zcontent = NULL;
< 	SW_MAKE_STD_ZVAL(zcontent);
< 	const char* content = (const char*)((ret < 0)? "":event->buf);
< 	SW_ZVAL_STRING(zcontent, content, 1);
< 
< 	zval** args[2];
< 	args[0] = &dns_req->domain;
< 	args[1] = &zcontent;
< 
< 	zval *retval = NULL;
< 	if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval,
< 															2, args, 0, NULL TSRMLS_CC) == FAILURE)
< 	{
< 		swWarn("swoole_async: file aio handler error");
< 	}
< 
< 	if (EG(exception))
< 	{
< 		zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 	}
< 
< 	if (dns_req->callback)
< 	{
< 	    sw_zval_ptr_dtor(&dns_req->callback);
< 		dns_req->callback = NULL;
< 	}
< 
< 	if (dns_req->domain)
< 	{
< 	    sw_zval_ptr_dtor(&dns_req->domain);
< 		dns_req->domain = NULL;
< 	}
< 
< 	swoole_efree(dns_req);
< 	swoole_efree(event->buf);
< 
< 	if (zcontent)
< 	{
< 		sw_zval_ptr_dtor(&zcontent);
< 	}
< 
< 	if (retval)
< 	{
< 		sw_zval_ptr_dtor(&retval);
< 	}
< }
< 
< static void swoole_aio_file_complete(swAio_event *event)
< {
< 	file_request *file_req = swHashMap_find_int(php_swoole_aio_request, event->task_id);
< 	if (!file_req || (!file_req->callback && file_req->type == SW_AIO_READ))
< 	{
< 		swWarn("swoole_async: file complete callback not found");
< 		return;
< 	}
< 
< 	int isEOF = SW_FALSE;
< 	int64_t ret = event->ret;
< 	if (ret < 0)
< 	{
< 		SwooleG.error = event->error;
< 		swoole_php_error(E_WARNING, "Aio Error: %s[%d]", strerror(event->error), event->error);
< 	}
< 	else if (0 == ret)
< 	{
< 		bzero(event->buf, event->nbytes);
< 		isEOF = SW_TRUE;
< 	}
< 	else if (event->type == SW_AIO_WRITE)
< 	{
< 		file_req->offset += ret;
< 		event->buf += ret;
< 		event->nbytes -= ret;
< 		file_req->length = (file_req->length <= ret)? 0:file_req->length - ret;
< 		isEOF = file_req->length > 0 ? 0: 1;
< 	}
< 	else if (file_req->once == 1 && ret < file_req->length)
< 	{
< 		swWarn("swoole_async: ret_length[%d] < req->length[%d].", (int ) ret, file_req->length);
< 	}
< 	else if (event->type == SW_AIO_READ)
< 	{
< 		file_req->offset += ret;
< 		file_req->length = (file_req->length <= ret)? 0:file_req->length - ret;
< 	}
< 
< 	zval **args[2];
< 	zval *zcontent = NULL;
< 	SW_MAKE_STD_ZVAL(zcontent);
< 	if (event->type == SW_AIO_READ)
< 	{
< 		memset(event->buf + ret, 0, 1);
< 		SW_ZVAL_STRINGL(zcontent, event->buf, ret, 1);
< 		args[0] = &file_req->filename;
< 		args[1] = &zcontent;
< 	}
< 	else if (event->type == SW_AIO_WRITE)
< 	{
< 		ZVAL_LONG(zcontent, ret);
< 		args[0] = &file_req->filename;
< 		args[1] = &zcontent;
< 	}
< 
< 	zval *zcallback = file_req->callback;
< 	zval *retval = NULL;
< 	if (zcallback && sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval,
< 															2, args, 0, NULL TSRMLS_CC) == FAILURE)
< 	{
< 		swWarn("swoole_async: file aio handler error");
< 		goto close_file;
< 	}
< 
< 	if (file_req->once)
< 	{
< close_file:
< 		close(event->fd);
< 		swHashMap_del_int(php_swoole_aio_request, event->task_id);
< 	}
< 	else if(file_req->type == SW_AIO_WRITE)
< 	{
< 		if ((retval && !ZVAL_IS_NULL(retval) && !Z_BVAL_P(retval)) || isEOF)
< 		{
< 			swHashMap_del(php_swoole_open_files, Z_STRVAL_P(file_req->filename), Z_STRLEN_P(file_req->filename));
< 			goto close_file;
< 		}
< 		else
< 		{
< 			event->nbytes = file_req->length;
< 			int taskId = SwooleAIO.write(event->fd, event->buf, event->nbytes, file_req->offset);
< 			if (taskId < 0)
< 			{
< 				swWarn("swoole_async: continue to read failed. Error: %s[%d]", strerror(event->error), event->error);
< 				goto close_file;
< 			}
< 			else
< 			{
< 				swHashMap_move_int(php_swoole_aio_request, event->task_id, taskId);
< 			}
< 		}
< 	}
< 	else
< 	{
< 		if ((retval && !ZVAL_IS_NULL(retval) && !Z_BVAL_P(retval)) || isEOF)
< 		{
< 			goto close_file;
< 		}
< 
< 		//continue to read
< 		event->nbytes = event->nbytes < file_req->length? event->nbytes:file_req->length;
< 		int ret = SwooleAIO.read(event->fd, event->buf, event->nbytes, file_req->offset);
< 		if (ret < 0)
< 		{
< 			swWarn("swoole_async: continue to read failed. Error: %s[%d]", strerror(event->error), event->error);
< 			goto close_file;
< 		}
< 		else
< 		{
< 			swHashMap_move_int(php_swoole_aio_request, event->task_id, ret);
< 		}
< 	}
< 
< 	if (EG(exception))
< 	{
< 		zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 	}
< 
< 	if (zcontent)
< 	{
< 		sw_zval_ptr_dtor(&zcontent);
< 	}
< 
< 	if (retval)
< 	{
< 		sw_zval_ptr_dtor(&retval);
< 	}
388c303
< void swoole_aio_init(int module_number TSRMLS_DC)
---
> PHP_FUNCTION(swoole_async_read)
390c305,309
<     bzero(&SwooleAIO, sizeof(SwooleAIO));
---
>     zval *cb;
>     zval *filename;
>     long buf_size = 8192;
>     long offset = 0;
>     int open_flag = O_RDONLY;
392,393c311,314
<     REGISTER_LONG_CONSTANT("SWOOLE_AIO_BASE", SW_AIO_BASE, CONST_CS | CONST_PERSISTENT);
<     REGISTER_LONG_CONSTANT("SWOOLE_AIO_LINUX", SW_AIO_LINUX, CONST_CS | CONST_PERSISTENT);
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|ll", &filename, &cb, &buf_size, &offset) == FAILURE)
>     {
>         return;
>     }
395c316,321
<     dns_lookup_init();
---
>     if (offset < 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "offset must be greater than 0.");
>         RETURN_FALSE;
>     }
>     convert_to_string(filename);
397,398c323
<     php_swoole_open_files = swHashMap_create(SW_HASHMAP_INIT_BUCKET_N,NULL);
<     if (!php_swoole_open_files)
---
>     if (SwooleAIO.mode == SW_AIO_LINUX)
400c325
<         swoole_php_fatal_error(E_ERROR, "create hashmap[1] failed.");
---
>         open_flag |= O_DIRECT;
403,404c328,329
<     php_swoole_aio_request = swHashMap_create(SW_HASHMAP_INIT_BUCKET_N, php_swoole_file_request_free);
<     if (!php_swoole_aio_request)
---
>     int fd = open(Z_STRVAL_P(filename), open_flag, 0644);
>     if (fd < 0)
406c331,332
<         swoole_php_fatal_error(E_ERROR, "create hashmap[2] failed.");
---
>         swoole_php_sys_error(E_WARNING, "open(%s, O_RDONLY) failed.", Z_STRVAL_P(filename));
>         RETURN_FALSE;
408d333
< }
410,492c335,372
< PHP_FUNCTION(swoole_async_read)
< {
< 	zval *callback = NULL;
< 	zval *filename = NULL;
< 	long buf_size = -1;
< 	long offset = 0;
< 
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|ll", &filename, &callback, &buf_size, &offset))
< 	{
< 		return;
< 	}
< 
< 	if (offset < 0)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "offset must be greater than 0.");
< 		RETURN_FALSE;
< 	}
< 
< 	if (swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
< 		swoole_php_fatal_error(E_WARNING,"user must set callback.");
< 		RETURN_FALSE;
< 	}
< 
< 	convert_to_string(filename);
< 	int open_flag = O_RDONLY;
< 	open_flag |= (SwooleAIO.mode == SW_AIO_LINUX)? O_DIRECT:0;
< 	int fd = open(Z_STRVAL_P(filename), open_flag, 0644);
< 	if (fd < 0)
< 	{
< 		swoole_php_sys_error(E_WARNING, "open(%s, O_RDONLY) failed.", Z_STRVAL_P(filename));
< 		RETURN_FALSE;
< 	}
< 
< 	size_t filelen = get_filelen(fd);
< 	if (filelen <= 0 || offset >= filelen)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "offset must be less than file_size[=%ld].", filelen);
< create_error:
< 		close(fd);
< 		RETURN_FALSE;
< 	}
< 
< 	/// 限制一次读取buf_size 的长度
< 	///[1] buf_size < 0 读取全部文件.
< 	buf_size = (buf_size < 0)? filelen:buf_size;
< 	///[2] buf_size + offset > filelen 则只读取filelen － offset的长度
< 	buf_size = (buf_size + offset > filelen)? filelen - offset:buf_size;
< 	int read_size = (buf_size > SW_FILE_MAX_LEN_ONCE)? SW_FILE_MAX_LEN_ONCE:buf_size;
< 	void *fcnt = swoole_aio_malloc(read_size + 1);
< 	if (!fcnt)
< 	{
< 		swoole_php_sys_error(E_WARNING, "malloc failed.");
< 		goto create_error;
< 	}
< 
< 	file_request *req = emalloc(sizeof(file_request));
< 	req->fd = fd;
< 	req->content = fcnt;
< 	req->once = 0;
< 	req->type = SW_AIO_READ;
< 	req->length = buf_size;
< 	req->offset = offset;
< 
< 	php_swoole_check_aio();
< 
< 	int ret = SwooleAIO.read(fd, fcnt, read_size, offset);
< 	if (ret < 0)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	req->filename = filename;
< 	sw_zval_add_ref(&filename);
< 	sw_copy_to_stack(req->filename, req->_filename);
< 
< 	if (callback && !ZVAL_IS_NULL(callback))
< 	{
< 		req->callback = callback;
< 		sw_zval_add_ref(&callback);
< 		sw_copy_to_stack(req->callback, req->_callback);
< 	}else
< 		req->callback = NULL;
---
>     struct stat file_stat;
>     if (fstat(fd, &file_stat) < 0)
>     {
>         swoole_php_sys_error(E_WARNING, "fstat(%s) failed.", Z_STRVAL_P(filename));
>         RETURN_FALSE;
>     }
>     if (offset >= file_stat.st_size)
>     {
>         swoole_php_fatal_error(E_WARNING, "offset must be less than file_size[=%ld].", file_stat.st_size);
>         RETURN_FALSE;
>     }
> 
>     void *fcnt = swoole_aio_malloc(buf_size);
>     if (fcnt == NULL)
>     {
>         swoole_php_sys_error(E_WARNING, "malloc failed.");
>         RETURN_FALSE;
>     }
> 
>     file_request *req = emalloc(sizeof(file_request));
>     req->fd = fd;
> #if PHP_MAJOR_VERSION >= 7
>     req->callback =  &req->_callback;
>     req->filename = &req->_filename;
>     memcpy(req->callback, cb, sizeof(zval));
>     memcpy(req->filename, filename, sizeof(zval));
> #else
>     req->filename = filename;
>     req->callback = cb;
> #endif
>     req->file_content = fcnt;
>     req->once = 0;
>     req->type = SW_AIO_READ;
>     req->content_length = buf_size;
>     req->offset = offset;
> 
>     sw_zval_add_ref(&cb);
>     sw_zval_add_ref(&filename);
494,495c374,377
< 	swHashMap_add_int(php_swoole_aio_request, ret, req);
< 	RETURN_TRUE;
---
>     swHashMap_add_int(php_swoole_aio_request, fd, req);
>     php_swoole_check_aio();
>     SW_CHECK_RETURN(SwooleAIO.read(fd, fcnt, buf_size, offset));
>     RETURN_TRUE;
500,572c382,383
< 	zval *callback = NULL;
< 	zval *filename = NULL;
< 	char *fcnt = NULL;
< 	zend_size_t fcnt_len = 0;
< 	off_t offset = -1;
< 
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zs|lz", &filename, &fcnt, &fcnt_len, &offset, &callback))
< 	{
< 		return;
< 	}
< 
< 	uint32_t maxBuflen = SwooleAIO.buf_max_len > 0? SwooleAIO.buf_max_len:SW_FILE_MAX_LEN_ONCE;
< 	if (fcnt_len <= 0 || fcnt_len > maxBuflen || !fcnt)
< 	{
< 		swWarn("user set data buffer must between 0~%d, and user buffer can not be null",maxBuflen);
< 		RETURN_FALSE;
< 	}
< 
< 	if (callback && !ZVAL_IS_NULL(callback) && swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	convert_to_string(filename);
< 
< 	long fd = -1;
< 	int open_flag = O_WRONLY | O_CREAT;
< 	open_flag |= (SwooleAIO.mode == SW_AIO_LINUX)? O_DIRECT:0;
< 	open_flag |= (offset < 0)? O_APPEND:0;
< 
< 	fd = open(Z_STRVAL_P(filename), open_flag, 0644);
< 	if (fd < 0)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "open(%s, %d) failed. Error: %s[%d]", Z_STRVAL_P(filename), open_flag, strerror(errno), errno);
< 		RETURN_FALSE;
< 	}
< 
< 	offset = (offset < 0)? 0:offset;
< 
< 	file_request *req = emalloc(sizeof(file_request));
< 	char *wt_cnt = swoole_aio_malloc(fcnt_len + 1);
< 	req->fd = fd;
< 	req->content = wt_cnt;
< 	req->once = 0;
< 	req->type = SW_AIO_WRITE;
< 	req->length = fcnt_len;
< 	req->offset = offset;
< 
< 	memcpy(wt_cnt, fcnt, fcnt_len);
< 	php_swoole_check_aio();
< 
< 	int ret = SwooleAIO.write(fd, wt_cnt, fcnt_len, offset);
< 	if (ret < 0)
< 	{
< 
< 		close(fd);
< 		swoole_aio_free(wt_cnt);
< 		swoole_efree(req);
< 		RETURN_FALSE;
< 	}
< 
< 	req->filename = filename;
< 	sw_zval_add_ref(&filename);
< 	sw_copy_to_stack(req->filename, req->_filename);
< 
< 	if (swoole_check_callable(callback) >= 0)
< 	{
< 		req->callback = callback;
< 		sw_zval_add_ref(&callback);
< 		sw_copy_to_stack(req->callback, req->_callback);
< 	}
< 	else
< 		req->callback = NULL;
---
>     zval *cb = NULL;
>     zval *filename;
574,576c385,388
< 	swHashMap_add_int(php_swoole_aio_request, ret, req);
< 	RETURN_TRUE;
< }
---
>     char *fcnt;
>     zend_size_t fcnt_len = 0;
>     int fd;
>     off_t offset = -1;
578,581c390
< PHP_FUNCTION(swoole_async_set)
< {
<     zval *zset = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zs|lz", &filename, &fcnt, &fcnt_len, &offset, &cb) == FAILURE)
584a394,397
>     convert_to_string(filename);
> 
>     char *wt_cnt;
>     int open_flag = O_WRONLY | O_CREAT;
586,588c399
<     zval *value = NULL ;
<     HashTable *vht = Z_ARRVAL_P(zset);
<     if (php_swoole_array_get_value(vht, "aio_mode", value))
---
>     if (SwooleAIO.mode == SW_AIO_LINUX)
590,591c401,406
<         convert_to_long(value);
<         SwooleAIO.mode = (uint8_t) Z_LVAL_P(value);
---
>         if (posix_memalign((void **) &wt_cnt, sysconf(_SC_PAGESIZE), fcnt_len))
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "posix_memalign failed. Error: %s[%d]", strerror(errno), errno);
>             RETURN_FALSE;
>         }
>         open_flag |= O_DIRECT;
593,595c408
< 
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "thread_num", value))
---
>     else
597,598c410,411
<         convert_to_long(value);
<         SwooleAIO.thread_num = (uint8_t) Z_LVAL_P(value);
---
>         wt_cnt = fcnt;
>         wt_cnt = emalloc(fcnt_len);
601,602c414,416
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "enable_signalfd", value))
---
>     file_request *req = swHashMap_find(php_swoole_open_files, Z_STRVAL_P(filename), Z_STRLEN_P(filename));
> 
>     if (req == NULL)
604,606c418,465
<         convert_to_boolean(value);
<         SwooleG.use_signalfd = Z_BVAL_P(value);
<     }
---
>         fd = open(Z_STRVAL_P(filename), open_flag, 0644);
>         if (fd < 0)
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "open file failed. Error: %s[%d]", strerror(errno), errno);
>             RETURN_FALSE;
>         }
> 
>         file_request *req = emalloc(sizeof(file_request));
>         req->fd = fd;
> #if PHP_MAJOR_VERSION >= 7
>         req->filename = &req->_filename;
>         memcpy(req->filename, filename, sizeof(zval));
>         if (cb)
>         {
>             req->callback = &req->_callback;
>             memcpy(req->callback, cb, sizeof(zval));
>         }
> #else
>         req->filename = filename;
>         req->callback = cb;
> #endif
>         req->file_content = wt_cnt;
>         req->once = 0;
>         req->type = SW_AIO_WRITE;
>         req->content_length = fcnt_len;
> 
>         sw_zval_add_ref(&filename);
> 
>         if (offset < 0)
>         {
>             struct stat file_stat;
>             if (fstat(fd, &file_stat) < 0)
>             {
>                 php_error_docref(NULL TSRMLS_CC, E_WARNING, "fstat() failed. Error: %s[%d]", strerror(errno), errno);
>                 RETURN_FALSE;
>             }
>             offset = file_stat.st_size;
>             req->offset = offset + fcnt_len;
>         }
>         else
>         {
>             req->offset = 0;
>         }
> 
>         if (cb != NULL)
>         {
>             sw_zval_add_ref(&cb);
>         }
608,609c467,470
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "socket_buffer_size", value))
---
>         swHashMap_add_int(php_swoole_aio_request, fd, req);
>         swHashMap_add(php_swoole_open_files, Z_STRVAL_P(filename), Z_STRLEN_P(filename), req);
>     }
>     else
611,614c472,477
<         convert_to_long(value);
<         int valueSize = Z_LVAL_P(value);
<         valueSize = (valueSize <= 0 || valueSize > SW_MAX_INT)? SW_MAX_INT:valueSize;
<         SwooleG.socket_buffer_size = valueSize;
---
>         if (offset < 0)
>         {
>             offset = req->offset;
>             req->offset += fcnt_len;
>         }
>         fd = req->fd;
617,618c480,497
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "socket_dontwait", value))
---
>     //swTrace("buf_len=%d|addr=%p", buf_len, fcnt);
>     //swTrace("pagesize=%d|st_size=%d", sysconf(_SC_PAGESIZE), buf_len);
> 
>     memcpy(wt_cnt, fcnt, fcnt_len);
> 
>     php_swoole_check_aio();
>     SW_CHECK_RETURN(SwooleAIO.write(fd, wt_cnt, fcnt_len, offset));
>     RETURN_TRUE;
> }
> 
> PHP_FUNCTION(swoole_async_readfile)
> {
>     zval *cb;
>     zval *filename;
> 
>     int open_flag = O_RDONLY;
> 
>     if (SwooleAIO.mode == SW_AIO_LINUX)
620,621c499
<         convert_to_boolean(value);
<         SwooleG.socket_dontwait = Z_BVAL_P(value);
---
>         open_flag |=  O_DIRECT;
624,625c502
<     value = NULL;
<     if (php_swoole_array_get_value(vht,"aio_max_buffer",value))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &filename, &cb) == FAILURE)
627,628c504
<     	convert_to_long(value);
<     	SwooleAIO.buf_max_len = Z_LVAL_P(value);
---
>         return;
629a506
>     convert_to_string(filename);
631,632c508,515
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "disable_dns_cache", value))
---
>     int fd = open(Z_STRVAL_P(filename), open_flag, 0644);
>     if (fd < 0)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "open file[%s] failed. Error: %s[%d]", Z_STRVAL_P(filename), strerror(errno), errno);
>         RETURN_FALSE;
>     }
>     struct stat file_stat;
>     if (fstat(fd, &file_stat) < 0)
634,635c517,518
<         convert_to_boolean(value);
<         SwooleG.disable_dns_cache = Z_BVAL_P(value);
---
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "fstat failed. Error: %s[%d]", strerror(errno), errno);
>         RETURN_FALSE;
637,639c520
< 
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "dns_lookup_random", value))
---
>     if (file_stat.st_size <= 0)
641,642c522,523
<         convert_to_boolean(value);
<         SwooleG.dns_lookup_random = Z_BVAL_P(value);
---
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "file is empty.");
>         RETURN_FALSE;
643a525,533
>     if (file_stat.st_size > SW_AIO_MAX_FILESIZE)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING,    "file_size[size=%ld|max_size=%d] is too big. Please use swoole_async_read.",
>                 (long int) file_stat.st_size, SW_AIO_MAX_FILESIZE);
>         RETURN_FALSE;
>     }
> 
>     void *fcnt;
>     int buf_len;
645,648c535,544
< #if defined(HAVE_REUSEPORT) && defined(HAVE_EPOLL)
<     //reuse port
<     value = NULL;
<     if (php_swoole_array_get_value(vht, "enable_reuse_port", value))
---
>     if (SwooleAIO.mode == SW_AIO_LINUX)
>     {
>         buf_len = file_stat.st_size + (sysconf(_SC_PAGESIZE) - (file_stat.st_size % sysconf(_SC_PAGESIZE)));
>         if (posix_memalign((void **) &fcnt, sysconf(_SC_PAGESIZE), buf_len + 1))
>         {
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "posix_memalign failed. Error: %s[%d]", strerror(errno), errno);
>             RETURN_FALSE;
>         }
>     }
>     else
650,651c546,548
<         convert_to_boolean(value);
<         if (swoole_version_compare(SwooleG.uname.release, "3.9.0") >= 0)
---
>         buf_len = file_stat.st_size;
>         fcnt = emalloc(buf_len + 1);
>         if (fcnt == NULL)
653c550,551
<             SwooleG.reuse_port = Z_BVAL_P(value)? 1:SwooleG.reuse_port;
---
>             php_error_docref(NULL TSRMLS_CC, E_WARNING, "malloc failed. Error: %s[%d]", strerror(errno), errno);
>             RETURN_FALSE;
655a554,564
> 
>     file_request *req = emalloc(sizeof(file_request));
>     req->fd = fd;
> #if PHP_MAJOR_VERSION >= 7
>     req->callback =  &req->_callback;
>     req->filename = &req->_filename;
>     memcpy(req->callback, cb, sizeof(zval));
>     memcpy(req->filename, filename, sizeof(zval));
> #else
>     req->filename = filename;
>     req->callback = cb;
656a566,578
>     req->file_content = fcnt;
>     req->once = 1;
>     req->type = SW_AIO_READ;
>     req->content_length = file_stat.st_size;
>     req->offset = 0;
> 
>     sw_zval_add_ref(&cb);
>     sw_zval_add_ref(&filename);
> 
>     swHashMap_add_int(php_swoole_aio_request, fd, req);
> 
>     php_swoole_check_aio();
>     SW_CHECK_RETURN(SwooleAIO.read(fd, fcnt, buf_len, 0));
659c581
< PHP_FUNCTION(swoole_async_dns_lookup)
---
> PHP_FUNCTION(swoole_async_writefile)
661,663c583,594
< 	zval *domain = NULL;
<     zval *callback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &domain, &callback))
---
>     zval *cb = NULL;
>     zval *filename;
>     char *fcnt;
>     zend_size_t fcnt_len;
> 
> #ifdef HAVE_LINUX_NATIVE_AIO
>     int open_flag = O_CREAT | O_WRONLY | O_DIRECT;
> #else
>     int open_flag = O_CREAT | O_WRONLY;
> #endif
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zs|z", &filename, &fcnt, &fcnt_len, &cb) == FAILURE)
667,668c598,619
< 
<     if (Z_TYPE_P(domain) != IS_STRING || !Z_STRLEN_P(domain))
---
>     if (fcnt_len <= 0)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "file is empty.");
>         RETURN_FALSE;
>     }
>     if (fcnt_len > SW_AIO_MAX_FILESIZE)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING,    "file_size[size=%d|max_size=%d] is too big. Please use swoole_async_read.",
>                 fcnt_len, SW_AIO_MAX_FILESIZE);
>         RETURN_FALSE;
>     }
>     convert_to_string(filename);
>     int fd = open(Z_STRVAL_P(filename), open_flag, 0644);
>     if (fd < 0)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "open file failed. Error: %s[%d]", strerror(errno), errno);
>         RETURN_FALSE;
>     }
>     char *wt_cnt;
> #ifdef SW_AIO_LINUX_NATIVE
>     fcnt_len = fcnt_len + (sysconf(_SC_PAGESIZE) - (fcnt_len % sysconf(_SC_PAGESIZE)));
>     if (posix_memalign((void **)&wt_cnt, sysconf(_SC_PAGESIZE), fcnt_len))
670c621
<         swWarn("domain must be string type ,and not empty.");
---
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "posix_memalign failed. Error: %s[%d]", strerror(errno), errno);
672a624,684
> #else
>     wt_cnt = emalloc(fcnt_len);
> #endif
> 
>     file_request *req = emalloc(sizeof(file_request));
> 
>     req->fd = fd;
> #if PHP_MAJOR_VERSION >= 7
>     req->filename = &req->_filename;
>     memcpy(req->filename, filename, sizeof(zval));
>     if (cb)
>     {
>         req->callback = &req->_callback;
>         memcpy(req->callback, cb, sizeof(zval));
>     }
> #else
>     req->filename = filename;
>     req->callback = cb;
> #endif
>     req->type = SW_AIO_WRITE;
>     req->file_content = wt_cnt;
>     req->once = 1;
>     req->content_length = fcnt_len;
>     req->offset = 0;
> 
>     sw_zval_add_ref(&filename);
>     if (req->callback != NULL)
>     {
>         sw_zval_add_ref(&req->callback);
>     }
> 
>     swHashMap_add_int(php_swoole_aio_request, fd, req);
>     memcpy(wt_cnt, fcnt, fcnt_len);
> 
>     php_swoole_check_aio();
>     SW_CHECK_RETURN(SwooleAIO.write(fd, wt_cnt, fcnt_len, 0));
> }
> 
> PHP_FUNCTION(swoole_async_set)
> {
>     zval *zset = NULL;
>     HashTable *vht;
>     zval *v;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset) == FAILURE)
>     {
>         return;
>     }
> 
>     vht = Z_ARRVAL_P(zset);
>     if (sw_zend_hash_find(vht, ZEND_STRS("aio_mode"), (void **)&v) == SUCCESS)
>     {
>         convert_to_long(v);
>         SwooleAIO.mode = (uint8_t) Z_LVAL_P(v);
>     }
> 
>     if (sw_zend_hash_find(vht, ZEND_STRS("thread_num"), (void **)&v) == SUCCESS)
>     {
>         convert_to_long(v);
>         SwooleAIO.thread_num = (uint8_t) Z_LVAL_P(v);
>     }
674c686
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("enable_signalfd"), (void **) &v) == SUCCESS)
676,677c688,689
<     	swWarn("async dns lookup callback error.");
<     	RETURN_FALSE;
---
>         convert_to_boolean(v);
>         SwooleG.use_signalfd = Z_BVAL_P(v);
680,681c692
<     /// 从缓存中获取到，立即返回
<     if (swoole_gethost_from_cache(domain,callback) == SW_OK)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("socket_buffer_size"), (void **) &v) == SUCCESS)
683c694,718
<         return ;
---
>         convert_to_long(v);
>         SwooleG.socket_buffer_size = Z_LVAL_P(v);
>     }
> 
>     if (sw_zend_hash_find(vht, ZEND_STRS("socket_dontwait"), (void **) &v) == SUCCESS)
>     {
>         convert_to_boolean(v);
>         SwooleG.socket_dontwait = Z_BVAL_P(v);
>     }
> }
> 
> PHP_FUNCTION(swoole_async_dns_lookup)
> {
>     zval *domain;
>     zval *cb;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &domain, &cb) == FAILURE)
>     {
>         return;
>     }
> 
>     if (Z_STRLEN_P(domain) == 0)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "domain name empty.");
>         RETURN_FALSE;
687,689d721
<     req->callback = callback;
<     sw_copy_to_stack(req->callback, req->_callback);
<     sw_zval_add_ref(&req->callback);
690a723,729
> #if PHP_MAJOR_VERSION >= 7
>     req->callback = &req->_callback;
>     req->domain = &req->_domain;
>     memcpy(req->callback, cb, sizeof(zval));
>     memcpy(req->domain, domain, sizeof(zval));
> #else
>     req->callback = cb;
692c731,733
<     sw_copy_to_stack(req->domain, req->_domain);
---
> #endif
> 
>     sw_zval_add_ref(&req->callback);
695c736,744
<     int buf_size = (Z_STRLEN_P(domain) < SW_IP_MAX_LENGTH)? SW_IP_MAX_LENGTH + 1:Z_STRLEN_P(domain) + 1;
---
>     int buf_size;
>     if (Z_STRLEN_P(domain) < SW_IP_MAX_LENGTH)
>     {
>         buf_size = SW_IP_MAX_LENGTH + 1;
>     }
>     else
>     {
>         buf_size = Z_STRLEN_P(domain) + 1;
>     }
697d745
<     int flag = SwooleG.disable_dns_cache? (AF_INET|SW_DNS_LOOKUP_NOCACHE):AF_INET;
703c751
<     SW_CHECK_RETURN(swAio_dns_lookup(flag,req, buf, buf_size));
---
>     SW_CHECK_RETURN(swAio_dns_lookup(req, buf, buf_size));
715,720d762
< 
< PHP_FUNCTION(swoole_clean_dns_cache)
< {
<     swoole_clear_dns_cache();
< }
< 
Only in ../swoole-1.8.5-stable/: swoole_atomic.c
diff -r ./zan-extension/swoole_buffer.c ../swoole-1.8.5-stable/swoole_buffer.c
19,20d18
< static void swoole_buffer_recycle(swString *buffer);
< 
29d26
< static PHP_METHOD(swoole_buffer, recycle);
32,62d28
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_construct, 0, 0, 0)
<     ZEND_ARG_INFO(0, size)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_expand, 0, 0, 1)
<     ZEND_ARG_INFO(0, size)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_substr, 0, 0, 1)
<     ZEND_ARG_INFO(0, offset)
<     ZEND_ARG_INFO(0, length)
<     ZEND_ARG_INFO(0, seek)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_write, 0, 0, 2)
<     ZEND_ARG_INFO(0, offset)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_read, 0, 0, 2)
<     ZEND_ARG_INFO(0, offset)
<     ZEND_ARG_INFO(0, length)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_buffer_append, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< 
65,74c31,39
<     PHP_ME(swoole_buffer, __construct, arginfo_swoole_buffer_construct, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_buffer, __destruct, arginfo_swoole_buffer_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_ME(swoole_buffer, __toString, arginfo_swoole_buffer_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, substr, arginfo_swoole_buffer_substr, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, write, arginfo_swoole_buffer_write, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, read, arginfo_swoole_buffer_read, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, append, arginfo_swoole_buffer_append, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, expand, arginfo_swoole_buffer_expand, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, recycle, arginfo_swoole_buffer_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_buffer, clear, arginfo_swoole_buffer_void, ZEND_ACC_PUBLIC)
---
>     PHP_ME(swoole_buffer, __construct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
>     PHP_ME(swoole_buffer, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
>     PHP_ME(swoole_buffer, __toString, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_buffer, substr, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_buffer, write, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_buffer, read, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_buffer, append, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_buffer, expand, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_buffer, clear, NULL, ZEND_ACC_PUBLIC)
78c43
< static zend_class_entry swoole_buffer_ce;
---
> zend_class_entry swoole_buffer_ce;
85,102d49
<     zend_declare_property_long(swoole_buffer_class_entry_ptr,SW_STRL("capacity") - 1,0,ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_buffer_class_entry_ptr,SW_STRL("length") - 1,0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 
< }
< 
< static void swoole_buffer_recycle(swString *buffer)
< {
<     if (buffer->offset <= 0) {
<         return;
<     }
< 
<     long length = buffer->length - buffer->offset;
<     if (length > 0) {
<         memcpy(buffer->str, buffer->str + buffer->offset, length);
<     }
< 
<     buffer->offset = 0;
<     buffer->length = length < 0? 0:length;
108c55,56
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &size))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &size) == FAILURE)
113c61,66
<     if (size < 1 || size > SW_STRING_BUFFER_MAXLEN)
---
>     if (size < 1)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_ERROR, "buffer size cannot be less than 0");
>         RETURN_FALSE;
>     }
>     else if (size > SW_STRING_BUFFER_MAXLEN)
115c68
<         php_error_docref(NULL TSRMLS_CC, E_ERROR, "buffer size cannot be less than 0 and must not exceed %d",SW_STRING_BUFFER_MAXLEN);
---
>         php_error_docref(NULL TSRMLS_CC, E_ERROR, "buffer size must not exceed %d", SW_STRING_BUFFER_MAXLEN);
120c73
<     if (!buffer)
---
>     if (buffer == NULL)
144c97
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &str.str, &str.length))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &str.str, &str.length) == FAILURE)
148,149c101
< 
<     if (str.length < 1 || !str.str)
---
>     if (str.length < 1)
154d105
< 
156,159d106
<     if (!buffer)
<     {
<     	RETURN_FALSE;
<     }
161,162c108
<     if ((str.length + buffer->length) > buffer->size &&
<     					(str.length + buffer->length) > SW_STRING_BUFFER_MAXLEN)
---
>     if ((str.length + buffer->size) > SW_STRING_BUFFER_MAXLEN)
169c115
<     if (swString_append(buffer,&str) < 0)
---
>     if (swString_append(buffer, &str) == SW_OK)
171c117,126
<     	RETURN_FALSE;
---
>         if (buffer->size > size_old)
>         {
>             zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("capacity"), buffer->size TSRMLS_CC);
>         }
>         zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("length"), buffer->length TSRMLS_CC);
>         RETURN_LONG(buffer->length);
>     }
>     else
>     {
>         RETURN_FALSE;
173,180d127
< 
<     if (buffer->size > size_old)
< 	{
< 		zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("capacity"), buffer->size TSRMLS_CC);
< 	}
< 
< 	zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("length"), buffer->length TSRMLS_CC);
< 	RETURN_LONG(buffer->length);
189c136
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|lb", &offset, &length, &seek))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|lb", &offset, &length, &seek) == FAILURE)
193d139
< 
195c141,142
<     if (!buffer)
---
> 
>     if (seek && !(offset == 0 && length < buffer->length))
197c144,148
<     	RETURN_FALSE;
---
>         seek = 0;
>     }
>     if (offset < 0)
>     {
>         offset = buffer->length + offset;
199,201d149
< 
<     seek = (seek && !(offset == 0 && length <= buffer->length))? 0:seek;
<     offset = (offset < 0)? buffer->length + offset:offset;
203,204c151,154
<     length = (length < 0)? buffer->length - offset:length;
< 
---
>     if (length < 0)
>     {
>         length = buffer->length - offset;
>     }
210,211d159
< 	
< 	SW_RETVAL_STRINGL(buffer->str + offset, length, 1);
216,223c164
<                 											buffer->length - buffer->offset TSRMLS_CC);
< 				
<         if (buffer->offset > SW_STRING_BUFFER_GARBAGE_MIN &&
<         		buffer->offset * SW_STRING_BUFFER_GARBAGE_RATIO > buffer->size)
<         {
< 			// Do recycle when the garbage is to large.
< 			swoole_buffer_recycle(buffer);
<         }
---
>                 buffer->length - buffer->offset TSRMLS_CC);
225,226c166
< 	
< 	return;
---
>     SW_RETURN_STRINGL(buffer->str + offset, length, 1);
232,236d171
<     if (!buffer)
<     {
<     	RETURN_FALSE;
<     }
< 
243,248c178,179
<     char *new_str = NULL;
<     zend_size_t length = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ls", &offset, &new_str, &length))
<     {
<         RETURN_FALSE;
<     }
---
>     char *new_str;
>     zend_size_t length;
250c181
<     if (!new_str || length < 1)
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ls", &offset, &new_str, &length) == FAILURE)
252,253c183
<     	php_error_docref(NULL TSRMLS_CC, E_WARNING, "string empty.");
<     	RETURN_FALSE;
---
>         RETURN_FALSE;
255d184
< 
257,262d185
<     if (!buffer)
<     {
<     	RETURN_FALSE;
<     }
< 
<     offset = (offset < 0)? buffer->length - buffer->offset + offset:offset;
265,266c188
<     	php_error_docref(NULL TSRMLS_CC, E_WARNING, "offset(%ld) out of bounds.", offset);
<     	RETURN_FALSE;
---
>         offset = buffer->length + offset;
268d189
< 
270,279c191
< 
<     if ((length + offset) > buffer->size && (length + offset) > SW_STRING_BUFFER_MAXLEN)
< 	{
< 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "buffer size must not exceed %d", SW_STRING_BUFFER_MAXLEN);
< 		RETURN_FALSE;
< 	}
< 
<     size_t size_old = buffer->size;
<     int ret = swString_write_ptr(buffer, offset, new_str,length);
<     if (ret != SW_OK)
---
>     if (length > buffer->size - offset)
281c193,194
<     	RETURN_FALSE;
---
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "string is too long.");
>         RETURN_FALSE;
283,293c196,197
< 
<     if (buffer->size > size_old)
< 	{
< 		zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("capacity"),
< 																				buffer->size TSRMLS_CC);
< 	}
< 
< 	zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("length"),
< 																buffer->length - buffer->offset TSRMLS_CC);
< 
< 	RETURN_LONG(buffer->length - buffer->offset);
---
>     memcpy(buffer->str + offset, new_str, length);
>     RETURN_TRUE;
298,300c202,205
<     long offset = 0;
<     long length = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &offset, &length))
---
>     long offset;
>     long length;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &offset, &length) == FAILURE)
304d208
< 
306c210
<     if (!buffer)
---
>     if (offset < 0)
308c212,218
<     	RETURN_FALSE;
---
>         offset = buffer->length + offset;
>     }
>     offset += buffer->offset;
>     if (length > buffer->size - offset)
>     {
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "no enough data.");
>         RETURN_FALSE;
310,323d219
< 
<     offset = (offset < 0)? buffer->length - buffer->offset + offset:offset;
< 	if (offset < 0)
< 	{
< 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "offset(%ld) out of bounds.", offset);
< 		RETURN_FALSE;
< 	}
< 
< 	offset += buffer->offset;
< 	if (length > buffer->length - offset)
< 	{
< 		RETURN_FALSE;
< 	}
< 
330c226
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &size))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &size) == FAILURE)
334d229
< 
336,341c231
<     if (!buffer)
<     {
<     	RETURN_FALSE;
<     }
< 
<     if (size <= buffer->size || size > SW_STRING_BUFFER_MAXLEN)
---
>     if (size <= buffer->size)
343,344c233
<         php_error_docref(NULL TSRMLS_CC, E_WARNING, "new size must more than %ld and need less than %d",
<         														buffer->size,SW_STRING_BUFFER_MAXLEN);
---
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "new size must more than %ld", buffer->size);
347,353d235
< 
<     int iret = swString_extend(buffer, size);
<     if (iret != SW_OK)
<     {
<     	RETURN_FALSE;
<     }
< 
355,368c237
<     RETURN_TRUE;
< }
< 
< static PHP_METHOD(swoole_buffer, recycle)
< {
<     swString *buffer = swoole_get_object(getThis());
<     if (!buffer)
<     {
<     	return;
<     }
< 
<     swoole_buffer_recycle(buffer);
< 
<     zend_update_property_long(swoole_buffer_class_entry_ptr, getThis(), ZEND_STRL("length"), buffer->length TSRMLS_CC);
---
>     SW_CHECK_RETURN(swString_extend(buffer, size));
374,378d242
<     if (!buffer)
<     {
<     	return;
<     }
< 
diff -r ./zan-extension/swoole_client.c ../swoole-1.8.5-stable/swoole_client.c
18,19d17
< #include "swWork.h"
< #include "swBaseOperator.h"
29,37d26
<     zval* onTimeout;
< #if PHP_MAJOR_VERSION >= 7
<     zval _object;
<     zval _onConnect;
< 	zval _onReceive;
< 	zval _onClose;
< 	zval _onError;
< 	zval _onTimeout;
< #endif
48,60d36
< static int 				swoole_client_ce_inited = 0;
< 
< static zend_class_entry swoole_client_ce;
< zend_class_entry *swoole_client_class_entry_ptr = NULL;
< 
< static void tcpClient_timeout(swTimer* timer,swTimer_node* node);
< static void client_execute_callback(swClient *cli, enum client_callback_type type);
< static void client_onConnect(swClient *cli);
< static void client_onReceive(swClient *cli, char *data, uint32_t length);
< static int  client_onPackage(swConnection *conn, char *data, uint32_t length);
< static void client_onClose(swClient *cli);
< static void client_onError(swClient *cli);
< 
64,65d39
< static PHP_METHOD(swoole_client,setConnectTimeout);
< static PHP_METHOD(swoole_client,setSendTimeout);
78,131d51
< static PHP_METHOD(swoole_client, getSocket);
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_construct, 0, 0, 1)
<     ZEND_ARG_INFO(0, type)
<     ZEND_ARG_INFO(0, async)
<     ZEND_ARG_INFO(0, id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_setTimeout, 0, 0, 1)
<     ZEND_ARG_INFO(0,timeout)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_set, 0, 0, 1)
<     ZEND_ARG_ARRAY_INFO(0, settings, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_connect, 0, 0, 2)
<     ZEND_ARG_INFO(0, host)
<     ZEND_ARG_INFO(0, port)
<     ZEND_ARG_INFO(0, timeout)
<     ZEND_ARG_INFO(0, sock_flag)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_recv, 0, 0, 0)
<     ZEND_ARG_INFO(0, size)
<     ZEND_ARG_INFO(0, flag)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_send, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
<     ZEND_ARG_INFO(0, flag)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_sendfile, 0, 0, 1)
<     ZEND_ARG_INFO(0, filename)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_sendto, 0, 0, 3)
<     ZEND_ARG_INFO(0, ip)
<     ZEND_ARG_INFO(0, port)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_close, 0, 0, 0)
<     ZEND_ARG_INFO(0, force)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_client_on, 0, 0, 2)
<     ZEND_ARG_INFO(0, event_name)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
132a53,55
> #ifdef SWOOLE_SOCKETS_SUPPORT
> static PHP_METHOD(swoole_client, getSocket);
> #endif
134d56
< static void client_free_callback(zval *object);
137d58
< static void client_check_setting(swClient *cli, zval *zset TSRMLS_DC);
139,160c60,64
< static const zend_function_entry swoole_client_methods[] =
< {
<     PHP_ME(swoole_client, __construct, arginfo_swoole_client_construct, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_client, __destruct, arginfo_swoole_client_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_ME(swoole_client, set, arginfo_swoole_client_set, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_client, setSendTimeout, arginfo_swoole_client_setTimeout, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_client, setConnectTimeout,arginfo_swoole_client_setTimeout, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, connect, arginfo_swoole_client_connect, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, recv, arginfo_swoole_client_recv, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, send, arginfo_swoole_client_send, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, sendfile, arginfo_swoole_client_sendfile, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, sendto, arginfo_swoole_client_sendto, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, sleep, arginfo_swoole_client_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, wakeup, arginfo_swoole_client_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, isConnected, arginfo_swoole_client_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, getsockname, arginfo_swoole_client_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, getpeername, arginfo_swoole_client_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, close, arginfo_swoole_client_close, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, on, arginfo_swoole_client_on, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_client, getSocket, arginfo_swoole_client_void, ZEND_ACC_PUBLIC)
<     PHP_FE_END
< };
---
> static void client_onConnect(swClient *cli);
> static void client_onReceive(swClient *cli, char *data, uint32_t length);
> static int client_onPackage(swConnection *conn, char *data, uint32_t length);
> static void client_onClose(swClient *cli);
> static void client_onError(swClient *cli);
162c66
< static sw_inline void defer_close(void* data)
---
> static sw_inline void client_free_callback(zval *object)
164,166c68,100
< 	swClient* cli = (swClient*)data;
< 	cli->released = 0;
< 	client_onClose(cli);
---
>     //free memory
>     client_callback *cb = swoole_get_property(object, 0);
>     if (!cb)
>     {
>         return;
>     }
> 
>     if (cb->onConnect)
>     {
>         sw_zval_ptr_dtor(&cb->onConnect);
>     }
>     if (cb->onReceive)
>     {
>         sw_zval_ptr_dtor(&cb->onReceive);
>     }
>     if (cb->onError)
>     {
>         sw_zval_ptr_dtor(&cb->onError);
>     }
>     if (cb->onClose)
>     {
>         sw_zval_ptr_dtor(&cb->onClose);
>     }
> 
> #if PHP_MAJOR_VERSION >= 7
>     swoole_efree(cb->onConnect);
>     swoole_efree(cb->onReceive);
>     swoole_efree(cb->onError);
>     swoole_efree(cb->onClose);
> #endif
> 
>     efree(cb);
>     swoole_set_property(object, 0, NULL);
169c103
< static void client_execute_callback(swClient *cli, enum client_callback_type type)
---
> static sw_inline void client_execute_callback(swClient *cli, enum client_callback_type type)
171c105,107
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
173,177d108
<     zval *zobject = cli->object;
<     if (!zobject)
<     {
<     		return;
<     }
180c111,113
<     char *callback_name = NULL;
---
>     zval *retval = NULL;
>     zval **args[1];
>     zval *zobject = cli->object;
182c115,116
<     client_callback *cb = swoole_get_property(zobject, swoole_property_common);
---
>     client_callback *cb = swoole_get_property(zobject, 0);
>     char *callback_name;
187c121
<         callback = (!cb)? NULL:cb->onConnect;
---
>         callback = cb->onConnect;
191c125
<         callback = (!cb)? NULL:cb->onError;
---
>         callback = cb->onError;
195c129
<         callback = (!cb)? NULL:cb->onClose;
---
>         callback = cb->onClose;
202c136
<     if (!callback || ZVAL_IS_NULL(callback))
---
>     if (callback == NULL || ZVAL_IS_NULL(callback))
204c138
<         swWarn("object have not %s callback.", callback_name);
---
>         swoole_php_fatal_error(E_WARNING, "object have not %s callback.", callback_name);
208d141
<     zval **args[1];
210,211c143
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
213c145,146
<         swWarn("%s handler error.", callback_name);
---
>         swoole_php_fatal_error(E_WARNING, "%s handler error.", callback_name);
>         return;
215d147
< 
220d151
< 
227,277c158
< static void tcpClient_timeout(swTimer* timer,swTimer_node* node)
< {
< 	swClient* cli = node? node->data:NULL;
< 	uint8_t timer_type = cli? cli->timeout_type:SW_CLIENT_INVAILED_TIMEOUT;
< 	if (timer_type == SW_CLIENT_CONNECT_TIMEOUT || timer_type == SW_CLIENT_RECV_TIMEOUT)
< 	{
< 		cli->timer_id = 0;
< 		zval *zobject = cli->object;
< 		client_callback *cb = zobject? swoole_get_property(zobject, swoole_property_common):NULL;
< 		if (cb && cb->onTimeout)
< 		{
< 			zval* callback = cb->onTimeout;
< 			zval* eventType = NULL;
< 			SW_MAKE_STD_ZVAL(eventType);
< 			ZVAL_LONG(eventType,timer_type);
< 			zval **args[2];
< 			args[0] = &zobject;
< 			args[1] = &eventType;
< 			zval *retval = NULL;
< 			if (sw_call_user_function_ex(EG(function_table), NULL,callback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
< 			{
< 				swWarn("timeout event handler error.");
< 			}
< 
< 			if (EG(exception))
< 			{
< 				zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 			}
< 
< 			if (retval) sw_zval_ptr_dtor(&retval);
< 			if (eventType) sw_zval_ptr_dtor(&eventType);
< 		}
< 	}
< 
< 	swTimer_del(timer,node->id);
< }
< 
< static void client_onConnect(swClient *cli)
< {
< 	if (cli && cli->timer_id > 0)
< 	{
< 		long timer_id = cli->timer_id;
< 		cli->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
< 	if (cli->object)
< 	{
< 		client_execute_callback(cli, SW_CLIENT_CALLBACK_onConnect);
< 	}
< }
---
> static void client_check_setting(swClient *cli, zval *zset TSRMLS_DC);
279c160
< static void client_onClose(swClient *cli)
---
> static const zend_function_entry swoole_client_methods[] =
281,287c162,181
<     SWOOLE_FETCH_TSRMLS;
<     if (cli && cli->timer_id > 0)
< 	{
< 		long timer_id = cli->timer_id;
< 		cli->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
---
>     PHP_ME(swoole_client, __construct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
>     PHP_ME(swoole_client, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
>     PHP_ME(swoole_client, set, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, connect, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, recv, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, send, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, sendfile, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, sendto, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, sleep, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, wakeup, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, isConnected, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, getsockname, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, getpeername, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, close, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_client, on, NULL, ZEND_ACC_PUBLIC)
> #ifdef SWOOLE_SOCKETS_SUPPORT
>     PHP_ME(swoole_client, getSocket, NULL, ZEND_ACC_PUBLIC)
> #endif
>     PHP_FE_END
> };
289,292c183
<     if (cli->released)
<     {
<     		return;
<     }
---
> static swHashMap *php_sw_long_connections;
294,295c185,186
<     zval *zobject = cli->object;
<     cli->released = 1;
---
> zend_class_entry swoole_client_ce;
> zend_class_entry *swoole_client_class_entry_ptr;
297,298c188,191
<     if (zobject){
< 		client_execute_callback(cli, SW_CLIENT_CALLBACK_onClose);
---
> void swoole_client_init(int module_number TSRMLS_DC)
> {
>     SWOOLE_INIT_CLASS_ENTRY(swoole_client_ce, "swoole_client", "Swoole\\Client", swoole_client_methods);
>     swoole_client_class_entry_ptr = zend_register_internal_class(&swoole_client_ce TSRMLS_CC);
300,308c193,195
< 		client_free_callback(zobject);
< 		if (cli->object)
< 		{
< 			zval* obj = cli->object;
< 			cli->object = NULL;
< 			sw_zval_ptr_dtor(&obj);
< 		}
<     }
< }
---
>     zend_declare_property_long(swoole_client_class_entry_ptr, SW_STRL("errCode")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
>     zend_declare_property_long(swoole_client_class_entry_ptr, SW_STRL("sock")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
>     zend_declare_property_bool(swoole_client_class_entry_ptr, SW_STRL("reuse")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
310,323c197
< static void client_onError(swClient *cli)
< {
<     SWOOLE_FETCH_TSRMLS;
<     if (cli && cli->timer_id > 0)
< 	{
< 		long timer_id = cli->timer_id;
< 		cli->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
<     if (cli->released)
< 	{
< 		return;
< 	}
---
>     php_sw_long_connections = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, NULL);
325,338c199,202
<     zval *zobject = cli->object;
<     cli->released = 1;
<     if (zobject){
< 		zend_update_property_long(swoole_client_class_entry_ptr, zobject, ZEND_STRL("errCode"), SwooleG.error TSRMLS_CC);
< 		client_execute_callback(cli, SW_CLIENT_CALLBACK_onError);
< 
< 		client_free_callback(zobject);
< 		if (cli->object)
< 		{
< 			zval* obj = cli->object;
< 			cli->object = NULL;
< 			sw_zval_ptr_dtor(&obj);
< 		}
< 	}
---
>     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_OOB"), MSG_OOB TSRMLS_CC);
>     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_PEEK"), MSG_PEEK TSRMLS_CC);
>     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_DONTWAIT"), MSG_DONTWAIT TSRMLS_CC);
>     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_WAITALL"), MSG_WAITALL TSRMLS_CC);
349,361c213,215
<     SWOOLE_FETCH_TSRMLS;
<     if (cli && cli->timer_id > 0)
< 	{
< 		long timer_id = cli->timer_id;
< 		cli->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
<     zval *zobject = cli? cli->object:NULL;
<     if (!zobject)
<     {
<     	   return ;
<     }
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
362a217
>     zval *zobject = cli->object;
365c220
<     zval *retval = NULL;
---
>     zval *retval;
367c222
<     zval *zdata = NULL;
---
>     zval *zdata;
370d224
<     sw_zval_add_ref(&zobject);
375,379c229,231
<     client_callback *cb = swoole_get_property(zobject, swoole_property_common);
< 	zcallback = (!cb)? NULL:cb->onReceive;
< 
<     if (zcallback &&
<     		sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     client_callback *cb = swoole_get_property(zobject, 0);
>     zcallback = cb->onReceive;
>     if (zcallback == NULL || ZVAL_IS_NULL(zcallback))
381c233,234
<         swWarn("onReactorCallback handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_client object have not receive callback.");
>         goto free_zdata;
383a237,241
>     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_WARNING, "onReactorCallback handler error");
>         goto free_zdata;
>     }
388,389c246
< 
<     if (retval)
---
>     if (retval != NULL)
393,412c250,251
< 
<     if (zdata) {
<         sw_zval_ptr_dtor(&zdata);
<     }
< 
<     sw_zval_ptr_dtor(&zobject);
< }
< 
< static void client_free_callback(zval* object)
< {
< 	client_callback *cb = swoole_get_property(object, swoole_property_common);
<     if (cb && cb->onConnect)  {sw_zval_ptr_dtor(&cb->onConnect);cb->onConnect = NULL;}
< 
<     if (cb && cb->onReceive) {sw_zval_ptr_dtor(&cb->onReceive);cb->onReceive = NULL;}
< 
<     if (cb && cb->onError) {sw_zval_ptr_dtor(&cb->onError);cb->onError = NULL;}
< 
<     if (cb && cb->onClose) {sw_zval_ptr_dtor(&cb->onClose);cb->onClose = NULL;}
< 
<     if (cb && cb->onTimeout) {sw_zval_ptr_dtor(&cb->onTimeout);cb->onTimeout = NULL;}
---
>     free_zdata:
>     sw_zval_ptr_dtor(&zdata);
415c254
< void swoole_client_init(int module_number TSRMLS_DC)
---
> static void client_onConnect(swClient *cli)
417,439c256
< 	if (swoole_client_ce_inited){
< 		return ;
< 	}
< 
< 	swoole_client_ce_inited = 1;
< 
<     SWOOLE_INIT_CLASS_ENTRY(swoole_client_ce, "swoole_client", "Swoole\\Client", swoole_client_methods);
<     swoole_client_class_entry_ptr = zend_register_internal_class(&swoole_client_ce TSRMLS_CC);
< 
<     zend_declare_property_long(swoole_client_class_entry_ptr, SW_STRL("errCode")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_client_class_entry_ptr, SW_STRL("sock")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
< //    zend_declare_property_bool(swoole_client_class_entry_ptr, SW_STRL("reuse")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_bool(swoole_client_class_entry_ptr, SW_STRL("internal_user")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_client_class_entry_ptr, SW_STRL("connectTimeout")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_client_class_entry_ptr, SW_STRL("sendTimeout")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_client_class_entry_ptr,ZEND_STRL("type"),ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_client_class_entry_ptr,ZEND_STRL("id"),ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_client_class_entry_ptr,ZEND_STRL("setting"),ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_OOB"), MSG_OOB TSRMLS_CC);
<     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_PEEK"), MSG_PEEK TSRMLS_CC);
<     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_DONTWAIT"), MSG_DONTWAIT TSRMLS_CC);
<     zend_declare_class_constant_long(swoole_client_class_entry_ptr, ZEND_STRL("MSG_WAITALL"), MSG_WAITALL TSRMLS_CC);
---
>     client_execute_callback(cli, SW_CLIENT_CALLBACK_onConnect);
442c259
< static int client_select_wait(zval *sock_array, fd_set *fds TSRMLS_DC)
---
> static void client_onClose(swClient *cli)
444,449c261,263
<     zval *element = NULL;
<     zval *zsock = NULL;
<     zend_class_entry *ce;
< 
<     ulong_t num = 0;
<     if (SW_Z_TYPE_P(sock_array) != IS_ARRAY)
---
>     client_execute_callback(cli, SW_CLIENT_CALLBACK_onClose);
>     zval *zobject = cli->object;
>     if (!cli->released)
451c265
<         return 0;
---
>         sw_zval_ptr_dtor(&zobject);
453,543d266
< 
< #if PHP_MAJOR_VERSION < 7
<     HashTable *new_hash;
<     char *key = NULL;
<     zval **dest_element;
<     uint32_t key_len;
< 
<     ALLOC_HASHTABLE(new_hash);
<     zend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(sock_array)), NULL, ZVAL_PTR_DTOR, 0);
< 
<     SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(sock_array), element)
<         if (Z_TYPE_P(element) != IS_OBJECT)
<         {
<             swWarn("object is not swoole_client object[1].");
<             continue;
<         }
<         ce = Z_OBJCE_P(element);
<         zsock = sw_zend_read_property(ce, element, SW_STRL("sock")-1, 0 TSRMLS_CC);
<         if (zsock == NULL || ZVAL_IS_NULL(zsock))
<         {
<             swWarn("object is not swoole_client object[2].");
<             continue;
<         }
<         if ((Z_LVAL(*zsock) < FD_SETSIZE) && FD_ISSET(Z_LVAL(*zsock), fds))
<         {
<             switch (sw_zend_hash_get_current_key(Z_ARRVAL_P(sock_array), &key, &key_len, &num))
<             {
<             case HASH_KEY_IS_STRING:
<                 sw_zend_hash_add(new_hash, key, key_len, (void * ) &element, sizeof(zval *), (void ** )&dest_element);
<                 break;
<             case HASH_KEY_IS_LONG:
<                 sw_zend_hash_index_update(new_hash, num, (void * ) &element, sizeof(zval *), (void ** )&dest_element);
<                 break;
<             }
<             if (dest_element)
<             {
<                 sw_zval_add_ref(dest_element);
<             }
<         }
<         num ++;
<     SW_HASHTABLE_FOREACH_END();
< 
<     zend_hash_destroy(Z_ARRVAL_P(sock_array));
<     swoole_efree(Z_ARRVAL_P(sock_array));
< 
<     zend_hash_internal_pointer_reset(new_hash);
<     Z_ARRVAL_P(sock_array) = new_hash;
< #else
<     zval new_array;
<     array_init(&new_array);
<     zend_ulong num_key;
<     zend_string *key;
<     zval *dest_element;
< 
<     ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(sock_array), num_key, key, element)
<     {
<         if (Z_TYPE_P(element) != IS_OBJECT)
<         {
<             swWarn("object is not swoole_client object[1].");
<             continue;
<         }
<         ce = Z_OBJCE_P(element);
<         zsock = sw_zend_read_property(ce, element, SW_STRL("sock")-1, 0 TSRMLS_CC);
<         if (zsock == NULL || ZVAL_IS_NULL(zsock))
<         {
<             swWarn("object is not swoole_client object[2].");
<             continue;
<         }
< 
<         if ((Z_LVAL(*zsock) < FD_SETSIZE) && FD_ISSET(Z_LVAL(*zsock), fds))
<         {
<             if (key)
<             {
<                 dest_element = zend_hash_add(Z_ARRVAL(new_array), key, element);
<             }
<             else
<             {
<                 dest_element = zend_hash_index_update(Z_ARRVAL(new_array), num_key, element);
<             }
<             if (dest_element)
<             {
<                 Z_ADDREF_P(dest_element);
<             }
<         }
<         num++;
<     } ZEND_HASH_FOREACH_END();
< 
<     zval_ptr_dtor(sock_array);
<     ZVAL_COPY_VALUE(sock_array, &new_array);
< #endif
<     return num ? 1 : 0;
546c269
< static int client_select_add(zval *sock_array, fd_set *fds, int *max_fd TSRMLS_DC)
---
> static void client_onError(swClient *cli)
548,586c271,277
<     zval *element = NULL;
<     zval *zsock;
<     zend_class_entry *ce;
< 
<     if (SW_Z_TYPE_P(sock_array) != IS_ARRAY)
<     {
<         return 0;
<     }
< 
<     int num = 0;
<     SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(sock_array), element)
<         if (Z_TYPE_P(element) != IS_OBJECT)
<         {
<             swWarn("object is not swoole_client object[1].");
<             continue;
<         }
<         ce = Z_OBJCE_P(element);
<         zsock = sw_zend_read_property(ce, element, SW_STRL("sock")-1, 0 TSRMLS_CC);
<         if (zsock == NULL || ZVAL_IS_NULL(zsock))
<         {
<             swWarn("object is not swoole_client object[2].");
<             continue;
<         }
<         if (Z_LVAL(*zsock) < FD_SETSIZE)
<         {
<             FD_SET(Z_LVAL(*zsock), fds);
<         }
<         else
<         {
<             swWarn("socket[%ld] > FD_SETSIZE[%d].", Z_LVAL(*zsock), FD_SETSIZE);
<             continue;
<         }
<         if (Z_LVAL(*zsock) > *max_fd)
<         {
<             *max_fd = Z_LVAL(*zsock);
<         }
<         num ++;
<     SW_HASHTABLE_FOREACH_END();
<     return num ? 1 : 0;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
>     zval *zobject = cli->object;
>     zend_update_property_long(swoole_client_class_entry_ptr, zobject, ZEND_STRL("errCode"), SwooleG.error TSRMLS_CC);
>     client_execute_callback(cli, SW_CLIENT_CALLBACK_onError);
>     sw_zval_ptr_dtor(&zobject);
591c282,283
<     zval *valuePtr = NULL;
---
>     HashTable *vht;
>     zval *v;
597c289
<     HashTable *vht = Z_ARRVAL_P(zset);
---
>     vht = Z_ARRVAL_P(zset);
600,601c292,293
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_eof_split"), (void **) &valuePtr) == SUCCESS
<             || sw_zend_hash_find(vht, ZEND_STRS("open_eof_check"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_eof_split"), (void **) &v) == SUCCESS
>             || sw_zend_hash_find(vht, ZEND_STRS("open_eof_check"), (void **) &v) == SUCCESS)
603,604c295,296
<         convert_to_boolean(valuePtr);
<         cli->open_eof_check = Z_BVAL_P(valuePtr);
---
>         convert_to_boolean(v);
>         cli->open_eof_check = Z_BVAL_P(v);
608c300
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_eof"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_eof"), (void **) &v) == SUCCESS)
610,616c302,307
<         convert_to_string(valuePtr);
<         cli->protocol.package_eof_len = Z_STRLEN_P(valuePtr);
<         if (cli->protocol.package_eof_len <= SW_DATA_EOF_MAXLEN)
<         {
<         	bzero(cli->protocol.package_eof, SW_DATA_EOF_MAXLEN);
<         	memcpy(cli->protocol.package_eof, Z_STRVAL_P(valuePtr), Z_STRLEN_P(valuePtr));
<         	cli->protocol.onPackage = client_onPackage;
---
>         convert_to_string(v);
>         cli->protocol.package_eof_len = Z_STRLEN_P(v);
>         if (cli->protocol.package_eof_len > SW_DATA_EOF_MAXLEN)
>         {
>             swoole_php_fatal_error(E_ERROR, "pacakge_eof max length is %d", SW_DATA_EOF_MAXLEN);
>             return;
618c309,311
< 
---
>         bzero(cli->protocol.package_eof, SW_DATA_EOF_MAXLEN);
>         memcpy(cli->protocol.package_eof, Z_STRVAL_P(v), Z_STRLEN_P(v));
>         cli->protocol.onPackage = client_onPackage;
621c314
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_length_check"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_length_check"), (void **) &v) == SUCCESS)
623,624c316,317
<         convert_to_boolean(valuePtr);
<         cli->open_length_check = Z_BVAL_P(valuePtr);
---
>         convert_to_boolean(v);
>         cli->open_length_check = Z_BVAL_P(v);
629c322
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_type"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_type"), (void **) &v) == SUCCESS)
631,632c324,325
<         convert_to_string(valuePtr);
<         cli->protocol.package_length_type = Z_STRVAL_P(valuePtr)[0];
---
>         convert_to_string(v);
>         cli->protocol.package_length_type = Z_STRVAL_P(v)[0];
642c335
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_offset"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_offset"), (void **) &v) == SUCCESS)
644,645c337,338
<         convert_to_long(valuePtr);
<         cli->protocol.package_length_offset = (int) Z_LVAL_P(valuePtr);
---
>         convert_to_long(v);
>         cli->protocol.package_length_offset = (int) Z_LVAL_P(v);
648c341
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_body_offset"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_body_offset"), (void **) &v) == SUCCESS)
650,651c343,344
<         convert_to_long(valuePtr);
<         cli->protocol.package_body_offset = (int) Z_LVAL_P(valuePtr);
---
>         convert_to_long(v);
>         cli->protocol.package_body_offset = (int) Z_LVAL_P(v);
656c349
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_max_length"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_max_length"), (void **) &v) == SUCCESS)
658,659c351,352
<         convert_to_long(valuePtr);
<         cli->protocol.package_max_length = (int) Z_LVAL_P(valuePtr);
---
>         convert_to_long(v);
>         cli->protocol.package_max_length = (int) Z_LVAL_P(v);
668c361
<     if (sw_zend_hash_find(vht, ZEND_STRS("socket_buffer_size"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("socket_buffer_size"), (void **) &v) == SUCCESS)
670,672c363,364
<         convert_to_long(valuePtr);
<         value = (int) Z_LVAL_P(valuePtr);
<         value = (value <= 0 || value > SW_MAX_INT)? SW_MAX_INT:value;
---
>         convert_to_long(v);
>         value = (int) Z_LVAL_P(v);
679c371
<     if (sw_zend_hash_find(vht, ZEND_STRS("bind_address"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("bind_address"), (void **) &v) == SUCCESS)
681,682c373,374
<         convert_to_string(valuePtr);
<         bind_address = Z_STRVAL_P(valuePtr);
---
>         convert_to_string(v);
>         bind_address = Z_STRVAL_P(v);
687c379
<     if (sw_zend_hash_find(vht, ZEND_STRS("bind_port"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("bind_port"), (void **) &v) == SUCCESS)
689,690c381,382
<         convert_to_long(valuePtr);
<         bind_port = (int) Z_LVAL_P(valuePtr);
---
>         convert_to_long(v);
>         bind_port = (int) Z_LVAL_P(v);
699c391
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_tcp_nodelay"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_tcp_nodelay"), (void **) &v) == SUCCESS)
708c400
<     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_method"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_method"), (void **) &v) == SUCCESS)
710,711c402,403
<         convert_to_long(valuePtr);
<         cli->ssl_method = (int) Z_LVAL_P(valuePtr);
---
>         convert_to_long(v);
>         cli->ssl_method = (int) Z_LVAL_P(v);
714c406
<     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_compress"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_compress"), (void **) &v) == SUCCESS)
716,717c408,409
<         convert_to_boolean(valuePtr);
<         cli->ssl_disable_compress = !Z_BVAL_P(valuePtr);
---
>         convert_to_boolean(v);
>         cli->ssl_disable_compress = !Z_BVAL_P(v);
719c411
<     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_cert_file"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_cert_file"), (void **) &v) == SUCCESS)
721,722c413,414
<         convert_to_string(valuePtr);
<         cli->ssl_cert_file = strdup(Z_STRVAL_P(valuePtr));
---
>         convert_to_string(v);
>         cli->ssl_cert_file = strdup(Z_STRVAL_P(v));
730c422
<     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_key_file"), (void **) &valuePtr) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("ssl_key_file"), (void **) &v) == SUCCESS)
732,733c424,425
<         convert_to_string(valuePtr);
<         cli->ssl_key_file = strdup(Z_STRVAL_P(valuePtr));
---
>         convert_to_string(v);
>         cli->ssl_key_file = strdup(Z_STRVAL_P(v));
750c442,444
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
756c450
<     ZVAL_STRING(&shutdown_function_entry.arguments[0], function);
---
>     ZVAL_STRING(&shutdown_function_entry.arguments[0], "swoole_event_wait");
758c452
<     if (!register_user_shutdown_function(function, strlen(function), &shutdown_function_entry TSRMLS_CC))
---
>     if (!register_user_shutdown_function("swoole_event_wait", sizeof("swoole_event_wait")-1, &shutdown_function_entry TSRMLS_CC))
761,762c455,456
<         swoole_efree(shutdown_function_entry.arguments);
<         swWarn("Unable to register shutdown function [%s]",function);
---
>         efree(shutdown_function_entry.arguments);
>         swoole_php_fatal_error(E_WARNING, "Unable to register shutdown function [swoole_event_wait]");
765,766c459,460
< 
<     zval *callback = NULL;
---
>     
>     zval *callback;
768c462
<     SW_ZVAL_STRING(callback, function, 1);
---
>     SW_ZVAL_STRING(callback, "swoole_event_wait", 1);
772c466
<     php_shutdown_function_entry shutdown_function_entry;
---
>      php_shutdown_function_entry shutdown_function_entry;
776a471
> 
779c474
<     if (!register_user_shutdown_function(function, strlen(function), &shutdown_function_entry TSRMLS_CC))
---
>     if (!register_user_shutdown_function("swoole_event_wait", sizeof("swoole_event_wait"), &shutdown_function_entry TSRMLS_CC))
781c476
<         swoole_efree(shutdown_function_entry.arguments);
---
>         efree(shutdown_function_entry.arguments);
783c478
<         swWarn("Unable to register shutdown function [%s]",function);
---
>         swoole_php_fatal_error(E_WARNING, "Unable to register shutdown function [swoole_event_wait]");
786c481,482
<     zval *register_shutdown_function = NULL;
---
>     zval *register_shutdown_function;
>     zval *retval = NULL;
791d486
<     zval *retval = NULL;
794c489,490
<         swWarn("Unable to register shutdown function [%s]",function);
---
>         swoole_php_fatal_error(E_WARNING, "Unable to register shutdown function [swoole_event_wait]");
>         return;
796d491
< 
801,806d495
< 
<     if (retval)
<     {
<     	sw_zval_ptr_dtor(&retval);
<     }
< 
808c497
< 
---
>     
819c508,510
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
838c529,534
<         if (swReactor_init(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) < 0)
---
>         if (SwooleG.main_reactor == NULL)
>         {
>             swoole_php_fatal_error(E_ERROR, "malloc failed.");
>             return;
>         }
>         if (swReactor_create(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) < 0)
843d538
< 
847a543,544
>         //only client side
>         php_swoole_at_shutdown("swoole_event_wait");
850,851d546
<     //only client side
<     php_swoole_at_shutdown("swoole_event_wait");
853,854d547
<     SwooleWG.reactor_init = 1;
< }
856,859c549
< void swoole_thread_clean()
< {
< 	/// 释放async io线程资源
< 	swAio_free();
---
>     SwooleWG.reactor_init = 1;
864,870c554,555
< 	//unset object
< 	if (object)
< 	{
< 		swoole_set_object(object, NULL);
< 	}
< 
<     if (cli)
---
>     //long tcp connection, delete from php_sw_long_connections
>     if (cli->keep)
872,874c557,563
<         swoole_efree(cli->server_str);
<         cli->close(cli);
<         swoole_efree(cli);
---
>         if (swHashMap_del(php_sw_long_connections, cli->server_str, cli->server_strlen))
>         {
>             swoole_php_fatal_error(E_WARNING, "delete from hashtable failed.");
>         }
>         efree(cli->server_str);
>         swClient_free(cli);
>         pefree(cli, 1);
875a565,572
>     else
>     {
>         efree(cli->server_str);
>         swClient_free(cli);
>         efree(cli);
>     }
>     //unset object
>     swoole_set_object(object, NULL);
878c575
< swClient* php_swoole_client_new(zval *object, char *host, int host_len, int port,swClient** client)
---
> swClient* php_swoole_client_new(zval *object, char *host, int host_len, int port)
879a577,587
>     zval *ztype;
>     int async = 0;
>     int packet_mode = 0;
>     char conn_key[SW_LONG_CONNECTION_KEY_LEN];
>     int conn_key_len = 0;
>     uint64_t tmp_buf;
>     int ret;
> 
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
881c589
<     SWOOLE_FETCH_TSRMLS;
---
>     ztype = sw_zend_read_property(swoole_client_class_entry_ptr, object, SW_STRL("type")-1, 0 TSRMLS_CC);
883,884c591
<     zval *ztype = sw_zend_read_property(swoole_client_class_entry_ptr, object, SW_STRL("type")-1, 0 TSRMLS_CC);
<     if (!ztype || ZVAL_IS_NULL(ztype))
---
>     if (ztype == NULL || ZVAL_IS_NULL(ztype))
891c598,599
<     int packet_mode = (type_tmp & SW_MODE_PACKET) >> 4;
---
>     packet_mode = type_tmp & SW_MODE_PACKET;
>     packet_mode >>= 4;
893a602,604
>     //debug
>     //swTrace("type:%d,type_tmp:%d\r\n",type,type_tmp);
> 
895c606,609
<     int async = (type & SW_FLAG_ASYNC)? 1: 0;
---
>     if (type & SW_FLAG_ASYNC)
>     {
>         async = 1;
>     }
897,899c611
<     char conn_key[SW_LONG_CONNECTION_KEY_LEN] = {0};
<     int conn_key_len = 0;
<     bzero(conn_key, SW_LONG_CONNECTION_KEY_LEN);
---
>     swClient *cli;
900a613
>     bzero(conn_key, SW_LONG_CONNECTION_KEY_LEN);
902,904d614
<     conn_key_len = (!connection_id || ZVAL_IS_NULL(connection_id))?
<     		snprintf(conn_key, SW_LONG_CONNECTION_KEY_LEN - 1, "%s:%d", host, port) + 1:
<     		snprintf(conn_key, SW_LONG_CONNECTION_KEY_LEN - 1, "%s", Z_STRVAL_P(connection_id)) + 1;
906,907c616
<     swClient* cli = NULL;
<     if (*client)
---
>     if (connection_id == NULL || ZVAL_IS_NULL(connection_id))
909,910c618
<     	cli = *client;
<     	goto create_client;
---
>         conn_key_len = snprintf(conn_key, SW_LONG_CONNECTION_KEY_LEN, "%s:%d", host, port) + 1;
914,932c622,623
<     	cli = (swClient*) emalloc(sizeof(swClient));
<     	/// 新分配的结构，必须要用bzero 处理，否则会出现问题（cli 中的内容是随机的）
<     	bzero(cli,sizeof(swClient));
<     	*client = cli;
<     }
< 
< create_client:
< 	if (swClient_create(cli, php_swoole_socktype(type), async) < 0) {
< 		swWarn("swClient_create() failed. Error: %s [%d]", strerror(errno), errno);
< 		zend_update_property_long(swoole_client_class_entry_ptr, object, ZEND_STRL("errCode"), errno TSRMLS_CC);
< 		return NULL;
< 	}
< 
< 	//don't forget free it
< 	if (!cli->server_str)
< 	{
< 		cli->server_str = estrndup(conn_key,conn_key_len);
< 		cli->server_strlen = conn_key_len;
< 	}
---
>         conn_key_len = snprintf(conn_key, SW_LONG_CONNECTION_KEY_LEN, "%s", Z_STRVAL_P(connection_id)) + 1;
>     }
934c625,677
< 	zend_update_property_long(swoole_client_class_entry_ptr, object, ZEND_STRL("sock"), cli->socket->fd TSRMLS_CC);
---
>     //keep the tcp connection
>     if (type & SW_FLAG_KEEP)
>     {
>         swClient *find = swHashMap_find(php_sw_long_connections, conn_key, conn_key_len);
>         if (find == NULL)
>         {
>             cli = (swClient*) pemalloc(sizeof(swClient), 1);
>             if (swHashMap_add(php_sw_long_connections, conn_key, conn_key_len, cli) == FAILURE)
>             {
>                 swoole_php_fatal_error(E_WARNING, "swoole_client_create_socket add to hashtable failed.");
>             }
>             goto create_socket;
>         }
>         else
>         {
>             cli = find;
>             //try recv, check connection status
>             ret = recv(cli->socket->fd, &tmp_buf, sizeof(tmp_buf), MSG_DONTWAIT | MSG_PEEK);
>             if (ret == 0 || (ret < 0 && swConnection_error(errno) == SW_CLOSE))
>             {
>                 cli->close(cli);
>                 goto create_socket;
>             }
>             //clear history data
>             if (ret > 0)
>             {
>                 swSocket_clean(cli->socket->fd);
>             }
>         }
>     }
>     else
>     {
>         cli = (swClient*) emalloc(sizeof(swClient));
> 
>         create_socket:
>         if (swClient_create(cli, php_swoole_socktype(type), async) < 0)
>         {
>             swoole_php_fatal_error(E_WARNING, "swClient_create() failed. Error: %s [%d]", strerror(errno), errno);
>             zend_update_property_long(swoole_client_class_entry_ptr, object, ZEND_STRL("errCode"), errno TSRMLS_CC);
>             return NULL;
>         }
> 
>         //don't forget free it
>         cli->server_str = estrdup(conn_key);
>         cli->server_strlen = conn_key_len;
>     }
> 
>     zend_update_property_long(swoole_client_class_entry_ptr, object, ZEND_STRL("sock"), cli->socket->fd TSRMLS_CC);
> 
>     if (type & SW_FLAG_KEEP)
>     {
>         cli->keep = 1;
>     }
937c680,683
< 	cli->open_ssl = (type & SW_SOCK_SSL)? 1:0;
---
>     if (type & SW_SOCK_SSL)
>     {
>         cli->open_ssl = 1;
>     }
940c686,689
< 	cli->packet_mode = (packet_mode == 1)? 1: 0;
---
>     if (packet_mode == 1)
>     {
>         cli->packet_mode = 1;
>     }
946c695
<     long async = SW_SOCK_SYNC;
---
>     long async = 0;
950c699,700
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|ls", &ztype, &async, &id, &len))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|ls", &ztype, &async, &id, &len) == FAILURE)
960,966c710,713
<     Z_LVAL_P(ztype) = (async == SW_SOCK_ASYNC)? (Z_LVAL_P(ztype) | SW_FLAG_ASYNC) : Z_LVAL_P(ztype);
<     int client_type = php_swoole_socktype(Z_LVAL_P(ztype));
< 	if (client_type < SW_SOCK_TCP || client_type > SW_SOCK_UNIX_STREAM)
< 	{
< 		swoole_php_fatal_error(E_ERROR, "Unknown client type '%d'.", client_type);
< 		RETURN_FALSE;
< 	}
---
>     if (async == 1)
>     {
>         Z_LVAL_P(ztype) = Z_LVAL_P(ztype) | SW_FLAG_ASYNC;
>     }
969a717,720
>         if ((Z_LVAL_P(ztype) & SW_FLAG_KEEP) && SWOOLE_G(cli))
>         {
>             swoole_php_fatal_error(E_ERROR, "The 'SWOOLE_KEEP' flag can only be used in the php-fpm or apache environment.");
>         }
973c724,728
<     zend_update_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("type"), ztype TSRMLS_CC);
---
>     int client_type = php_swoole_socktype(Z_LVAL_P(ztype));
>     if (client_type < SW_SOCK_TCP || client_type > SW_SOCK_UNIX_STREAM)
>     {
>         swoole_php_fatal_error(E_ERROR, "Unknown client type '%d'.", client_type);
>     }
974a730
>     zend_update_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("type"), ztype TSRMLS_CC);
983d738
< 
986,991d740
<     swoole_set_property(getThis(),swoole_property_socket,NULL);
< 
<     client_callback *cb = emalloc(sizeof(client_callback));
< 	bzero(cb, sizeof(client_callback));
< 	swoole_set_property(getThis(), swoole_property_common, cb);
< 
1001,1012c750,759
<     	cli->object = NULL;
<         php_swoole_client_free(getThis(), cli TSRMLS_CC);
<     }
< 
<     releaseConnobj(getThis());
< 
< #ifdef SWOOLE_SOCKETS_SUPPORT
<     zval *zsocket = swoole_get_property(getThis(), swoole_property_socket);
<     if (zsocket)
<     {
<         sw_zval_free(zsocket);
<         swoole_set_property(getThis(), swoole_property_socket, NULL);
---
>         cli->released = 1;
>         if (cli->socket->closed)
>         {
>             php_swoole_client_free(getThis(), cli TSRMLS_CC);
>         }
>         else if (!cli->keep)
>         {
>             cli->close(cli);
>             php_swoole_client_free(getThis(), cli TSRMLS_CC);
>         }
1014c761,762
< #endif
---
>     //free callback function
>     client_free_callback(getThis());
1023,1028d770
< 
<     //free callback function
<     client_callback *cb = swoole_get_property(getThis(), swoole_property_common);
< 	client_free_callback(getThis());
< 	swoole_efree(cb);
< 	swoole_set_property(getThis(), swoole_property_common, NULL);
1033,1034c775,776
<     zval *zset = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset))
---
>     zval *zset;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset) == FAILURE)
1038d779
< 
1043,1068d783
< static PHP_METHOD(swoole_client,setConnectTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &timeout))
< 	{
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
< 	}
< 
< 	zend_update_property_long(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("connectTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE;
< }
< 
< static PHP_METHOD(swoole_client,setSendTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &timeout))
< 	{
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
< 	}
< 
< 	zend_update_property_long(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("sendTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE;
< }
< 
1071,1092d785
< 	swClient *cli = swoole_get_object(getThis());
< 	if (cli && cli->socket && cli->socket->active)
< 	{
< 		RETURN_TRUE;
< 	}
< 
< 	if (cli && cli->released)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	if (cli && cli->socket)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	zval *internal_user = sw_zend_read_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	if (internal_user && Z_BVAL_P(internal_user))
< 	{
< 		RETURN_FALSE;
< 	}
< 
1095,1096c788,791
<     zend_size_t host_len = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sl|l", &host, &host_len, &port, &sock_flag))
---
>     zend_size_t host_len;
>     double timeout = SW_CLIENT_DEFAULT_TIMEOUT;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|ldl", &host, &host_len, &port, &timeout, &sock_flag) == FAILURE)
1098,1099c793
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
---
>         return;
1102c796
<     if (!host || host_len <= 0)
---
>     if (host_len <= 0)
1104c798
<         swWarn("The host is empty.");
---
>         swoole_php_fatal_error(E_WARNING, "The host is empty.");
1108,1109c802,803
<     /// 取消定时器
<     if (cli && cli->timer_id > 0)
---
>     swClient *cli = swoole_get_object(getThis());
>     if (cli && !cli->keep)
1111,1113c805,809
< 		long timer_id = cli->timer_id;
< 		cli->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
---
>         if (!cli->socket->closed)
>         {
>             cli->close(cli);
>         }
>         php_swoole_client_free(getThis(), cli TSRMLS_CC);
1116,1117c812,813
<     cli = php_swoole_client_new(getThis(), host, host_len, port,&cli);
<     if (!cli)
---
>     cli = php_swoole_client_new(getThis(), host, host_len, port);
>     if (cli == NULL)
1119,1120c815
< 		swWarn("create swClient failed.");
< 		RETURN_FALSE;
---
>         RETURN_FALSE;
1123,1127c818
<     if (swSocket_is_tcpStream(cli->type) && (port <= 0 || port > SW_CLIENT_MAX_PORT))
< 	{
< 		swWarn("The port is invalid.");
< 		RETURN_FALSE;
< 	}
---
>     swoole_set_object(getThis(), cli);
1129,1131c820
<     /// for tcp: is async
<     /// for udp: wether use connect.
<     if (swSocket_is_tcpStream(cli->type) && cli->async)
---
>     if (cli->type == SW_SOCK_TCP || cli->type == SW_SOCK_TCP6)
1133c822,832
<     		sock_flag = 1;
---
>         if (port <= 0 || port > SW_CLIENT_MAX_PORT)
>         {
>             swoole_php_fatal_error(E_WARNING, "The port is invalid.");
>             RETURN_FALSE;
>         }
>         if (cli->async == 1)
>         {
>             //for tcp: nonblock
>             //for udp: have udp connect
>             sock_flag = 1;
>         }
1136c835,844
< //    sock_flag = (swSocket_is_tcpStream(cli->type) || cli->async)? cli->async:sock_flag;
---
>     if (cli->keep == 1 && cli->socket->active == 1)
>     {
>         zend_update_property_bool(swoole_client_class_entry_ptr, getThis(), SW_STRL("reuse")-1, 1 TSRMLS_CC);
>         RETURN_TRUE;
>     }
>     else if (cli->socket->active == 1)
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_client is already connected.");
>         RETURN_FALSE;
>     }
1144c852
<     /// 异步时关联了 zval object对象实例
---
>     //nonblock async
1147c855,861
<         client_callback *cb = swoole_get_property(getThis(), swoole_property_common);
---
>         client_callback *cb = swoole_get_property(getThis(), 0);
>         if (!cb || !cb->onReceive)
>         {
>             swoole_php_fatal_error(E_ERROR, "no receive callback.");
>             RETURN_FALSE;
>         }
> 
1150,1158c864,865
<         	    if (!cb || !cb->onConnect || !cb->onClose)
< 			{
< 				swWarn("no receive or connect or close callback.");
< 				RETURN_FALSE;
< 			}
< 
< 			cli->onReceive = client_onReceive;
< 			cli->onConnect = client_onConnect;
< 			cli->onClose = client_onClose;
---
>             cli->onConnect = client_onConnect;
>             cli->onClose = client_onClose;
1159a867,884
>             cli->onReceive = client_onReceive;
> 
>             if (!cb->onConnect)
>             {
>                 swoole_php_fatal_error(E_ERROR, "no connect callback.");
>                 RETURN_FALSE;
>             }
>             if (!cb->onError)
>             {
>                 swoole_php_fatal_error(E_ERROR, "no error callback.");
>                 RETURN_FALSE;
>             }
>             if (!cb->onClose)
>             {
>                 swoole_php_fatal_error(E_ERROR, "no close callback.");
>                 RETURN_FALSE;
>             }
>             cli->reactor_fdtype = PHP_SWOOLE_FD_STREAM_CLIENT;
1163,1168d887
<            	if (!cb || !cb->onReceive)
< 			{
< 				swWarn("no receive or connect or close callback.");
< 				RETURN_FALSE;
< 			}
< 
1181,1199c900,908
<         cli->reactor_fdtype = swSocket_is_stream(cli->type)? PHP_SWOOLE_FD_STREAM_CLIENT:PHP_SWOOLE_FD_DGRAM_CLIENT;
<         if (!cli->object)
< 		{
< 			zval *obj = getThis();
< 			cli->object = obj;
< 			sw_zval_add_ref(&obj);
< 			sw_copy_to_stack(cli->object,cb->_object);
< 		}
<     }
< 
< 	swoole_set_object(getThis(), cli);
< 
< 	long timeout = 0;
< 	zval* connectTimeout = sw_zend_read_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("connectTimeout"), 1 TSRMLS_CC);
< 	if (connectTimeout)
< 	{
< 		convert_to_long(connectTimeout);
< 		timeout = Z_LVAL_P(connectTimeout);
< 	}
---
>         zval *obj = getThis();
> #if PHP_MAJOR_VERSION >= 7
>         cli->object = (zval *) emalloc(sizeof(zval));
>         ZVAL_DUP(cli->object, obj);
> #else
>         cli->object = obj;
> #endif
>         sw_zval_add_ref(&obj);
>     }
1201c910,911
<     if (cli->connect(cli, host, port, timeout/1000.0,sock_flag) < 0)
---
>     //nonblock async
>     if (cli->connect(cli, host, port, timeout, sock_flag) < 0)
1202a913
>         swoole_php_sys_error(E_WARNING, "connect to server[%s:%d] failed.", host, (int )port);
1204d914
<         swWarn("connect to server[%s:%d] failed.", host, (int )port);
1207,1221d916
< 
<     if (cli->async && swSocket_is_stream(cli->type) && timeout > 0)
< 	{
<     		cli->timer_id = 0;
< 		cli->timer_id = swTimer_add(&SwooleG.timer,timeout,0,cli,TCPCLIENT_USED);
< 		if (cli->timer_id <= 0)
< 		{
< 			swWarn("set connect time out timer failed.");
< 			RETURN_FALSE;
< 		}
< 
< 		cli->timeout_type = SW_CLIENT_CONNECT_TIMEOUT;
< 		register_after_cb(&SwooleG.timer,TCPCLIENT_USED,tcpClient_timeout);
< 	}
< 
1227,1240c922,923
< 	swClient *cli = swoole_get_object(getThis());
< 	if (!cli || !cli->socket || cli->released)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	if (!cli->socket->active)
< 	{
< 		swWarn("socket[%d] is not connected",cli->socket->fd);
< 		RETURN_FALSE;
< 	}
< 
< 	char *data = NULL;
<     zend_size_t data_len = 0;
---
>     char *data;
>     zend_size_t data_len;
1242c925,926
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &data, &data_len, &flags))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &data, &data_len, &flags) == FAILURE)
1244c928
<     		RETURN_FALSE;
---
>         return;
1247c931
<     if (!data || data_len <= 0)
---
>     if (data_len <= 0)
1249c933,946
<         swWarn("data is empty or data len < 0.");
---
>         swoole_php_fatal_error(E_WARNING, "data is empty.");
>         RETURN_FALSE;
>     }
> 
>     swClient *cli = swoole_get_object(getThis());
>     if (!cli)
>     {
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
>         RETURN_FALSE;
>     }
> 
>     if (cli->socket->active == 0)
>     {
>         swoole_php_error(E_WARNING, "server is not connected.");
1254d950
<     int ret = 0;
1255a952,953
>     int ret;
> 
1259c957,958
<         if (cli->send(cli, (char *) &len_tmp,sizeof(uint32_t), flags) < 0)
---
>         ret = cli->send(cli, (char *) &len_tmp, 4, flags);
>         if (ret < 0)
1268c967
< send_error:
---
>         send_error:
1270c969
<         swWarn("client(%d) send %d bytes failed, errno=%d:%s.", cli->socket->fd, data_len, errno, strerror(errno));
---
>         swoole_php_sys_error(E_WARNING, "send(%d) %d bytes failed.", cli->socket->fd, data_len);
1274c973
<     else if (cli->async && swSocket_is_stream(cli->type))
---
>     else
1276,1304c975
<       	cli->timer_id = 0;
< 		long timeout = 0;
< 		zval* sendTimeout = sw_zend_read_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("sendTimeout"), 1 TSRMLS_CC);
< 		if (sendTimeout)
< 		{
< 			convert_to_long(sendTimeout);
< 			timeout = Z_LVAL_P(sendTimeout);
< 		}
< 
< 		timeout = timeout <= 0? 0:timeout;
< 		if (timeout > 0)
< 		{
< 			cli->timer_id = swTimer_add(&SwooleG.timer,timeout,0,cli,TCPCLIENT_USED);
< 			if (cli->timer_id <= 0)
< 			{
< 				swWarn("set recv msg time out timer failed.");
< 				RETURN_FALSE;
< 			}
< 
< 			cli->timeout_type = SW_CLIENT_RECV_TIMEOUT;
< 			register_after_cb(&SwooleG.timer,TCPCLIENT_USED,tcpClient_timeout);
< 		}
< 
< 		if (ret > 0)
< 		{
< 			RETURN_LONG(ret);
< 		}
< 
< 		RETURN_TRUE;
---
>         RETURN_LONG(ret);
1306,1307d976
< 
<     RETURN_LONG(ret);
1312,1314c981,983
<     char* ip = NULL;
<     zend_size_t ip_len = 0;
<     zend_size_t port = 0;
---
>     char* ip;
>     char* ip_len;
>     zend_size_t port;
1316,1318c985,988
<     char *data = NULL;
<     zend_size_t len = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sls", &ip, &ip_len, &port, &data, &len))
---
>     char *data;
>     zend_size_t len;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sls", &ip, &ip_len, &port, &data, &len) == FAILURE)
1320c990
<     	RETURN_FALSE;
---
>         return;
1323c993
<     if (!data || len <= 0)
---
>     if (len <= 0)
1325c995
<         swWarn("data is empty.");
---
>         swoole_php_error(E_WARNING, "data is empty.");
1332,1339c1002,1003
<     		cli = php_swoole_client_new(getThis(), ip, ip_len, port,&cli);
< 		if (cli == NULL)
< 		{
< 			RETURN_FALSE;
< 		}
< 
< 		cli->socket->active = 1;
< 		swoole_set_object(getThis(), cli);
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
>         RETURN_FALSE;
1342c1006
<     if (!cli || !cli->socket || cli->released)
---
>     if (cli->socket->active == 0)
1344,1345c1008,1009
< 		swWarn("swoole_client_sendto cli or socket is null or cli is released.\n");
< 		RETURN_FALSE;
---
>         swoole_php_error(E_WARNING, "server is not connected.");
>         RETURN_FALSE;
1348c1012,1013
<     if (!swSocket_is_udpDgram(cli->type))
---
>     int ret;
>     if (cli->type == SW_SOCK_UDP)
1350,1351c1015,1024
< 		swWarn("only support SWOOLE_SOCK_UDP or SWOOLE_SOCK_UDP6.");
< 		RETURN_FALSE;
---
>         ret = swSocket_udp_sendto(cli->socket->fd, ip, port, data, len);
>     }
>     else if (cli->type == SW_SOCK_UDP6)
>     {
>         ret = swSocket_udp_sendto6(cli->socket->fd, ip, port, data, len);
>     }
>     else
>     {
>         swoole_php_fatal_error(E_WARNING, "only support SWOOLE_SOCK_UDP or SWOOLE_SOCK_UDP6.");
>         RETURN_FALSE;
1353,1357d1025
< 
<     int ret = (cli->type == SW_SOCK_UDP)?
<     		swSocket_udp_sendto(cli->socket->fd, ip, port, data, len):
<     		swSocket_udp_sendto6(cli->socket->fd, ip, port, data, len);
< 
1363,1368c1031,1032
< 	swClient *cli = swoole_get_object(getThis());
< 	if (!cli || !cli->socket || !cli->socket->active || cli->released)
< 	{
< 		swWarn("object(client or socket) is not instance or socekt is not active.");
< 		RETURN_FALSE;
< 	}
---
>     char *file;
>     zend_size_t file_len;
1370,1372c1034
<     char *file = NULL;
<     zend_size_t file_len = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &file, &file_len))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &file, &file_len) == FAILURE)
1376,1377c1038
< 
<     if (!file || file_len <= 0)
---
>     if (file_len <= 0)
1379c1040
<         swWarn("file is empty or filename is null.");
---
>         swoole_php_fatal_error(E_WARNING, "file is empty.");
1383c1044,1045
<     if (!swSocket_is_stream(cli->type))
---
>     swClient *cli = swoole_get_object(getThis());
>     if (!cli)
1385c1047
<         swWarn("dgram socket cannot use sendfile.");
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
1388a1051,1060
>     if (!(cli->type == SW_SOCK_TCP || cli->type == SW_SOCK_TCP6 || cli->type == SW_SOCK_UNIX_STREAM))
>     {
>         swoole_php_error(E_WARNING, "dgram socket cannot use sendfile.");
>         RETURN_FALSE;
>     }
>     if (cli->socket->active == 0)
>     {
>         swoole_php_error(E_WARNING, "Server is not connected.");
>         RETURN_FALSE;
>     }
1391c1063,1064
<     if (cli->sendfile(cli, file) < 0)
---
>     int ret = cli->sendfile(cli, file);
>     if (ret < 0)
1394c1067
<         swWarn("sendfile() failed. Error: %s [%d]", strerror(SwooleG.error), SwooleG.error);
---
>         swoole_php_fatal_error(E_WARNING, "sendfile() failed. Error: %s [%d]", strerror(SwooleG.error), SwooleG.error);
1398,1399c1071,1074
< 
<     RETVAL_TRUE;
---
>     else
>     {
>         RETVAL_TRUE;
>     }
1405a1081
>     int ret;
1407c1083
<     char stack_buf[SW_BUFFER_SIZE_BIG] = {0};
---
>     char stack_buf[SW_BUFFER_SIZE_BIG];
1409c1085
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ll", &buf_len, &flags))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ll", &buf_len, &flags) == FAILURE)
1415c1091,1095
<     flags = (1 == flags)? MSG_WAITALL:flags;
---
>     if (flags == 1)
>     {
>         flags = MSG_WAITALL;
>     }
> 
1417c1097
<     if (!cli || !cli->socket || !cli->socket->active)
---
>     if (!cli)
1419c1099
<         swWarn("object(client or socket) is not instance or socket is not active.");
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
1427a1108,1113
>     if (cli->socket->active == 0)
>     {
>         swoole_php_error(E_WARNING, "server is not connected.");
>         RETURN_FALSE;
>     }
> 
1429c1115
<     int ret = -1;
---
> 
1432c1118,1122
<     	cli->buffer = (!cli->buffer)? swString_new(SW_BUFFER_SIZE_BIG) : cli->buffer;
---
>         if (cli->buffer == NULL)
>         {
>             cli->buffer = swString_new(SW_BUFFER_SIZE_BIG);
>         }
> 
1434a1125
> 
1439c1130,1134
<             buf_len = (buf_len > SW_BUFFER_SIZE_BIG)? SW_BUFFER_SIZE_BIG:buf_len;
---
> 
>             if (buf_len > SW_BUFFER_SIZE_BIG)
>             {
>                 buf_len = SW_BUFFER_SIZE_BIG;
>             }
1444c1139
<                 swWarn("recv() failed. Error: %s [%d]", strerror(errno), errno);
---
>                 swoole_php_error(E_WARNING, "recv() failed. Error: %s [%d]", strerror(errno), errno);
1454a1150
> 
1465,1466c1161,1162
<                 buffer->length = (buffer->length > eof)? (buffer->length - eof):0;
<                 if (buffer->length > 0)
---
> 
>                 if (buffer->length > eof)
1467a1164
>                     buffer->length -= eof;
1471c1168,1171
< 
---
>                 else
>                 {
>                     buffer->length = 0;
>                 }
1474c1174
<             else if (buffer->length == protocol->package_max_length)
---
>             else
1476,1478c1176,1197
< 				swWarn("no package eof");
< 				buffer->length = 0;
< 				RETURN_FALSE;
---
>                 if (buffer->length == protocol->package_max_length)
>                 {
>                     swoole_php_error(E_WARNING, "no package eof");
>                     buffer->length = 0;
>                     RETURN_FALSE;
>                 }
>                 else if (buffer->length == buffer->size)
>                 {
>                     if (buffer->size < protocol->package_max_length)
>                     {
>                         int new_size = buffer->size * 2;
>                         if (new_size > protocol->package_max_length)
>                         {
>                             new_size = protocol->package_max_length;
>                         }
>                         if (swString_extend(buffer, new_size) < 0)
>                         {
>                             buffer->length = 0;
>                             RETURN_FALSE;
>                         }
>                     }
>                 }
1480,1489d1198
<             else if (buffer->length == buffer->size && buffer->size < protocol->package_max_length)
< 			{
< 				int new_size = buffer->size * 2;
< 				new_size = (new_size > protocol->package_max_length)? protocol->package_max_length:new_size;
< 				if (swString_extend(buffer, new_size) < 0)
< 				{
< 					buffer->length = 0;
< 					RETURN_FALSE;
< 				}
< 			}
1491d1199
< 
1509c1217
<         	RETURN_EMPTY_STRING();
---
>             RETURN_FALSE;
1516,1520d1223
<         else if (buf_len > protocol->package_max_length)
<         {
<         	swoole_error_log(SW_LOG_WARNING, SW_ERROR_PACKAGE_LENGTH_TOO_LARGE, "Package is too big. package_length=%d", (int )buf_len);
<         	RETURN_EMPTY_STRING();
<         }
1534c1237
<         ret = cli->recv(cli, (char*) &len_tmp, sizeof(uint32_t), MSG_WAITALL);
---
>         ret = cli->recv(cli, (char*) &len_tmp, 4, MSG_WAITALL);
1537c1240
<             swWarn("recv() header failed. Error: %s [%d]", strerror(errno), errno);
---
>             swoole_php_error(E_WARNING, "recv() header failed. Error: %s [%d]", strerror(errno), errno);
1542c1245,1246
<         	buf_len = ntohl(len_tmp);
---
>             len_tmp = ntohl(len_tmp);
>             buf_len = len_tmp;
1557c1261,1262
< check_return:
---
>     check_return:
> 
1561c1266
<         swWarn("recv() failed. Error: %s [%d]", strerror(SwooleG.error), SwooleG.error);
---
>         swoole_php_error(E_WARNING, "recv() failed. Error: %s [%d]", strerror(SwooleG.error), SwooleG.error);
1566c1271
<     else if (0 == ret)
---
>     else
1568,1569c1273,1282
< 		swoole_efree(buf);
< 		RETURN_EMPTY_STRING();
---
>         if (ret == 0)
>         {
>             swoole_efree(buf);
>             RETURN_EMPTY_STRING();
>         }
>         else
>         {
>             buf[ret] = 0;
>             SW_RETVAL_STRINGL(buf, ret, 0);
>         }
1571,1575d1283
< 	else
< 	{
< 		buf[ret] = 0;
< 		SW_RETVAL_STRINGL(buf, ret, 0);
< 	}
1581c1289,1293
<     if (!cli || !cli->socket)
---
>     if (!cli)
>     {
>         RETURN_FALSE;
>     }
>     if (!cli->socket)
1585d1296
< 
1592c1303,1308
<     if (!cli || !cli->socket || !cli->socket->active)
---
>     if (!cli)
>     {
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
>         RETURN_FALSE;
>     }
>     if (!cli->socket->active)
1594c1310
<         swWarn("object(client or socket) is not instance or socket is not active.");
---
>         swoole_php_error(E_WARNING, "not connected to the server");
1598c1314
<     if (!swSocket_is_tcpStream(cli->type) && !swSocket_is_udpDgram(cli->type))
---
>     if (cli->type == SW_SOCK_UNIX_STREAM || cli->type == SW_SOCK_UNIX_DGRAM)
1600c1316
<         swWarn("getsockname() only support AF_INET family socket.");
---
>         swoole_php_fatal_error(E_WARNING, "getsockname() only support AF_INET family socket.");
1607c1323
<         swWarn("getsockname() failed.");
---
>         swoole_php_sys_error(E_WARNING, "getsockname() failed.");
1612,1613c1328
<     char tmp[SW_IP_MAX_LENGTH] = {0};
<     if (swConnection_get_ip(cli->socket,tmp,SW_IP_MAX_LENGTH) < 0)
---
>     if (cli->type == SW_SOCK_UDP6 || cli->type == SW_SOCK_TCP6)
1615c1330,1339
<     	swWarn("get socket ip failed.");
---
>         add_assoc_long(return_value, "port", ntohs(cli->socket->info.addr.inet_v6.sin6_port));
>         char tmp[INET6_ADDRSTRLEN];
>         if (inet_ntop(AF_INET6, &cli->socket->info.addr.inet_v6.sin6_addr, tmp, sizeof(tmp)))
>         {
>             sw_add_assoc_string(return_value, "host", tmp, 1);
>         }
>         else
>         {
>             swoole_php_fatal_error(E_WARNING, "inet_ntop() failed.");
>         }
1617,1619c1341,1344
<     else{
<     	add_assoc_long(return_value, "port", swConnection_get_port(cli->socket));
<     	sw_add_assoc_string(return_value, "host", tmp, 1);
---
>     else
>     {
>         add_assoc_long(return_value, "port", ntohs(cli->socket->info.addr.inet_v4.sin_port));
>         sw_add_assoc_string(return_value, "host", inet_ntoa(cli->socket->info.addr.inet_v4.sin_addr), 1);
1622a1348
> #ifdef SWOOLE_SOCKETS_SUPPORT
1625,1630d1350
< 	zval *zsocket = swoole_get_property(getThis(), swoole_property_socket);
< 	if (zsocket)
< 	{
< 		RETURN_ZVAL(zsocket, 1, NULL);
< 	}
< 
1634c1354
<         swWarn("object(%s) is null.",cli? "swClient":"socket");
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
1637d1356
< 
1643d1361
< 
1645,1648d1362
<     zsocket = sw_zval_dup(return_value);
< 	sw_zval_add_ref(&zsocket);
< 	swoole_set_property(getThis(), swoole_property_socket, zsocket);
< 	RETURN_ZVAL(return_value,1,NULL);
1649a1364
> #endif
1654,1660c1369
<     if (!cli || !cli->socket || !cli->socket->active)
< 	{
< 		swWarn("object(client or socket) is not instance or socket is not active.");
< 		RETURN_FALSE;
< 	}
< 
<     if (!swSocket_is_udpDgram(cli->type))
---
>     if (!cli)
1662,1663c1371,1372
<     	swWarn("only support SWOOLE_SOCK_UDP or SWOOLE_SOCK_UDP6.");
<     	RETURN_FALSE;
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
>         RETURN_FALSE;
1666c1375,1379
<     array_init(return_value);
---
>     if (!cli->socket->active)
>     {
>         swoole_php_error(E_WARNING, "not connected to the server");
>         RETURN_FALSE;
>     }
1668,1669d1380
<     int type = AF_INET;
<     void* addrPtr = NULL;
1672,1673c1383,1385
<     	add_assoc_long(return_value, "port", ntohs(cli->remote_addr.addr.inet_v4.sin_port));
<     	addrPtr = (void*)((struct sockaddr*)(&cli->remote_addr.addr.inet_v4.sin_addr));
---
>         array_init(return_value);
>         add_assoc_long(return_value, "port", ntohs(cli->remote_addr.addr.inet_v4.sin_port));
>         sw_add_assoc_string(return_value, "host", inet_ntoa(cli->remote_addr.addr.inet_v4.sin_addr), 1);
1676a1389
>         array_init(return_value);
1678,1680c1391
<         addrPtr = (void*)((struct sockaddr*)(&cli->remote_addr.addr.inet_v6.sin6_addr));
<         type = AF_INET6;
<     }
---
>         char tmp[INET6_ADDRSTRLEN];
1682,1690c1393,1406
<     char tmp[SW_IP_MAX_LENGTH] = {0};
< 	if (inet_ntop(type, addrPtr, tmp, sizeof(tmp)))
< 	{
< 		sw_add_assoc_string(return_value, "host", tmp, 1);
< 	}
< 	else
< 	{
< 		swWarn("inet_ntop() failed.");
< 	}
---
>         if (inet_ntop(AF_INET6, &cli->remote_addr.addr.inet_v6.sin6_addr, tmp, sizeof(tmp)))
>         {
>             sw_add_assoc_string(return_value, "host", tmp, 1);
>         }
>         else
>         {
>             swoole_php_fatal_error(E_WARNING, "inet_ntop() failed.");
>         }
>     }
>     else
>     {
>         swoole_php_fatal_error(E_WARNING, "only support SWOOLE_SOCK_UDP or SWOOLE_SOCK_UDP6.");
>         RETURN_FALSE;
>     }
1695,1713c1411
< 	swClient *cli = swoole_get_object(getThis());
< 	if (!cli || !cli->socket)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	if (cli->released || cli->socket->closed)
< 	{
< 		//swWarn("client socket is Closed.");
< 		RETURN_TRUE;
< 	}
< 
< 	zval *internal_user = sw_zend_read_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	if (internal_user && Z_BVAL_P(internal_user))
< 	{
< 		return;
< 	}
< 
< 	int ret = 1;
---
>     int ret = 1;
1715c1413,1414
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &force))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &force) == FAILURE)
1720,1725c1419,1425
<     zval* obj = cli->object;
<     cli->object = NULL;		///手动调用回调,不产生回调
<     ret = cli->close(cli);
< 
<     /// 手动调用回调
<     if (obj)
---
>     swClient *cli = swoole_get_object(getThis());
>     if (!cli)
>     {
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
>         RETURN_FALSE;
>     }
>     if (!cli->socket)
1727,1729c1427,1439
< 		cli->object = obj;
< 		cli->released = 1;
< 		SwooleG.main_reactor->defer(SwooleG.main_reactor,defer_close,cli);
---
>         swoole_php_error(E_WARNING, "not connected to the server");
>         RETURN_FALSE;
>     }
>     if (cli->socket->closed)
>     {
>         swoole_php_error(E_WARNING, "client socket is closed.");
>         RETURN_FALSE;
>     }
>     //Connection error, or short tcp connection.
>     //No keep connection
>     if (force || !cli->keep || swConnection_error(SwooleG.error) == SW_CLOSE)
>     {
>         ret = cli->close(cli);
1731d1440
< 
1737,1738c1446,1448
< 	zval *internal_user = sw_zend_read_property(swoole_client_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	int disable_set = internal_user && Z_BVAL_P(internal_user);
---
>     char *cb_name;
>     zend_size_t cb_name_len;
>     zval *zcallback;
1740,1743c1450
<     char *cb_name = NULL;
<     zend_size_t cb_name_len = 0;
<     zval *zcallback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &cb_name, &cb_name_len, &zcallback))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &cb_name, &cb_name_len, &zcallback) == FAILURE)
1748,1758d1454
<     if (!cb_name || cb_name_len <= 0)
<     {
< 		swoole_php_fatal_error(E_ERROR,"parse callback name error.");
< 		return;
<     }
< 
< 	if (swoole_check_callable(zcallback TSRMLS_CC) < 0)
< 	{
< 		return ;
< 	}
< 
1760c1456
<     if (!ztype || ZVAL_IS_NULL(ztype))
---
>     if (ztype == NULL || ZVAL_IS_NULL(ztype))
1762c1458
<         swoole_php_fatal_error(E_ERROR, "get client type failed.");
---
>         swoole_php_fatal_error(E_ERROR, "get swoole_client->type failed.");
1772c1468
<     client_callback *cb = swoole_get_property(getThis(), swoole_property_common);
---
>     client_callback *cb = swoole_get_property(getThis(), 0);
1777c1473
<         swoole_set_property(getThis(), swoole_property_common, cb);
---
>         swoole_set_property(getThis(), 0, cb);
1780c1476,1478
<     if (cb_name_len == strlen("connect") && strncasecmp("connect", cb_name, cb_name_len) == 0)
---
> #ifdef PHP_SWOOLE_CHECK_CALLBACK
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(zcallback, 0, &func_name TSRMLS_CC))
1782,1786c1480,1492
< 		if (disable_set)
< 		{
< 			swWarn("object created by connection pool,disable set connect event");
< 			RETURN_FALSE;
< 		}
---
>         swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
>         return;
>     }
>     efree(func_name);
> #endif
> 
> #if PHP_MAJOR_VERSION >= 7
>     zval *tmp = emalloc(sizeof(zval));
>     ZVAL_DUP(tmp,zcallback);
>     zcallback = tmp;
> #endif
>     sw_zval_add_ref(&zcallback);
1788c1494,1499
<     	    if (cb->onConnect) sw_zval_ptr_dtor(&cb->onConnect);
---
>     if (strncasecmp("connect", cb_name, cb_name_len) == 0)
>     {
>         if (cb->onConnect)
>         {
>             sw_zval_ptr_dtor(&cb->onConnect);
>         }
1790d1500
<         sw_copy_to_stack(cb->onConnect,cb->_onConnect);
1792c1502
<     else if (cb_name_len == strlen("receive") && strncasecmp("receive", cb_name, cb_name_len) == 0)
---
>     else if (strncasecmp("receive", cb_name, cb_name_len) == 0)
1794c1504,1507
<         if (cb->onReceive) sw_zval_ptr_dtor(&cb->onReceive);
---
>         if (cb->onReceive)
>         {
>             sw_zval_ptr_dtor(&cb->onReceive);
>         }
1796d1508
<         sw_copy_to_stack(cb->onReceive,cb->_onReceive);
1798c1510,1518
<     else if (cb_name_len == strlen("close") && strncasecmp("close", cb_name, cb_name_len) == 0)
---
>     else if (strncasecmp("close", cb_name, cb_name_len) == 0)
>     {
>         if (cb->onClose)
>         {
>             sw_zval_ptr_dtor(&cb->onClose);
>         }
>         cb->onClose = zcallback;
>     }
>     else if (strncasecmp("error", cb_name, cb_name_len) == 0)
1800,1826c1520,1524
<        	if (disable_set)
< 		{
< 			swWarn("object created by connection pool,disable set close event");
< 			RETURN_FALSE;
< 		}
< 
<         if (cb->onClose) sw_zval_ptr_dtor(&cb->onClose);
< 		cb->onClose = zcallback;
< 		sw_copy_to_stack(cb->onClose,cb->_onClose);
<     }
<     else if (cb_name_len == strlen("timeout") && strncasecmp("timeout",cb_name,cb_name_len) == 0)
< 	{
< 		if (cb->onTimeout) sw_zval_ptr_dtor(&cb->onTimeout);
< 		cb->onTimeout = zcallback;
< 		sw_copy_to_stack(cb->onTimeout,cb->_onTimeout);
< 	}
<     else if (cb_name_len == strlen("error") && strncasecmp("error", cb_name, cb_name_len) == 0)
<     {
<     	if (disable_set)
< 		{
< 			swWarn("object created by connection pool,disable set error event");
< 			RETURN_FALSE;
< 		}
< 
<         if (cb->onError) sw_zval_ptr_dtor(&cb->onError);
<     	cb->onError = zcallback;
< 		sw_copy_to_stack(cb->onError,cb->_onError);
---
>         if (cb->onError)
>         {
>             sw_zval_ptr_dtor(&cb->onError);
>         }
>         cb->onError = zcallback;
1830c1528
<         swWarn("Unknown event callback type name '%s'.", cb_name);
---
>         swoole_php_fatal_error(E_WARNING, "Unknown event callback type name '%s'.", cb_name);
1833,1834d1530
< 
<     sw_zval_add_ref(&zcallback);
1841c1537
<     if (!cli || !cli->socket || !cli->socket->active || cli->released)
---
>     if (!cli)
1842a1539
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
1846,1848c1543,1547
<     int ret = (cli->socket->events & SW_EVENT_WRITE)?
<     		SwooleG.main_reactor->set(SwooleG.main_reactor, cli->socket->fd, cli->socket->fdtype | SW_EVENT_WRITE):
<     		SwooleG.main_reactor->del(SwooleG.main_reactor, cli->socket->fd);
---
>     if (cli->socket->active == 0)
>     {
>         swoole_php_error(E_WARNING, "server is not connected.");
>         RETURN_FALSE;
>     }
1849a1549,1557
>     int ret;
>     if (cli->socket->events & SW_EVENT_WRITE)
>     {
>         ret = SwooleG.main_reactor->set(SwooleG.main_reactor, cli->socket->fd, cli->socket->fdtype | SW_EVENT_WRITE);
>     }
>     else
>     {
>         ret = SwooleG.main_reactor->del(SwooleG.main_reactor, cli->socket->fd);
>     }
1855,1863c1563,1574
< 	swClient *cli = swoole_get_object(getThis());
< 	if (!cli || !cli->socket || !cli->socket->active || cli->released)
< 	{
< 		RETURN_FALSE;
< 	}
< 
<     int ret = (cli->socket->events & SW_EVENT_WRITE)?
<     		SwooleG.main_reactor->set(SwooleG.main_reactor, cli->socket->fd, cli->socket->fdtype | SW_EVENT_READ | SW_EVENT_WRITE):
<     		SwooleG.main_reactor->add(SwooleG.main_reactor, cli->socket->fd, cli->socket->fdtype | SW_EVENT_READ);
---
>     swClient *cli = swoole_get_object(getThis());
>     if (!cli)
>     {
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_client.");
>         RETURN_FALSE;
>     }
> 
>     if (cli->socket->active == 0)
>     {
>         swoole_php_error(E_WARNING, "server is not connected.");
>         RETURN_FALSE;
>     }
1864a1576,1584
>     int ret;
>     if (cli->socket->events & SW_EVENT_WRITE)
>     {
>         ret = SwooleG.main_reactor->set(SwooleG.main_reactor, cli->socket->fd, cli->socket->fdtype | SW_EVENT_READ | SW_EVENT_WRITE);
>     }
>     else
>     {
>         ret = SwooleG.main_reactor->add(SwooleG.main_reactor, cli->socket->fd, cli->socket->fdtype | SW_EVENT_READ);
>     }
1871d1590
<     r_array = w_array = e_array = NULL;
1875,1876c1594,1595
<     int sets = 0;
<     double timeout = SW_CLIENT_DEFAULT_TIMEOUT;
---
>     int    retval, sets = 0;
>     double timeout = 0.5;
1878c1597,1598
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "a!a!a!|d", &r_array, &w_array, &e_array, &timeout))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "a!a!a!|d", &r_array, &w_array, &e_array, &timeout) == FAILURE)
1883,1888d1602
<     if (!r_array && !w_array && !e_array){
<     	swoole_php_fatal_error(E_ERROR,"read/write/error array is null.");
<     	return ;
<     }
< 
<     /// todo 替换成reactor接口的模式
1899c1613
<         swWarn("no resource arrays were passed to select");
---
>         swoole_php_fatal_error(E_WARNING, "no resource arrays were passed to select");
1905c1619
<         swWarn("select max_fd > FD_SETSIZE[%d]", FD_SETSIZE);
---
>         swoole_php_fatal_error(E_WARNING, "select max_fd > FD_SETSIZE[%d]", FD_SETSIZE);
1908d1621
< 
1912,1913c1625,1626
<     int retval = select(max_fd + 1, &rfds, &wfds, &efds, &timeo);
<     if (retval < 0)
---
>     retval = select(max_fd + 1, &rfds, &wfds, &efds, &timeo);
>     if (retval == -1)
1915c1628
<         swWarn("unable to select. Error: %s [%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "unable to select. Error: %s [%d]", strerror(errno), errno);
1918d1630
< 
1931d1642
< 
1933a1645,1791
> 
> static int client_select_wait(zval *sock_array, fd_set *fds TSRMLS_DC)
> {
>     zval *element = NULL;
>     zval *zsock;
>     zend_class_entry *ce;
> 
>     ulong_t num = 0;
>     if (SW_Z_TYPE_P(sock_array) != IS_ARRAY)
>     {
>         return 0;
>     }
> 
> #if PHP_MAJOR_VERSION < 7
>     HashTable *new_hash;
>     char *key = NULL;
>     zval **dest_element;
>     uint32_t key_len;
> 
>     ALLOC_HASHTABLE(new_hash);
>     zend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(sock_array)), NULL, ZVAL_PTR_DTOR, 0);
> 
>     SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(sock_array), element)
>         if (Z_TYPE_P(element) != IS_OBJECT)
>         {
>             swoole_php_fatal_error(E_WARNING, "object is not swoole_client object[1].");
>             continue;
>         }
>         ce = Z_OBJCE_P(element);
>         zsock = sw_zend_read_property(ce, element, SW_STRL("sock")-1, 0 TSRMLS_CC);
>         if (zsock == NULL || ZVAL_IS_NULL(zsock))
>         {
>             swoole_php_fatal_error(E_WARNING, "object is not swoole_client object[2].");
>             continue;
>         }
>         if ((Z_LVAL(*zsock) < FD_SETSIZE) && FD_ISSET(Z_LVAL(*zsock), fds))
>         {
>             switch (sw_zend_hash_get_current_key(Z_ARRVAL_P(sock_array), &key, &key_len, &num))
>             {
>             case HASH_KEY_IS_STRING:
>                 sw_zend_hash_add(new_hash, key, key_len, (void * ) &element, sizeof(zval *), (void ** )&dest_element);
>                 break;
>             case HASH_KEY_IS_LONG:
>                 sw_zend_hash_index_update(new_hash, num, (void * ) &element, sizeof(zval *), (void ** )&dest_element);
>                 break;
>             }
>             if (dest_element)
>             {
>                 sw_zval_add_ref(dest_element);
>             }
>         }
>         num ++;
>     SW_HASHTABLE_FOREACH_END();
> 
>     zend_hash_destroy(Z_ARRVAL_P(sock_array));
>     efree(Z_ARRVAL_P(sock_array));
> 
>     zend_hash_internal_pointer_reset(new_hash);
>     Z_ARRVAL_P(sock_array) = new_hash;
> #else
>     zval new_array;
>     array_init(&new_array);
>     zend_ulong num_key;
>     zend_string *key;
>     zval *dest_element;
> 
>     ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(sock_array), num_key, key, element)
>     {
>         if (Z_TYPE_P(element) != IS_OBJECT)
>         {
>             swoole_php_fatal_error(E_WARNING, "object is not swoole_client object[1].");
>             continue;
>         }
>         ce = Z_OBJCE_P(element);
>         zsock = sw_zend_read_property(ce, element, SW_STRL("sock")-1, 0 TSRMLS_CC);
>         if (zsock == NULL || ZVAL_IS_NULL(zsock))
>         {
>             swoole_php_fatal_error(E_WARNING, "object is not swoole_client object[2].");
>             continue;
>         }
> 
>         if ((Z_LVAL(*zsock) < FD_SETSIZE) && FD_ISSET(Z_LVAL(*zsock), fds))
>         {
>             if (key)
>             {
>                 dest_element = zend_hash_add(Z_ARRVAL(new_array), key, element);
>             }
>             else
>             {
>                 dest_element = zend_hash_index_update(Z_ARRVAL(new_array), num_key, element);
>             }
>             if (dest_element)
>             {
>                 Z_ADDREF_P(dest_element);
>             }
>         }
>         num++;
>     } ZEND_HASH_FOREACH_END();
> 
>     zval_ptr_dtor(sock_array);
>     ZVAL_COPY_VALUE(sock_array, &new_array);
> #endif
>     return num ? 1 : 0;
> }
> 
> static int client_select_add(zval *sock_array, fd_set *fds, int *max_fd TSRMLS_DC)
> {
>     zval *element = NULL;
>     zval *zsock;
>     zend_class_entry *ce;
> 
>     if (SW_Z_TYPE_P(sock_array) != IS_ARRAY)
>     {
>         return 0;
>     }
> 
>     int num = 0;
>     SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(sock_array), element)
>         if (Z_TYPE_P(element) != IS_OBJECT)
>         {
>             swoole_php_fatal_error(E_WARNING, "object is not swoole_client object[1].");
>             continue;
>         }
>         ce = Z_OBJCE_P(element);
>         zsock = sw_zend_read_property(ce, element, SW_STRL("sock")-1, 0 TSRMLS_CC);
>         if (zsock == NULL || ZVAL_IS_NULL(zsock))
>         {
>             swoole_php_fatal_error(E_WARNING, "object is not swoole_client object[2].");
>             continue;
>         }
>         if (Z_LVAL(*zsock) < FD_SETSIZE)
>         {
>             FD_SET(Z_LVAL(*zsock), fds);
>         }
>         else
>         {
>             swoole_php_fatal_error(E_WARNING, "socket[%ld] > FD_SETSIZE[%d].", Z_LVAL(*zsock), FD_SETSIZE);
>             continue;
>         }
>         if (Z_LVAL(*zsock) > *max_fd)
>         {
>             *max_fd = Z_LVAL(*zsock);
>         }
>         num ++;
>     SW_HASHTABLE_FOREACH_END();
>     return num ? 1 : 0;
> }
diff -r ./zan-extension/swoole_config.h ../swoole-1.8.5-stable/swoole_config.h
30c30
< #define SW_MAX_LISTEN_PORT         60000
---
> #define SW_MAX_LISTEN_PORT         128  //allows up to 128 ports to listen
34d33
< #define SW_USE_MONOTONIC_TIME
57d55
< //#define YZ_DEBUG                 //debug
112c110
< #define SW_IP_MAX_LENGTH                 64
---
> #define SW_IP_MAX_LENGTH                 32
126a125,126
> #define SW_MAINREACTOR_USE_POLL         //main thread to use select or poll
> 
129a130
> #define SW_REACTOR_MINEVENTS             128
133a135
> #define SW_MSGMAX                        8192
135d136
< #define SW_MSGMAX						 65535
217,218d217
< #define SW_STRING_BUFFER_GARBAGE_MIN	 4
< #define SW_STRING_BUFFER_GARBAGE_RATIO   (1024*64)
223d221
< #define SW_DNS_LOOKUP_CACHE_SIZE         4
227c225
< #define SW_HTTP_SERVER_SOFTWARE          "zan-http-server"
---
> #define SW_HTTP_SERVER_SOFTWARE          "swoole-http-server"
233,234c231
< #define SW_HTTP_HEADER_MAX_SIZE          (8192*2)
< #define SW_HTTP_HEADER_KEY_SIZE          128
---
> #define SW_HTTP_HEADER_MAX_SIZE          8192
236c233
< #define SW_HTTP_UPLOAD_TMP_FILE          "/tmp/zan.upfile.XXXXXX"
---
> #define SW_HTTP_UPLOAD_TMP_FILE          "/tmp/swoole.upfile.XXXXXX"
Only in ./zan-extension/: swoole_connpool.c
diff -r ./zan-extension/swoole_event.c ../swoole-1.8.5-stable/swoole_event.c
20c20
< #include "swSignal.h"
---
> 
24,26c24,29
< 	zval _cb_read;
<     zval _cb_write;
<     zval _socket;
---
>     struct
>     {
>         zval cb_read;
>         zval cb_write;
>         zval socket;
>     } stack;
48,57d50
< static sw_inline void defer_free(void* data)
< {
< 	php_reactor_fd* ev_set = (php_reactor_fd*)data;
< 
< 	if (ev_set && ev_set->cb_read) {sw_zval_ptr_dtor(&(ev_set->cb_read));ev_set->cb_read = NULL;}
< 	if (ev_set && ev_set->cb_write)  {sw_zval_ptr_dtor(&(ev_set->cb_write));ev_set->cb_write = NULL;}
< 	if (ev_set && ev_set->socket) {sw_zval_ptr_dtor(&(ev_set->socket));ev_set->socket = NULL;}
< 	swoole_efree(ev_set);
< }
< 
60,62c53,54
< 
<     SWOOLE_FETCH_TSRMLS;
< 
---
>     zval *retval;
>     zval **args[1];
64,69d55
<     if (!fd || !fd->socket || !fd->cb_read)
< 	{
< 		swWarn("read callback is null,user error");
< 		SwooleG.main_reactor->del(SwooleG.main_reactor, event->fd);
< 		return SW_OK;
< 	}
71c57,60
<     zval **args[1];
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
73d61
<     zval *retval = NULL;
77c65
<         swWarn("swoole_event: onRead handler error.");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event: onRead handler error.");
81d68
< 
86,87c73
< 
<     if (retval)
---
>     if (retval != NULL)
91d76
< 
96a82,84
>     zval *retval;
>     zval **args[1];
>     php_reactor_fd *fd = event->socket->object;
98c86,88
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
100,103c90,92
<     php_reactor_fd *fd = event->socket->object;
<     if (!fd || !fd->socket || !fd->cb_write)
< 	{
< 		return swReactor_onWrite(reactor, event);
---
>     if (!fd->cb_write)
>     {
>         return swReactor_onWrite(reactor, event);
106d94
<     zval **args[1];
108c96
<     zval *retval = NULL;
---
> 
111c99
<         swWarn("swoole_event: onWrite handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event: onWrite handler error");
115d102
< 
120,121c107
< 
<     if (retval)
---
>     if (retval != NULL)
125d110
< 
132c117,119
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
134c121
<     int error = 0;
---
>     int error;
135a123
> 
138c126
<         swWarn("swoole_event->onError[1]: getsockopt[sock=%d] failed. Error: %s[%d]", event->fd, strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event->onError[1]: getsockopt[sock=%d] failed. Error: %s[%d]", event->fd, strerror(errno), errno);
143c131
<         swWarn("swoole_event->onError[1]: socket error. Error: %s [%d]", strerror(error), error);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event->onError[1]: socket error. Error: %s [%d]", strerror(error), error);
146,147c134
<     swoole_efree(event->socket->object);
<     event->socket->object = NULL;
---
>     efree(event->socket->object);
157,158d143
<     SWOOLE_FETCH_TSRMLS;
< 
161c146,150
<     zval *retval = NULL;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     zval *retval;
164c153,154
<         swWarn("swoole_event: defer handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event: defer handler error");
>         return;
166d155
< 
171,172c160
< 
<     if (retval)
---
>     if (retval != NULL)
176,183c164,165
< 
<     if (defer->callback)
<     {
<         sw_zval_ptr_dtor(&defer->callback);
<     	defer->callback = NULL;
<     }
< 
<     swoole_efree(defer);
---
>     sw_zval_ptr_dtor(&defer->callback);
>     efree(defer);
195,196c177,179
<     SWOOLE_FETCH_TSRMLS;
< 
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
216a200,201
>     php_stream *stream;
>     int socket_fd;
218,223c203,205
<     SWOOLE_FETCH_TSRMLS;
<     if (!zfd || Z_TYPE_P(zfd) == IS_NULL)
<     {
<     	swWarn("zfd is null.");
<     	return SW_ERR;
<     }
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
225c207,209
<     int socket_fd = -1;
---
> #ifdef SWOOLE_SOCKETS_SUPPORT
>     php_socket *php_sock;
> #endif
228,229c212
<     	php_stream *stream = NULL;
<         if (SW_ZEND_FETCH_RESOURCE_NO_RETURN(stream, php_stream*, &zfd, -1, NULL, php_file_le_stream()))
---
>         if (SW_ZEND_FETCH_RESOURCE_NO_RETURN(stream, php_stream *, &zfd, -1, NULL, php_file_le_stream()))
239,240c222
<         	php_socket *php_sock = NULL;
<             if (SW_ZEND_FETCH_RESOURCE_NO_RETURN(php_sock, php_socket*, &zfd, -1, NULL, php_sockets_le_socket()))
---
>             if (SW_ZEND_FETCH_RESOURCE_NO_RETURN(php_sock, php_socket *, &zfd, -1, NULL, php_sockets_le_socket()))
247c229
<                 swWarn("fd argument must be either valid PHP stream or valid PHP socket resource");
---
>                 swoole_php_fatal_error(E_WARNING, "fd argument must be either valid PHP stream or valid PHP socket resource");
251c233
<             swWarn("fd argument must be valid PHP stream resource");
---
>             swoole_php_fatal_error(E_WARNING, "fd argument must be valid PHP stream resource");
258a241,245
>         if (socket_fd < 0)
>         {
>             swoole_php_fatal_error(E_WARNING, "invalid file descriptor passed");
>             return SW_ERR;
>         }
260,261c247,251
< 
<     return socket_fd < 0? SW_ERR:socket_fd;
---
>     else
>     {
>         return SW_ERR;
>     }
>     return socket_fd;
263a254
> #ifdef SWOOLE_SOCKETS_SUPPORT
266,270c257,260
< #ifdef SWOOLE_SOCKETS_SUPPORT
< 
<     SWOOLE_FETCH_TSRMLS;
< 
<     php_socket *socket_object = emalloc(sizeof(php_socket));
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
>     php_socket *socket_object = emalloc(sizeof *socket_object);
285,286c275,276
< error:
<         swoole_efree(socket_object);
---
>         error:
>         efree(socket_object);
291c281
<     if (t < 0)
---
>     if (t == -1)
300d289
< 
302,304d290
< #else
<     return NULL;
< #endif
305a292
> #endif
311c298,299
<     zval *zfd = NULL;
---
>     zval *zfd;
>     char *func_name = NULL;
314c302
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zzl", &zfd, &cb_read, &cb_write, &event_flag))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zzl", &zfd, &cb_read, &cb_write, &event_flag) == FAILURE)
319,331c307,311
<     int checkRCb = swoole_check_callable(cb_read TSRMLS_CC);
<     int checkWCb = swoole_check_callable(cb_write TSRMLS_CC);
<     if ((event_flag & SW_EVENT_READ) && checkRCb < 0)
< 	{
< 		swWarn("swoole_event: no read callback.");
< 		RETURN_FALSE;
< 	}
< 
< 	if ((event_flag & SW_EVENT_WRITE) && checkWCb < 0)
< 	{
< 		swWarn("swoole_event: no write callback.");
< 		RETURN_FALSE;
< 	}
---
>     if ((cb_read == NULL && cb_write == NULL) || (ZVAL_IS_NULL(cb_read) && ZVAL_IS_NULL(cb_write)))
>     {
>         swoole_php_fatal_error(E_WARNING, "no read or write event callback.");
>         RETURN_FALSE;
>     }
336c316
<         swWarn("unknow type.");
---
>         swoole_php_fatal_error(E_WARNING, "unknow type.");
339d318
< 
341,348d319
< 	{
< 		swWarn("socket fd [%d] is std input,but used write event", socket_fd);
< 		RETURN_FALSE;
< 	}
< 
<     php_swoole_check_reactor();
<     swConnection *socket = swReactor_get(SwooleG.main_reactor, socket_fd);
<     if (!socket || socket->active)
350,351c321,322
<     	swWarn("socket[%d] is not found in the reactor or socket has been actived.", socket_fd);
<     	RETURN_FALSE;
---
>         swoole_php_fatal_error(E_WARNING, "invalid socket fd [%d].", socket_fd);
>         RETURN_FALSE;
354,355c325,336
<     php_reactor_fd *reactor_fd = (socket->object)? socket->object:emalloc(sizeof(php_reactor_fd));
<     if (!reactor_fd)
---
>     php_reactor_fd *reactor_fd = emalloc(sizeof(php_reactor_fd));
> 
> #if PHP_MAJOR_VERSION < 7
>     reactor_fd->cb_read = cb_read;
>     reactor_fd->cb_write = cb_write;
>     reactor_fd->socket = zfd;
> #else
>     reactor_fd->cb_read = &reactor_fd->stack.cb_read;
>     reactor_fd->cb_write = &reactor_fd->stack.cb_write;
>     reactor_fd->socket = &reactor_fd->stack.socket;
>     memcpy(reactor_fd->socket, zfd, sizeof(zval));
>     if (cb_read)
357,358c338
<     	swWarn("alloc global memory failed");
<     	RETURN_FALSE;
---
>         memcpy(reactor_fd->cb_read, cb_read, sizeof(zval));
359a340,344
>     if (cb_write)
>     {
>         memcpy(reactor_fd->cb_write, cb_write, sizeof(zval));
>     }
> #endif
360a346
>     sw_zval_add_ref(&reactor_fd->socket);
362,368c348
<     reactor_fd->cb_read = (checkRCb < 0)? NULL:cb_read;
<     reactor_fd->cb_write = (checkWCb < 0)? NULL:cb_write;
<     reactor_fd->socket = zfd;
< 
<     sw_zval_add_ref(&zfd);
<     sw_copy_to_stack(reactor_fd->socket,reactor_fd->_socket);
<     if (checkRCb >= 0)
---
>     if (cb_read!= NULL && !ZVAL_IS_NULL(cb_read))
370,371c350,357
<     	sw_zval_add_ref(&cb_read);
<     	sw_copy_to_stack(reactor_fd->cb_read,reactor_fd->_cb_read);
---
>         if (!sw_zend_is_callable(cb_read, 0, &func_name TSRMLS_CC))
>         {
>             swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>             efree(func_name);
>             RETURN_FALSE;
>         }
>         efree(func_name);
>         sw_zval_add_ref(&reactor_fd->cb_read);
374c360
<     if (checkWCb >= 0)
---
>     if (cb_write!= NULL && !ZVAL_IS_NULL(cb_write))
376,377c362,369
<     	sw_zval_add_ref(&cb_write);
<     	sw_copy_to_stack(reactor_fd->cb_write,reactor_fd->_cb_write);
---
>         if (!sw_zend_is_callable(cb_write, 0, &func_name TSRMLS_CC))
>         {
>             swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>             efree(func_name);
>             RETURN_FALSE;
>         }
>         efree(func_name);
>         sw_zval_add_ref(&reactor_fd->cb_write);
380c372,373
<     swSetNonBlock(socket_fd,1); //must be nonblock
---
>     php_swoole_check_reactor();
>     swSetNonBlock(socket_fd); //must be nonblock
384c377
<         swWarn("swoole_event_add failed.");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event_add failed.");
387a381
>     swConnection *socket = swReactor_get(SwooleG.main_reactor, socket_fd);
395a390,393
>     zval *zfd;
>     char *data;
>     zend_size_t len;
>     
398c396
<         swWarn("reactor no ready, cannot swoole_event_write.");
---
>         swoole_php_fatal_error(E_WARNING, "reactor no ready, cannot swoole_event_write.");
401,405c399,400
< 
<     zval *zfd = NULL;
< 	char *data = NULL;
< 	zend_size_t len = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zs", &zfd, &data, &len))
---
>     
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zs", &zfd, &data, &len) == FAILURE)
410c405
<     if (!data || len <= 0)
---
>     if (len <= 0)
412c407
<         swWarn("data empty.");
---
>         swoole_php_fatal_error(E_WARNING, "data empty.");
419c414
<         swWarn("unknow type.");
---
>         swoole_php_fatal_error(E_WARNING, "unknow type.");
427,428c422,425
< 
<     RETURN_TRUE;
---
>     else
>     {
>         RETURN_TRUE;
>     }
433,438d429
< 	if (!SwooleG.main_reactor)
< 	{
< 		swWarn("reactor no ready, cannot swoole_event_set.");
< 		RETURN_FALSE;
< 	}
< 
441c432,434
<     zval *zfd = NULL;
---
>     zval *zfd;
> 
>     char *func_name = NULL;
443c436,437
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zzl", &zfd, &cb_read, &cb_write, &event_flag))
---
>     
>     if (!SwooleG.main_reactor)
445c439,440
<         return;
---
>         swoole_php_fatal_error(E_WARNING, "reactor no ready, cannot swoole_event_set.");
>         RETURN_FALSE;
448,460c443,446
<     int checkRCb = swoole_check_callable(cb_read TSRMLS_CC);
< 	int checkWCb = swoole_check_callable(cb_write TSRMLS_CC);
< 	if ((event_flag & SW_EVENT_READ) && checkRCb < 0)
< 	{
< 		swWarn("swoole_event: no read callback.");
< 		RETURN_FALSE;
< 	}
< 
< 	if ((event_flag & SW_EVENT_WRITE) && checkWCb < 0)
< 	{
< 		swWarn("swoole_event: no write callback.");
< 		RETURN_FALSE;
< 	}
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zzl", &zfd, &cb_read, &cb_write, &event_flag) == FAILURE)
>     {
>         return;
>     }
465c451
<         swWarn("unknow type.");
---
>         swoole_php_fatal_error(E_WARNING, "unknow type.");
469,474d454
<     if (socket_fd == 0 && (event_flag & SW_EVENT_WRITE))
< 	{
< 		swWarn("invalid socket fd [%d].", socket_fd);
< 		RETURN_FALSE;
< 	}
< 
476c456
<     if (!socket || !socket->active)
---
>     if (!socket->active)
478c458,459
<         swWarn("socket[%d] is not found in the reactor or not actice.", socket_fd);
---
>         swoole_php_fatal_error(E_WARNING, "socket[%d] is not found in the reactor.", socket_fd);
>         efree(func_name);
481d461
< 
483c463,484
<     if (!ev_set)
---
> 
>     if (cb_read != NULL && !ZVAL_IS_NULL(cb_read))
>     {
>         if (!sw_zend_is_callable(cb_read, 0, &func_name TSRMLS_CC))
>         {
>             swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>             efree(func_name);
>             RETURN_FALSE;
>         }
>         else
>         {
> #if PHP_MAJOR_VERSION < 7
>             ev_set->cb_read = cb_read;
> #else
>             memcpy(ev_set->cb_read, cb_read, sizeof(zval));
> #endif
>             sw_zval_add_ref(&cb_read);
>             efree(func_name);
>         }
>     }
> 
>     if (cb_write != NULL && !ZVAL_IS_NULL(cb_write))
485,486c486,506
<     	swWarn("socket[%d] has not been set. should set first.",socket_fd);
<     	RETURN_FALSE;
---
>         if (socket_fd == 0 && (event_flag & SW_EVENT_WRITE))
>         {
>             swoole_php_fatal_error(E_WARNING, "invalid socket fd [%d].", socket_fd);
>             RETURN_FALSE;
>         }
>         if (!sw_zend_is_callable(cb_write, 0, &func_name TSRMLS_CC))
>         {
>             swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>             efree(func_name);
>             RETURN_FALSE;
>         }
>         else
>         {
> #if PHP_MAJOR_VERSION < 7
>             ev_set->cb_write = cb_write;
> #else
>             memcpy(ev_set->cb_write, cb_write, sizeof(zval));
> #endif
>             sw_zval_add_ref(&cb_write);
>             efree(func_name);
>         }
489c509
<     if (checkRCb >= 0)
---
>     if ((event_flag & SW_EVENT_READ) && ev_set->cb_read == NULL)
491,494c511,512
<     	if (ev_set->cb_read) sw_zval_ptr_dtor(&(ev_set->cb_read));
<     	ev_set->cb_read = cb_read;
<     	sw_zval_add_ref(&cb_read);
<     	sw_copy_to_stack(ev_set->cb_read,ev_set->_cb_read);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event: no read callback.");
>         RETURN_FALSE;
497c515
<     if (checkWCb >= 0)
---
>     if ((event_flag & SW_EVENT_WRITE) && ev_set->cb_write == NULL)
499,502c517,518
<     	if (ev_set->cb_write)  sw_zval_ptr_dtor(&(ev_set->cb_write));
<     	ev_set->cb_write = cb_write;
<     	sw_zval_add_ref(&cb_write);
<     	sw_copy_to_stack(ev_set->cb_write,ev_set->_cb_write);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event: no write callback.");
>         RETURN_FALSE;
507c523
<         swWarn("swoole_event_set failed.");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event_set failed.");
515a532,533
>     zval *zfd;
>     
518c536
<         swWarn("reactor no ready, cannot swoole_event_del.");
---
>         swoole_php_fatal_error(E_WARNING, "reactor no ready, cannot swoole_event_del.");
521,523c539,540
< 
<     zval *zfd = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zfd))
---
>     
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zfd) == FAILURE)
525c542
<     	RETURN_FALSE;
---
>         return;
531c548
<         swWarn("unknow type.");
---
>         swoole_php_fatal_error(E_WARNING, "unknow type.");
536c553
<     if (!socket)
---
>     if (socket->object)
538,539c555
<     	swWarn("socket[%d] is not found in the reactor",socket_fd);
<     	RETURN_FALSE;
---
>         efree(socket->object);
541,543d556
< 
<     php_reactor_fd *ev_set = socket->object;
<     socket->object = NULL;
545,546c558,559
< 
<     if (ev_set)
---
>     int ret = 0;
>     if (socket->fd)
548c561
<     	SwooleG.main_reactor->defer(SwooleG.main_reactor,defer_free,ev_set);
---
>         ret = SwooleG.main_reactor->del(SwooleG.main_reactor, socket_fd);
550,551d562
< 
<     int ret = (socket->fd >= 0)? SwooleG.main_reactor->del(SwooleG.main_reactor, socket_fd):SW_ERR;
559c570
<         swWarn("reactor no ready, cannot swoole_event_defer.");
---
>         swoole_php_fatal_error(E_WARNING, "reactor no ready, cannot swoole_event_defer.");
563,564c574,575
<     zval *callback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &callback))
---
>     zval *callback;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &callback) == FAILURE)
569,575c580,581
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
< 		return;
< 	}
< 
<     php_defer_callback *defer = emalloc(sizeof(php_defer_callback));
<     if (!defer)
---
>     char *func_name;
>     if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))
577,578c583,585
<     	swWarn("alloc global memory failed");
<     	return;
---
>         swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
>         RETURN_FALSE;
579a587
>     efree(func_name);
580a589,594
>     php_defer_callback *defer = emalloc(sizeof(php_defer_callback));
> 
> #if PHP_MAJOR_VERSION >= 7
>     defer->callback = &defer->_callback;
>     memcpy(defer->callback, callback, sizeof(zval));
> #else
581a596
> #endif
583,584d597
<     sw_copy_to_stack(defer->callback,defer->_callback);
< 
590d602
< 	/// 只针对client 支持事件循环退出
597d608
< 
608d618
< 
diff -r ./zan-extension/swoole_http.h ../swoole-1.8.5-stable/swoole_http.h
28a29,36
> #define HTTP_SERVER_CALLBACK_NUM   3
> 
> enum http_callback_type
> {
>     HTTP_CALLBACK_onRequest = 0,
>     HTTP_CALLBACK_onHandShake = 1,
> };
> 
44d51
< 
47d53
< 
50,53c56
< #ifdef SW_USE_HTTP2
<     swString *post_buffer;
< #endif
< 
---
>     char *post_content;
56,58d58
<     zval *zobject;		/// 对象
< 
<     /// 对象属性
59a60,62
> 
>     zval *zrequest_object;
> 
64a68
>     zval *zrequest;
66,76d69
< 
< #if PHP_MAJOR_VERSION >= 7
<     zval _zobject;
<     zval _zdata;
<     zval _zserver;
<     zval _zheader;
<     zval _zget;
<     zval _zpost;
<     zval _zfiles;
<     zval _zcookie;
< #endif
82d74
<     int release;
85,88c77
<     /// 对象
<     zval *zobject;
< 
<     /// 对象属性
---
>     zval *zresponse_object;
91,95d79
< #if PHP_MAJOR_VERSION >= 7
< 	zval _zobject;
< 	zval _zheader;
< 	zval _zcookie;
< #endif
101d84
<     int refcount;       /// 引用计数，一个http_conext 对象可能被request、response同时持有
103,113c86,96
<     uint16_t end:1;
<     uint16_t send_header :1;
<     uint16_t gzip_enable :1;
<     uint16_t gzip_level :4;
<     uint16_t chunk :1;
<     uint16_t keepalive :1;
<     uint16_t http2 :1;
< 
<     uint16_t request_read :1;
<     uint16_t current_header_name_allocated :1;
<     uint16_t content_sender_initialized :1;
---
>     uint32_t end :1;
>     uint32_t send_header :1;
>     uint32_t gzip_enable :1;
>     uint32_t gzip_level :4;
>     uint32_t chunk :1;
>     uint32_t keepalive :1;
>     uint32_t http2 :1;
> 
>     uint32_t request_read :1;
>     uint32_t current_header_name_allocated :1;
>     uint32_t content_sender_initialized :1;
115a99
>     swString *buffer;
122a107,127
> #if PHP_MAJOR_VERSION >= 7
>     struct
>     {
>         zval zrequest_object;
>         zval zrequest;
>         zval zserver;
>         zval zheader;
>         zval zget;
>         zval zpost;
>         zval zfiles;
>         zval zcookie;
>         zval zdata;
>     } request_stack;
>     struct
>     {
>         zval zresponse_object;
>         zval zheader;
>         zval zcookie;
>     } response_stack;
> #endif
> 
125d129
< 
148a153,154
>     http_context context;
> 
154,158c160,164
< int swoole_websocket_onMessage(swEventData *);
< int swoole_websocket_onHandshake(swListenPort *port, http_context *);
< void swoole_websocket_onOpen(http_context *);
< void swoole_websocket_onRequest(http_context *);
< 
---
> int swoole_websocket_onMessage(swEventData *req);
> int swoole_websocket_onHandshake(swoole_http_client *client);
> void swoole_websocket_onOpen(swoole_http_client *client);
> void swoole_websocket_onReuqest(swoole_http_client *client);
> int swoole_websocket_isset_onMessage(void);
162a169
> void swoole_http_context_free(http_context *ctx TSRMLS_DC);
165,174c172,176
< #define swoole_http_server_array_init(name, class,ctx)    SW_MAKE_STD_ZVAL(z##name);\
< array_init(z##name);\
< zend_update_property(swoole_http_##class##_class_entry_ptr, z##class##_object, ZEND_STRL(#name), z##name TSRMLS_CC);\
< sw_zval_ptr_dtor(&z##name);\
< ctx->class.z##name = sw_zend_read_property(swoole_http_##class##_class_entry_ptr, z##class##_object, ZEND_STRL(#name), 0 TSRMLS_CC);\
< sw_copy_to_stack(ctx->class.z##name, ctx->class._z##name);\
< z##name = ctx->class.z##name;
< 
< #define http_strncasecmp(const_str, at, length) ((length >= sizeof(const_str)-1) &&\
<         (strncasecmp(at, ZEND_STRL(const_str)) == 0))
---
> #if PHP_MAJOR_VERSION >= 7
> #define http_alloc_zval(ctx,object,val)   val = &(ctx)->object##_stack.val; (ctx)->object.val = val
> #else
> #define http_alloc_zval(ctx,object,val)   MAKE_STD_ZVAL(val); (ctx)->object.val = val
> #endif
182d183
< void swoole_http2_free(swoole_http_client *client);
184a186,193
> extern zend_class_entry swoole_http_server_ce;
> extern zend_class_entry *swoole_http_server_class_entry_ptr;
> 
> extern zend_class_entry swoole_http_response_ce;
> extern zend_class_entry *swoole_http_response_class_entry_ptr;
> 
> extern zend_class_entry swoole_http_request_ce;
> extern zend_class_entry *swoole_http_request_class_entry_ptr;
187d195
< #ifdef SW_HAVE_ZLIB
189c197,198
< #endif
---
> 
> extern zval* php_sw_http_server_callbacks[HTTP_SERVER_CALLBACK_NUM];
diff -r ./zan-extension/swoole_http_client.c ../swoole-1.8.5-stable/swoole_http_client.c
19d18
< #include "swProtocol/websocket.h"
25a25,26
> #include "websocket.h"
> 
29a31,36
> #ifdef SW_ASYNC_HTTPCLIENT
> 
> extern swString *swoole_zlib_buffer;
> 
> static swString *http_client_buffer;
> 
31a39
>     HTTP_CLIENT_STATE_WAIT,
34c42
<     ///for  WebSocket
---
>     //WebSocket
36d43
<     HTTP_CLIENT_STATE_WAIT_CLOSE,
39,40d45
< #define SW_CLIENT_CB_onTimeout  (SW_CLIENT_CB_onError+1)
< 
43d47
<     zval *onConnect;
47d50
<     zval *onTimeout;
50,54d52
<     zval *cookies;
<     zval *request_header;
<     zval *request_body;
<     char *request_method;
< 
56,57c54
<     zval _object;
<     zval _onConnect;
---
>     zval _onResponse;
61,64d57
<     zval _onTimeout;
<     zval _cookies;
<     zval _request_header;
<     zval _request_body;
66a60,65
>     zval *cookies;
>     zval *request_header;
>     zval *request_body;
>     char *request_method;
>     int callback_index;
> 
75c74
<     long timeout;
---
>     double timeout;
79c78
<     char *tmp_header_field_name;    //header field string
---
>     char *tmp_header_field_name;
84c83
<     swString *buffer;  //only used for websocket
---
>     swString *buffer;
87c86
<     uint8_t state;       //ready busy wait_close
---
>     uint8_t state;       //0 wait 1 ready 2 busy
89,92c88,89
<     uint8_t upgrade;     //for websocket
<     uint8_t gzip;        //SW_HAVE_ZLIB def, the header is Content-Encoding: gzip  
<     uint8_t chunked;     //Transfer-Encoding: chunked
<     uint8_t completed;   //message_complete
---
>     uint8_t upgrade;
>     uint8_t gzip;
96,101d92
< #ifdef SW_HAVE_ZLIB
< extern swString *swoole_zlib_buffer;
< #endif
< static swString *http_client_buffer;  //buffer append for request line and header
< 
< static void httpClient_timeout(swTimer* timer,swTimer_node* node);
105d95
< static int http_client_parser_on_headers_complete(php_http_parser *parser);
108d97
< static void http_client_execute_callback(zval *zobject, int type);
114,115c103
< static void http_client_free_cb(zval* object);
< 
---
> static int http_client_error_callback(zval *zobject, swEvent *event, int error TSRMLS_DC);
118d105
< static void http_client_free(zval *object TSRMLS_DC);
120a108,127
> static sw_inline void http_client_swString_append_headers(swString* swStr, char* key, zend_size_t key_len, char* data, zend_size_t data_len)
> {
>     swString_append_ptr(swStr, key, key_len);
>     swString_append_ptr(swStr, ZEND_STRL(": "));
>     swString_append_ptr(swStr, data, data_len);
>     swString_append_ptr(swStr, ZEND_STRL("\r\n"));
> }
> 
> static sw_inline void http_client_create_token(int length, char *buf)
> {
>     char characters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"§$%&/()=[]{}";
>     int i;
>     assert(length < 1024);
>     for (i = 0; i < length; i++)
>     {
>         buf[i] = characters[rand() % sizeof(characters) - 1];
>     }
>     buf[length] = '\0';
> }
> 
130c137
<     http_client_parser_on_headers_complete,
---
>     NULL,
135c142
< static zend_class_entry swoole_http_client_ce;
---
> zend_class_entry swoole_http_client_ce;
141d147
< static PHP_METHOD(swoole_http_client,setReqTimeout);
155,210d160
< //check the php method para
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_construct, 0, 0, 1)
<     ZEND_ARG_INFO(0, host)
<     ZEND_ARG_INFO(0, port)
<     ZEND_ARG_INFO(0, ssl)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_set, 0, 0, 1)
<     ZEND_ARG_ARRAY_INFO(0, settings, 0)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_setTimeout, 0, 0, 1)
<     ZEND_ARG_INFO(0,timeout)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_setMethod, 0, 0, 1)
<     ZEND_ARG_INFO(0, method)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_setHeaders, 0, 0, 1)
<     ZEND_ARG_ARRAY_INFO(0, headers, 0)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_setCookies, 0, 0, 1)
< 	ZEND_ARG_ARRAY_INFO(0, cookies,0)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_setData, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_execute, 0, 0, 2)
<     ZEND_ARG_INFO(0, path)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_push, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
<     ZEND_ARG_INFO(0, opcode)
<     ZEND_ARG_INFO(0, finish)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_on, 0, 0, 2)
<     ZEND_ARG_INFO(0, event_name)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_get, 0, 0, 2)
<     ZEND_ARG_INFO(0, path)
< 	ZEND_ARG_INFO(0, args1)
< 	ZEND_ARG_INFO(0, args2)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_post, 0, 0, 3)
<     ZEND_ARG_INFO(0, path)
<     ZEND_ARG_INFO(0, data)
< 	ZEND_ARG_INFO(0, args1)
< 	ZEND_ARG_INFO(0, args2)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_client_upgrade, 0, 0, 2)
<     ZEND_ARG_INFO(0, path)
< 	ZEND_ARG_INFO(0, args1)
< 	ZEND_ARG_INFO(0, args2)
< ZEND_END_ARG_INFO()
< 
213,228c163,177
<     PHP_ME(swoole_http_client, __construct, arginfo_swoole_http_client_construct, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_http_client, __destruct, arginfo_swoole_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_ME(swoole_http_client, set, arginfo_swoole_http_client_set, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_http_client, setReqTimeout, arginfo_swoole_http_client_setTimeout, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, setMethod, arginfo_swoole_http_client_setMethod, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, setHeaders, arginfo_swoole_http_client_setHeaders, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, setCookies, arginfo_swoole_http_client_setCookies, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, setData, arginfo_swoole_http_client_setData, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, execute, arginfo_swoole_http_client_execute, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, push, arginfo_swoole_http_client_push, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, get, arginfo_swoole_http_client_get, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, post, arginfo_swoole_http_client_post, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, upgrade, arginfo_swoole_http_client_upgrade, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, isConnected, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, close, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_client, on, arginfo_swoole_http_client_on, ZEND_ACC_PUBLIC)
---
>     PHP_ME(swoole_http_client, __construct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
>     PHP_ME(swoole_http_client, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
>     PHP_ME(swoole_http_client, set, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, setMethod, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, setHeaders, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, setCookies, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, setData, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, execute, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, push, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, get, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, post, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, upgrade, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, isConnected, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, close, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_client, on, NULL, ZEND_ACC_PUBLIC)
232,239c181
< static sw_inline void defer_close(void* data)
< {
< 	swClient* cli = (swClient*)data;
< 	cli->released = 0;
< 	http_client_onClose(cli);
< }
< 
< static void httpClient_timeout(swTimer* timer,swTimer_node* node)
---
> static int http_client_execute(zval *zobject, char *uri, zend_size_t uri_len, zval *callback TSRMLS_DC)
241,250c183,187
< 	swClient* cli = node? node->data:NULL;
< 	zval *zobject = cli? cli->object:NULL;
< 	if (zobject)
< 	{
< 		cli->timer_id = 0;
< 		http_client_execute_callback(zobject,SW_CLIENT_CB_onTimeout);
< 	}
< 
< 	swTimer_del(timer,node->id);
< }
---
>     if (uri_len <= 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "path is empty.");
>         return SW_ERR;
>     }
252,259c189
< //append headers filed for send_http_request
< static sw_inline void http_client_swString_append_headers(swString* swStr, char* key, zend_size_t key_len, char* data, zend_size_t data_len)
< {
<     swString_append_ptr(swStr, key, key_len);
<     swString_append_ptr(swStr, ZEND_STRL(": "));
<     swString_append_ptr(swStr, data, data_len);
<     swString_append_ptr(swStr, ZEND_STRL("\r\n"));
< }
---
>     http_client *http = swoole_get_object(zobject);
261,270c191,198
< //append request line. buffer: GET/POST uri HTTP/1.1
< static sw_inline void http_client_buffer_append_request_line(swString* swStr, http_client *http, http_client_property *hcc)
< {
<     swString_clear(swStr);
<     swString_append_ptr(swStr, hcc->request_method, strlen(hcc->request_method));
<     hcc->request_method = NULL;
<     swString_append_ptr(swStr, ZEND_STRL(" "));
<     swString_append_ptr(swStr, http->uri, http->uri_len);
<     swString_append_ptr(swStr, ZEND_STRL(" HTTP/1.1\r\n"));
< }
---
>     //http is not null when keeping alive
>     if (http)
>     {
>         //http not ready
>         if (http->state != HTTP_CLIENT_STATE_READY)
>         {
>             //swWarn("fd=%d, state=%d, active=%d, keep_alive=%d", http->cli->socket->fd, http->state, http->cli->socket->active, http->keep_alive);
>             swoole_php_fatal_error(E_WARNING, "Operation now in progress phase %d.", http->state);
272,279c200,203
< //append headers filed of content_length
< static sw_inline void http_client_swString_append_contentlength(swString* buf, int length)
< {
<     char content_length_str[32] = {0};
<     int n = snprintf(content_length_str, sizeof(content_length_str) - 1, "Content-Length: %d\r\n\r\n", length);
<     n = n > 32? 32:n;
<     swString_append_ptr(buf, content_length_str, n);
< }
---
>             swEvent e;
>             e.fd = http->cli->socket->fd;
>             e.socket = http->cli->socket;
>             http_client_error_callback(zobject, &e, errno TSRMLS_CC);
281,287c205,213
< //only used for upgrade method,so just for websocket
< static sw_inline void http_client_create_token(int length, char *buf)
< {
<     char characters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"§$%&/()=[]{}";
<     assert(length < 1024);
<     int index;
<     for (index = 0; index < length; index++)
---
>             return SW_ERR;
>         }
>         else if (!http->cli->socket->active)
>         {
>             swoole_php_fatal_error(E_WARNING, "connection#%d is closed.", http->cli->socket->fd);
>             return SW_ERR;
>         }
>     }
>     else
289c215
<         buf[index] = characters[rand() % sizeof(characters) - 1];
---
>         http = http_client_create(zobject TSRMLS_CC);
292,297c218
<     buf[length] = '\0';
< }
< 
< static int http_client_execute(zval *zobject, char *uri, zend_size_t uri_len, zval *callback TSRMLS_DC)
< {
<     if (uri_len <= 0 || !uri)
---
>     if (http == NULL)
299d219
<         swWarn("path is empty.");
303c223
<     if (callback && !ZVAL_IS_NULL(callback) && swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     if (http->body == NULL)
305c225,230
<     	return SW_ERR;
---
>         http->body = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);
>         if (http->body == NULL)
>         {
>             swoole_php_fatal_error(E_ERROR, "[1] swString_new(%d) failed.", SW_HTTP_RESPONSE_INIT_SIZE);
>             return SW_ERR;
>         }
307,310c232
< 
<     /// http is not null when keeping alive
<     http_client *http = http_client_create(zobject TSRMLS_CC);
<     if (!http)
---
>     else
312c234
<         return SW_ERR;
---
>         swString_clear(http->body);
315,317c237
<     long timeout = 0;
< 	zval* reqTimeout = sw_zend_read_property(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("requestTimeout"), 1 TSRMLS_CC);
<     if (reqTimeout)
---
>     if (http->uri)
319,320c239
<     	convert_to_long(reqTimeout);
<     	timeout = Z_LVAL_P(reqTimeout);
---
>         efree(http->uri);
323,328c242,245
<     if (timeout > 0)
<     {
<     	http->timeout = timeout;
<     }
<     http->body = (!http->body)? swString_new(SW_HTTP_RESPONSE_INIT_SIZE) : http->body;
<     if (!http->body)
---
>     http->uri = estrdup(uri);
>     http->uri_len = uri_len;
> 
>     if (callback == NULL || ZVAL_IS_NULL(callback))
330,331c247
< 		swoole_php_fatal_error(E_ERROR, "[1] swString_new(%d) failed.", SW_HTTP_RESPONSE_INIT_SIZE);
< 		return SW_ERR;
---
>         swoole_php_fatal_error(E_WARNING, "response callback is not set.");
334,335c250,252
<     swString_clear(http->body);
<     http->upgrade = 0;
---
>     http_client_property *hcc = swoole_get_property(zobject, 0);
>     hcc->onResponse = callback;
>     sw_copy_to_stack(hcc->onResponse, hcc->_onResponse);
337,338c254
<     http->gzip = 0;
< 	http->chunked = 0;
---
>     sw_zval_add_ref(&hcc->onResponse);
340,342c256,261
< 	swoole_efree(http->uri);
<     http->uri = estrndup(uri,uri_len);
<     http->uri_len = uri_len;
---
>     //if connection exists
>     if (http->cli)
>     {
>         http_client_send_http_request(zobject TSRMLS_CC);
>         return SW_OK;
>     }
344,346c263,264
<     http_client_property *hcc = swoole_get_property(zobject, swoole_property_common);
<     swClient *cli = http->cli;
<     if (cli->object)
---
>     swClient *cli = php_swoole_client_new(zobject, http->host, http->host_len, http->port);
>     if (cli == NULL)
348,349c266
<     	zval* object = cli->object;
<     	sw_zval_ptr_dtor(&object);
---
>         return SW_ERR;
350a268
>     http->cli = cli;
352c270,279
<     sw_zval_add_ref(&zobject);
---
>     if (cli->socket->active == 1)
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_http_client is already connected.");
>         return SW_ERR;
>     }
> 
> #if PHP_MAJOR_VERSION >= 7
>     cli->object = (zval *) emalloc(sizeof(zval));
>     ZVAL_DUP(cli->object, zobject);
> #else
354c281
<     sw_copy_to_stack(cli->object, hcc->_object);
---
> #endif
356,372c283
< 	if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		hcc->onResponse = NULL;
< 		swWarn("response callback is not set.");
< 	}
< 	else
< 	{
< 		sw_zval_add_ref(&callback);
< 		hcc->onResponse = sw_zval_dup(callback);
< 	}
< 
<     //if connection is active
< 	if (cli->socket->active)
< 	{
< 		http_client_send_http_request(zobject TSRMLS_CC);
< 		return SW_OK;
< 	}
---
>     sw_zval_add_ref(&zobject);
380,400c291
<     /// timeout init at create
<     if (cli->connect(cli, http->host, http->port, http->timeout, 0) < 0)
<     {
<     	swWarn("http connect to server[%s:%d] failed.", http->host, (int )http->port);
<     	return SW_ERR;
<     }
< 
< 	if (cli->async && http->timeout > 0)
< 	{
< 		cli->timer_id = 0;
< 		cli->timer_id = swTimer_add(&SwooleG.timer,http->timeout,0,cli,HTTPCLIENT_USED);
< 		if (cli->timer_id <= 0)
< 		{
< 			swWarn("set recv msg timeout timer failed.");
< 			return SW_ERR;
< 		}
< 
< 		register_after_cb(&SwooleG.timer,HTTPCLIENT_USED,httpClient_timeout);
< 	}
< 
<     return SW_OK;
---
>     return cli->connect(cli, http->host, http->port, http->timeout, 0);
410,423d300
<     zend_declare_property_string(swoole_http_client_class_entry_ptr, SW_STRL("host")-1, "", ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_http_client_class_entry_ptr, SW_STRL("port")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     zend_declare_property_double(swoole_http_client_class_entry_ptr, SW_STRL("requestTimeout")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_client_class_entry_ptr, SW_STRL("headers")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_client_class_entry_ptr, SW_STRL("setting")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     zend_declare_property_null(swoole_http_client_class_entry_ptr, SW_STRL("requestHeaders")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_client_class_entry_ptr, SW_STRL("requestBody")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_client_class_entry_ptr, SW_STRL("requestMethod")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_client_class_entry_ptr, SW_STRL("cookies")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     zend_declare_property_string(swoole_http_client_class_entry_ptr, SW_STRL("body")-1, "", ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_http_client_class_entry_ptr, SW_STRL("statusCode")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
440c317,320
< static void http_client_execute_callback(zval *zobject, int type)
---
> /**
>  * @zobject: swoole_http_client object
>  */
> static void http_client_onClose(swClient *cli)
442c322,324
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
444,445c326,332
<     http_client_property *hcc = swoole_get_property(zobject,swoole_property_common);
<     if (!hcc)
---
>     zval *zcallback = NULL;
>     zval *retval = NULL;
>     zval **args[1];
>     zval *zobject = cli->object;
> 
>     http_client *http = swoole_get_object(zobject);
>     if (!http)
450,470c337,339
<     char *callback_name = NULL;
< 	zval *callback = NULL;
<     switch(type)
<     {
<     case SW_CLIENT_CB_onConnect:
<         callback = hcc->onConnect;
<         callback_name = "onConnect";
<         break;
<     case SW_CLIENT_CB_onError:
<         callback = hcc->onError;
<         callback_name = "onError";
<         break;
<     case SW_CLIENT_CB_onClose:
<         callback = hcc->onClose;
<         callback_name = "onClose";
<         break;
<     case SW_CLIENT_CB_onTimeout:
<     	callback = hcc->onTimeout;
<     	callback_name = "onTimeout";
<     	break;
<     default:
---
>     http_client_property *hcc = swoole_get_property(zobject, 0);
>     if (!hcc)
>     {
473,474c342,343
< 
<     if (!callback || ZVAL_IS_NULL(callback))
---
>     zcallback = hcc->onClose;
>     if (zcallback == NULL || ZVAL_IS_NULL(zcallback))
479,480d347
<     zval *retval = NULL;
< 	zval **args[1];
482,483c349
<     sw_zval_add_ref(&zobject);
<     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
485c351
<         swWarn("swoole_http_client->%s handler error.", callback_name);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_http_client->close[1]: onClose handler error");
487d352
< 
492,535c357,358
< 
<     if (zobject) sw_zval_ptr_dtor(&zobject);
<     if (retval)  sw_zval_ptr_dtor(&retval);
< }
< 
< static void http_client_free_cb(zval* object)
< {
< 	if (!object)
< 	{
< 		return;
< 	}
< 
< 	http_client_property *hcc = swoole_get_property(object, swoole_property_common);
< 	if (!hcc)
< 	{
< 		return;
< 	}
< 
< 	if (hcc->onResponse)
< 	{
< 		zval* responseCb = hcc->onResponse;
< 		hcc->onResponse = NULL;
< 		sw_zval_free(responseCb);
< 	}
< 
< 	if (hcc->onError)  {sw_zval_ptr_dtor(&hcc->onError);hcc->onError = NULL;}
< 	if (hcc->onConnect) {sw_zval_ptr_dtor(&hcc->onConnect);hcc->onConnect = NULL;}
< 	if (hcc->onClose) {sw_zval_ptr_dtor(&hcc->onClose); hcc->onClose = NULL;}
< 	if (hcc->onMessage) {sw_zval_ptr_dtor(&hcc->onMessage);hcc->onMessage = NULL;}
< 	if (hcc->onTimeout) {sw_zval_ptr_dtor(&hcc->onTimeout);hcc->onTimeout = NULL;}
< }
< 
< // @zobject: swoole_http_client object
< static void http_client_onClose(swClient *cli)
< {
<     SWOOLE_FETCH_TSRMLS;
<     if (cli && cli->timer_id > 0)
< 	{
< 		swTimer_del(&SwooleG.timer,cli->timer_id);
< 		cli->timer_id = 0;
< 	}
< 
<     zval *zobject = cli?cli->object:NULL;
<     if (!zobject)
---
>     //free the callback return value
>     if (retval != NULL)
537c360
< 		return;
---
>         sw_zval_ptr_dtor(&retval);
539,541c362
< 
<     http_client *http = swoole_get_object(zobject);
<     if (http && http->state == HTTP_CLIENT_STATE_WAIT_CLOSE)
---
>     if (EG(exception))
543c364
<         http_client_parser_on_message_complete(&http->parser);
---
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
545,561c366
< 
<     if (http)
< 	{
< 		http->state = HTTP_CLIENT_STATE_READY;
< 	}
< 
<     if (cli->released)
< 	{
< 			return;
< 	}
< 
< 	cli->released = 1;
< 
<     http_client_execute_callback(zobject, SW_CLIENT_CB_onClose);
< 
<     http_client_free_cb(zobject);
<     if (cli->object)
---
>     if (!cli->released)
563,565c368
< 		zval* obj = cli->object;
< 		cli->object = NULL;
< 		sw_zval_ptr_dtor(&obj);
---
>         sw_zval_ptr_dtor(&zobject);
569c372,374
< /// @zobject: swoole_http_client object
---
> /**
>  * @zobject: swoole_http_client object
>  */
572,577c377,383
<     SWOOLE_FETCH_TSRMLS;
<     if (cli && cli->timer_id > 0)
< 	{
< 		swTimer_del(&SwooleG.timer,cli->timer_id);
< 		cli->timer_id = 0;
< 	}
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     zval *retval = NULL;
>     zval **args[1];
>     zval *zobject = cli->object;
579,580c385,386
<     zval *zobject = cli? cli->object:NULL;
<     if (!zobject)
---
>     http_client *http = swoole_get_object(zobject);
>     if (!http || !http->cli)
581a388
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_http_client.");
585,607c392,395
<     zend_update_property_long(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("errCode"), SwooleG.error TSRMLS_CC);
<     http_client *http = swoole_get_object(zobject);
< 	if (http)
< 	{
< 	   http->state = HTTP_CLIENT_STATE_READY;
< 	}
<    
< 	if (cli->released)
< 	{
< 		return;
< 	}
< 
< 	cli->released = 1;
< 	http_client_execute_callback(zobject, SW_CLIENT_CB_onError);
< 
< 	http_client_free_cb(zobject);
< 	if (cli->object)
< 	{
< 		zval* obj = cli->object;
< 		cli->object = NULL;
< 		sw_zval_ptr_dtor(&obj);
< 	}
< }
---
>     if (http->cli->socket->closed)
>     {
>         return;
>     }
609,612c397,398
< static void http_client_onReceive(swClient *cli, char *data, uint32_t length)
< {
<     SWOOLE_FETCH_TSRMLS;
<     if (cli && cli->timer_id > 0)
---
>     http_client_property *hcc = swoole_get_property(zobject, 0);
>     if (!hcc)
614,615c400
< 		swTimer_del(&SwooleG.timer,cli->timer_id);
< 		cli->timer_id = 0;
---
>         return;
618,619c403,418
<     zval *zobject = cli? cli->object:NULL;
<     if (!zobject)
---
>     zval *zcallback = hcc->onError;
>     if (zcallback == NULL || ZVAL_IS_NULL(zcallback))
>     {
>         swoole_php_fatal_error(E_ERROR, "swoole_client->onError[1]: no error callback.");
>     }
>     args[0] = &zobject;
>     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC)  == FAILURE)
>     {
>         swoole_php_fatal_error(E_ERROR, "swoole_client->onError[2]: call_user_function failed.");
>     }
>     if (EG(exception))
>     {
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
>     }
>     //free the callback return value
>     if (retval != NULL)
621,622c420
< 		swWarn("http client has no object.");
< 		return;
---
>         sw_zval_ptr_dtor(&retval);
623a422,423
>     sw_zval_ptr_dtor(&zobject);
> }
624a425,431
> static void http_client_onReceive(swClient *cli, char *data, uint32_t length)
> {
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     zval *zobject = cli->object;
626c433
<     if (!http || !http->cli || !http->cli->socket || !cli->socket)
---
>     if (!http->cli)
628c435
<         swWarn("http client is NULL，or object is not instanceof swoole_http_client.");
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_http_client.");
632d438
<     //the branch for websocket   
647d452
<                 zval *zframe = php_swoole_websocket_unpack(buffer TSRMLS_CC);
648a454,457
>                 zval *retval;
> 
>                 zval *zframe = php_swoole_websocket_unpack(buffer TSRMLS_CC);
> 
651,654d459
<                 sw_zval_add_ref(&zobject);
<                 sw_zval_add_ref(&zframe);
<                 http_client_property *hcc = swoole_get_property(zobject, swoole_property_common);
<                 zval *zcallback = hcc->onMessage;
656,658c461,463
<                 zval *retval = NULL;
<                 if (zcallback && !ZVAL_IS_NULL(zcallback) &&
<                 		sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC)  == FAILURE)
---
>                 http_client_property *hcc = swoole_get_property(zobject, 0);
>                 zval *zcallback = hcc->onMessage;
>                 if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC)  == FAILURE)
660c465
<                     swWarn("swoole_http_client->onMessage: onClose handler error");
---
>                     swoole_php_fatal_error(E_ERROR, "swoole_http_client->onMessage: onClose handler error");
666,671d470
< 
<                 if (zframe)
<                 {
<                     sw_zval_ptr_dtor(&zframe);
<                 }
< 
673c472
<                 if (retval)
---
>                 if (retval != NULL)
677c476
< 
---
>                 sw_zval_ptr_dtor(&zframe);
680,682d478
< 
< 				sw_zval_ptr_dtor(&zobject);
<                 sw_zval_ptr_dtor(&zframe);
693a490,494
>             //no length
>             else if (package_length == 0)
>             {
>                 return;
>             }
697,698c498
<             	//no length or extend recv buffer failed,return immediately
<                 if (package_length == 0 || (buffer->size < package_length && swString_extend(buffer, package_length) < 0))
---
>                 if (buffer->size < package_length)
700c500,503
<                      return;
---
>                     if (swString_extend(buffer, package_length) < 0)
>                     {
>                         return;
>                     }
702d504
< 
704a507
> 
716,798d518
<             return ;
<         }
< 
<         //not complete
<         if (!http->completed)
<         {
<            return;
<         }
< 
<         http_client_property *hcc = swoole_get_property(zobject, swoole_property_common);
<         if (!hcc)
<         {
<            swWarn("http_client_parser_on_message_complete hcc is NULL");
<            return;
<         }
< 
<         zval *zcallback = hcc->onResponse;
<         hcc->onResponse = NULL;
<         if (!zcallback || ZVAL_IS_NULL(zcallback))
< 		{
< 		   swWarn("swoole http client object have not receive callback.");
< 		   return;
< 		}
< 
<         zval **args[1];
<         args[0] = &zobject;
<         sw_zval_add_ref(&zobject);
< 
<         if (http->keep_alive)
<         {
<            http->state = HTTP_CLIENT_STATE_READY;
<            http->completed = 0;
<         }
< 
<         zval *retval = NULL;
<         if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
<         {
<             swWarn("onReactorCallback handler error");
<         }
< 
<         if (EG(exception))
<         {
<             zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
<         }
< 
<         if (retval)
<         {
<             sw_zval_ptr_dtor(&retval);
<         }
< 
<         //释放回调前所持有的callback
<         sw_zval_free(zcallback);
< 
<         int socket_close = (cli->released || !cli->socket || cli->socket->closed);
< 		sw_zval_ptr_dtor(&zobject);
< 
< 		if (socket_close)
< 		{
< 			return;
< 		}
< 
<         /// TODO: Sec-WebSocket-Accept check
<         if (http->upgrade)
<         {
<             http->state = HTTP_CLIENT_STATE_UPGRADE;
<             http->buffer = swString_new(SW_HTTP_RESPONSE_INIT_SIZE);
<             if (!http->buffer)
<             {
<                 swoole_php_fatal_error(E_ERROR, "[1] swString_new(%d) failed.", SW_HTTP_RESPONSE_INIT_SIZE);
<                 return;
<             }
< 
<             swString_clear(http->buffer);
<         }
<         else if (http->keep_alive == 0 && http->state != HTTP_CLIENT_STATE_WAIT_CLOSE)
<         {
< //            retval = NULL;
< //            sw_zend_call_method_with_0_params(&zobject, swoole_http_client_class_entry_ptr, NULL, "close", &retval);
< //            if (retval)
< //            {
< //                sw_zval_ptr_dtor(&retval);
< //            }
<         		cli->close(cli);
805c525,527
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
808,813d529
<     if (!zobject)
<     {
<     	swWarn("http client has no object.");
<     	return;
<     }
< 
815c531
<     if (!(http && http->cli && http->cli->socket)) 
---
>     if (!http->cli)
817c533
<         swWarn("http_client is NULL,or object is not instanceof swoole_http_client,or socket is NULL");
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_http_client.");
820,821d535
< 
<     http_client_execute_callback(zobject, SW_CLIENT_CB_onConnect);
826,827d539
< static inline char* sw_http_build_query(zval *data, zend_size_t *length, smart_str *formstr TSRMLS_DC)
< {
828a541,544
> static inline char* sw_http_build_query(zval *data, zend_size_t *length TSRMLS_DC)
> {
>     smart_str formstr = {0};
> 
830c546
<     if (php_url_encode_hash_ex(HASH_OF(data), formstr, NULL, 0, NULL, 0, NULL, 0, NULL, NULL TSRMLS_CC) == FAILURE)
---
>     if (php_url_encode_hash_ex(HASH_OF(data), &formstr, NULL, 0, NULL, 0, NULL, 0, NULL, NULL TSRMLS_CC) == FAILURE)
832c548
<     if (php_url_encode_hash_ex(HASH_OF(data), formstr, NULL, 0, NULL, 0, NULL, 0, NULL, NULL, (int) PHP_QUERY_RFC1738 TSRMLS_CC) == FAILURE)
---
>     if (php_url_encode_hash_ex(HASH_OF(data), &formstr, NULL, 0, NULL, 0, NULL, 0, NULL, NULL, (int) PHP_QUERY_RFC1738 TSRMLS_CC) == FAILURE)
835c551
<         if (formstr->c)
---
>         if (formstr.c)
837c553
<             smart_str_free(formstr);
---
>             smart_str_free(&formstr);
839d554
< 
842c557
<     if (!formstr->c)
---
>     if (!formstr.c)
846,848c561,564
<     smart_str_0(formstr);
<     *length = formstr->len;
<     return formstr->c;
---
>     smart_str_0(&formstr);
>     *length = formstr.len;
>     return formstr.c;
> }
850c566,569
<     if (php_url_encode_hash_ex(HASH_OF(data), formstr, NULL, 0, NULL, 0, NULL, 0, NULL, NULL, (int) PHP_QUERY_RFC1738) == FAILURE)
---
> static inline char* sw_http_build_query(zval *data, zend_size_t *length TSRMLS_DC)
> {
>     smart_str formstr = {0};;
>     if (php_url_encode_hash_ex(HASH_OF(data), &formstr, NULL, 0, NULL, 0, NULL, 0, NULL, NULL, (int) PHP_QUERY_RFC1738) == FAILURE)
852c571
<         if (formstr->s)
---
>         if (formstr.s)
854,856c573,575
< 	    smart_str_free(formstr);
< 	}
< 	return NULL;
---
>             smart_str_free(&formstr);
>         }
>         return NULL;
858c577
<     if (!formstr->s)
---
>     if (!formstr.s)
862,865c581,583
<     smart_str_0(formstr);
<     *length = formstr->s->len;
<     return formstr->s->val;
< #endif
---
>     smart_str_0(&formstr);
>     *length = formstr.s->len;
>     return formstr.s->val;
866a585
> #endif
871c590
<     if (!(http && http->cli))
---
>     if (!http->cli)
873c592
<         swWarn("http client is NULL or object is not instanceof swoole_http_client.");
---
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_http_client.");
877c596
<     if (http->cli->socket && http->cli->socket->active == 0)
---
>     if (!http->cli->socket && http->cli->socket->active == 0)
879c598
<         swWarn("server is not connected.");
---
>         swoole_php_error(E_WARNING, "server is not connected.");
885c604
<         swWarn("http client is not ready.");
---
>         swoole_php_error(E_WARNING, "http client is not ready.");
892c611,612
<     http_client_property *hcc = swoole_get_property(zobject, swoole_property_common);
---
> 
>     http_client_property *hcc = swoole_get_property(zobject, 0);
894a615
>     zval *send_header = hcc->request_header;
896,897c617,618
<     //set request_method as get/post
<     if (!hcc->request_method)
---
>     //POST
>     if (post_data)
899c620,631
<         hcc->request_method = (post_data && (Z_TYPE_P(post_data) == IS_ARRAY || Z_TYPE_P(post_data) == IS_STRING)? "POST" : "GET");
---
>         if (hcc->request_method == NULL)
>         {
>             hcc->request_method = "POST";
>         }
>     }
>     //GET
>     else
>     {
>         if (hcc->request_method == NULL)
>         {
>             hcc->request_method = "GET";
>         }
902c634,644
<     http_client_buffer_append_request_line(http_client_buffer, http, hcc);
---
>     swString_clear(http_client_buffer);
>     swString_append_ptr(http_client_buffer, hcc->request_method, strlen(hcc->request_method));
>     hcc->request_method = NULL;
>     swString_append_ptr(http_client_buffer, ZEND_STRL(" "));
>     swString_append_ptr(http_client_buffer, http->uri, http->uri_len);
>     swString_append_ptr(http_client_buffer, ZEND_STRL(" HTTP/1.1\r\n"));
> 
>     char *key;
>     uint32_t keylen;
>     int keytype;
>     zval *value;
904,908d645
<     char *key = NULL;
<     uint32_t keylen = 0;
<     int keytype = 0;
<     zval *value = NULL;
<     zval *send_header = hcc->request_header;
911,917c648
<         int con_res = sw_zend_hash_find(Z_ARRVAL_P(send_header), ZEND_STRS("Connection"), (void **)&value);
<         if ((con_res == FAILURE && http->keep_alive) || (con_res == SUCCESS && strcasecmp(Z_STRVAL_P(value), "keep-alive") == 0))
<         {
<             http->keep_alive = 1;
<             http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("keep-alive"));
<         }
<         else if ((con_res == FAILURE && !http->keep_alive) || (con_res == SUCCESS && strcasecmp( Z_STRVAL_P(value), "closed") == 0))
---
>         if (sw_zend_hash_find(Z_ARRVAL_P(send_header), ZEND_STRS("Connection"), (void **) &value) == FAILURE)
919,920c650,657
<             http->keep_alive = 0;
<             http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("closed"));
---
>             if (http->keep_alive)
>             {
>                 http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("keep-alive"));
>             }
>             else
>             {
>                 http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("closed"));
>             }
940d676
< 
947,950c683,684
<         if(http->keep_alive)
<             http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("keep-alive"));
<         else
<             http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("closed"));
---
>         http_client_swString_append_headers(http_client_buffer, ZEND_STRL("Connection"), ZEND_STRL("keep-alive"));
>         http->keep_alive = 1;
960a695,696
>         int i = 0;
>         char *encoded_value;
962d697
<         int index = 0;
964c699
<             index++;
---
>             i ++;
969d703
< 
974,975c708,709
<             int encoded_value_len = 0;
<             char *encoded_value = sw_php_url_encode( Z_STRVAL_P(value), Z_STRLEN_P(value), &encoded_value_len);
---
>             int encoded_value_len;
>             encoded_value = sw_php_url_encode( Z_STRVAL_P(value), Z_STRLEN_P(value), &encoded_value_len);
979c713
<                 swoole_efree(encoded_value);
---
>                 efree(encoded_value);
981,982c715
< 
<             if (index < n_cookie)
---
>             if (i < n_cookie)
986d718
< 
992a725,727
>         char content_length_str[32];
>         int n;
> 
995c730
<             zend_size_t len = 0;
---
>             zend_size_t len;
997,999c732,733
<             smart_str formstr_s = {0};
<             char *formstr = sw_http_build_query(post_data, &len, &formstr_s TSRMLS_CC);
<             if (!formstr)
---
>             char *formstr = sw_http_build_query(post_data, &len TSRMLS_CC);
>             if (formstr == NULL)
1001c735
<                 swWarn("http_build_query failed.");
---
>                 swoole_php_error(E_WARNING, "http_build_query failed.");
1004,1005c738,739
< 
<             http_client_swString_append_contentlength(http_client_buffer, len);
---
>             n = snprintf(content_length_str, sizeof(content_length_str), "Content-Length: %d\r\n\r\n", len);
>             swString_append_ptr(http_client_buffer, content_length_str, n);
1007,1012c741
<             smart_str_free(&formstr_s);
<         }
<         else if (Z_TYPE_P(post_data) == IS_STRING)
<         {
<             http_client_swString_append_contentlength(http_client_buffer,Z_STRLEN_P(post_data));
<             swString_append_ptr(http_client_buffer, Z_STRVAL_P(post_data), Z_STRLEN_P(post_data));
---
>             efree(formstr);
1016c745,747
<         	swString_append_ptr(http_client_buffer, ZEND_STRL("\r\n"));
---
>             n = snprintf(content_length_str, sizeof(content_length_str), "Content-Length: %d\r\n\r\n", Z_STRLEN_P(post_data));
>             swString_append_ptr(http_client_buffer, content_length_str, n);
>             swString_append_ptr(http_client_buffer, Z_STRVAL_P(post_data), Z_STRLEN_P(post_data));
1027c758
<     swTrace("[%d]: %s\n", (int)http_client_buffer->length, http_client_buffer->str);
---
>     swTrace("[%d]: %s\n", http_client_buffer->length, http_client_buffer->str);
1036d766
< 
1040,1045c770,775
< /// 该内部接口不触发close 回调.
< static void http_client_free(zval *object TSRMLS_DC)
< {   
<     //host/buffer why not free?
<     http_client *http = swoole_get_object(object);
<     if (!http)
---
> static int http_client_error_callback(zval *zobject, swEvent *event, int error TSRMLS_DC)
> {
>     zval *retval = NULL;
>     zval **args[1];
> 
>     if (error != 0)
1047c777,781
<         return;
---
>         http_client *http = swoole_get_object(zobject);
>         if (http)
>         {
>             swoole_php_fatal_error(E_WARNING, "connect to server [%s:%ld] failed. Error: %s [%d].", http->host, http->port, strerror(error), error);
>         }
1050c784,787
<     swoole_efree(http->uri);
---
>     SwooleG.main_reactor->del(SwooleG.main_reactor, event->fd);
> 
>     http_client_property *hcc = swoole_get_property(zobject, 0);
>     zval *zcallback = hcc->onError;
1052,1056c789
< 	if (http->body)
< 	{
< 		swString_free(http->body);
< 		http->body = NULL;
< 	}
---
>     zend_update_property_long(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("errCode"), error TSRMLS_CC);
1058,1059c791,792
<     //http->buffer only apply to websocket
<     if (http->buffer)
---
>     args[0] = &zobject;
>     if (zcallback == NULL || ZVAL_IS_NULL(zcallback))
1061,1062c794,795
<         swString_free(http->buffer);
<         http->buffer = NULL;
---
>         swoole_php_fatal_error(E_WARNING, "object have not error callback.");
>         return SW_ERR;
1064,1066c797
< 
<     swClient *cli = http->cli;
<     if (cli)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
1068,1070c799,800
<     	http->cli = NULL;
<     	cli->object = NULL;   	/// 将不会触发php 回调
<         php_swoole_client_free(object, cli TSRMLS_CC);
---
>         swoole_php_fatal_error(E_WARNING, "onError handler error");
>         return SW_ERR;
1072c802
<     else
---
>     if (EG(exception))
1074c804
<     	swoole_set_object(object, NULL);
---
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
1076,1077c806,813
< 
<     swoole_efree(http);
---
>     if (retval)
>     {
>         sw_zval_ptr_dtor(&retval);
>     }
>     
>     //printf("sw_zval_ptr_dtor(&zobject) on error;\n");
>     sw_zval_ptr_dtor(&zobject);
>     return SW_OK;
1082,1097c818,820
< 	swClient *cli = NULL;
< 	http_client *http = swoole_get_object(object);
< 	if (http)
< 	{
< 		//http not ready
< 		int connectionActive = http->cli && http->cli->socket && http->cli->socket->active;
< 		if (http->state == HTTP_CLIENT_STATE_READY && connectionActive)
< 		{
< 		//	swWarn("Operation now in progress phase %d,or socket is closed", http->state);
< 			return http;
< 		}
< 		else
< 		{
< 			return NULL;
< 		}
< 	}
---
>     zval *ztmp;
>     http_client *http;
>     HashTable *vht;
1100,1104d822
<     if (!http)
<     {
<     	return NULL;
<     }
< 
1105a824,826
> 
>     swoole_set_object(object, http);
> 
1109c830
<     zval *ztmp = sw_zend_read_property(swoole_http_client_class_entry_ptr, object, ZEND_STRL("host"), 0 TSRMLS_CC);
---
>     ztmp = sw_zend_read_property(swoole_http_client_class_entry_ptr, object, ZEND_STRL("host"), 0 TSRMLS_CC);
1112,1113d832
< 
<     ztmp = NULL;
1118,1119c837,838
<     http->timeout = 0;
<     http->keep_alive = 1;  //default close
---
>     http->timeout = SW_CLIENT_DEFAULT_TIMEOUT;
>     http->keep_alive = 0;
1124,1128c843,847
<     	HashTable *vht = Z_ARRVAL_P(zset);
< 
<         /// timeout
<     	ztmp = NULL;
<         if (php_swoole_array_get_value(vht, "timeout", ztmp))
---
>         vht = Z_ARRVAL_P(zset);
>         /**
>          * timeout
>          */
>         if (sw_zend_hash_find(vht, ZEND_STRS("timeout"), (void **) &ztmp) == SUCCESS)
1130d848
<             convert_to_double(ztmp);
1133,1136c851,854
< 
<         /// keep_alive
<         ztmp = NULL;
<         if (php_swoole_array_get_value(vht, "keep_alive", ztmp))
---
>         /**
>          * keep_alive
>          */
>         if (sw_zend_hash_find(vht, ZEND_STRS("keep_alive"), (void **) &ztmp) == SUCCESS)
1138d855
<             convert_to_boolean(ztmp);
1143,1168d859
< 	cli = http->cli;
< 	if (cli && cli->released)
< 	{
< 		return NULL;
< 	}
< 
< 	if (cli)
<     {
< 		if (cli->object) {
< 			zval* object = cli->object;
< 			sw_zval_ptr_dtor(&object);
< 			cli->object = NULL;
< 		}
< 
<     	php_swoole_client_free(object,cli TSRMLS_DC);
<     }
< 
< 	swoole_set_object(object, http);
<     cli = php_swoole_client_new(object, http->host, http->host_len, http->port,&cli);
<     if (!cli)
<     {
<     	swoole_php_sys_error(E_WARNING, "http create client[%s:%d] failed.", http->host, (int )http->port);
<         return NULL;
<     }
< 
<     http->cli = cli;
1170c861
<     
---
> 
1176,1177c867,868
<     char *host = NULL;
<     zend_size_t host_len = 0;
---
>     char *host;
>     zend_size_t host_len;
1180c871,872
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|lb", &host, &host_len, &port, &ssl))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|lb", &host, &host_len, &port, &ssl) == FAILURE)
1185c877
<     if (!host || host_len <= 0)
---
>     if (host_len <= 0)
1187c879
<         zend_throw_exception(zend_exception_get_default(), "construct swoole_http_client host is empty", 0 TSRMLS_CC);
---
>         swoole_php_fatal_error(E_ERROR, "host is empty.");
1191,1192c883,886
<     zend_update_property_stringl(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("host"), host, host_len TSRMLS_CC);   
<     zend_update_property_long(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("port"), port TSRMLS_CC);
---
>     zend_update_property_stringl(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("host"), host, host_len TSRMLS_CC);
>     
>     zend_update_property_long(swoole_http_client_class_entry_ptr,
>     getThis(), ZEND_STRL("port"), port TSRMLS_CC);
1194d887
< 	//check here
1196,1197c889,890
<     
< 	//init
---
> 
>     //init
1200c893
<     zval *headers = NULL;
---
>     zval *headers;
1206c899
<     http_client_property *hcc = NULL;
---
>     http_client_property *hcc;
1209c902
<     swoole_set_property(getThis(), swoole_property_common, hcc);
---
>     swoole_set_property(getThis(), 0, hcc);
1212,1214c905,908
< #ifdef SW_USE_OPENSSL
<     flags |= (ssl)? SW_SOCK_SSL:0;
< #endif
---
>     if (ssl)
>     {
>         flags |= SW_SOCK_SSL;
>     }
1223,1226c917,948
< //	swWarn("destruct http client.");
< 	http_client_free(getThis() TSRMLS_CC);
< 
< 	http_client_free_cb(getThis());
---
>     http_client *http = swoole_get_object(getThis());
>     if (http)
>     {
>         swClient *cli = http->cli;
>         if (cli)
>         {
>             cli->released = 1;
>             if (cli->socket->closed)
>             {
>                 php_swoole_client_free(getThis(), cli TSRMLS_CC);
>             }
>             else if(!cli->keep)
>             {
>                 cli->close(cli);
>                 php_swoole_client_free(getThis(), cli TSRMLS_CC);
>             }
>             http->cli = NULL;
>         }
>         if (http->uri)
>         {
>             efree(http->uri);
>         }
>         if (http->body)
>         {
>             swString_free(http->body);
>         }
>         if (http->buffer)
>         {
>             swString_free(http->buffer);
>         }
>         efree(http);
>     }
1228,1230c950,952
< 	http_client_property *hcc = swoole_get_property(getThis(),swoole_property_common);
< 	swoole_efree(hcc);
< 	swoole_set_property(getThis(), swoole_property_common, NULL);
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
>     efree(hcc);
>     swoole_set_property(getThis(), 0, NULL);
1235,1236c957,958
<     zval *zset = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset))
---
>     zval *zset;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset) == FAILURE)
1240d961
< 
1245,1257d965
< static PHP_METHOD(swoole_http_client,setReqTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &timeout))
< 	{
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
< 	}
< 
< 	zend_update_property_long(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("requestTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE;
< }
< 
1260,1261c968,969
<     zval *headers = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &headers))
---
>     zval *headers;
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &headers) == FAILURE)
1265d972
< 
1267,1272c974
<     http_client_property *hcc = swoole_get_property(getThis(), swoole_property_common);
<     if (!hcc)
<     {
<         swWarn("http_client_property is NULL ");
<         RETURN_FALSE;
<     }
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
1273a976,978
> #if PHP_MAJOR_VERSION < 7
>     hcc->request_header = headers;
> #else
1275c980,981
<     sw_copy_to_stack(hcc->request_header,hcc->_request_header);
---
> #endif
> 
1281,1282c987,988
<     zval *cookies = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &cookies))
---
>     zval *cookies;
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &cookies) == FAILURE)
1286d991
< 
1288,1293c993
<     http_client_property *hcc = swoole_get_property(getThis(), swoole_property_common);
<     if (!hcc)
<     {
<         swWarn("http_client_property is NULL ");
<         RETURN_FALSE;
<     }
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
1294a995,997
> #if PHP_MAJOR_VERSION < 7
>     hcc->cookies = cookies;
> #else
1296c999
<     sw_copy_to_stack(hcc->cookies,hcc->_cookies);
---
> #endif
1303,1304c1006,1007
<     zval *data = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data))
---
>     zval *data;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE)
1308,1315d1010
< 
<     /// post_data 参数可以为空或者null. post_data存在时，必须为string类型或者array 类型
< 	if (data && !ZVAL_IS_NULL(data) && Z_TYPE_P(data) != IS_ARRAY && Z_TYPE_P(data) != IS_STRING)
< 	{
< 		swWarn("post data must be string or array.");
< 		RETURN_FALSE;
< 	}
< 
1317,1323c1012
<     http_client_property *hcc = swoole_get_property(getThis(), swoole_property_common);
<     if (!hcc)
<     {
<         swWarn("http_client_property is NULL ");
<         RETURN_FALSE;
<     }
< 
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
1325,1326d1013
<     sw_copy_to_stack(hcc->request_body,hcc->_request_body);
< 
1332,1352c1019,1028
<     zval *method = NULL;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &method))
< 	{
< 		return;
< 	}
< 
< 	convert_to_string(method);
< 	zend_update_property(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("requestMethod"),
< 																			method TSRMLS_CC);
< 	http_client_property *hcc = swoole_get_property(getThis(), swoole_property_common);
< 	if (!hcc)
< 	{
< 		swWarn("http_client_property is NULL ");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* tmpMethod = sw_zend_read_property(swoole_http_client_class_entry_ptr, getThis(),
< 													ZEND_STRL("requestMethod"), 1 TSRMLS_CC);
< 													
< 	hcc->request_method = Z_STRVAL_P(tmpMethod);
< 	RETURN_TRUE;
---
>     zval *method;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &method) == FAILURE)
>     {
>         return;
>     }
>     convert_to_string(method);
>     zend_update_property(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("requestMethod"), method TSRMLS_CC);
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
>     hcc->request_method = Z_STRVAL_P(method);
>     RETURN_TRUE;
1358c1034,1038
<     if (!http || !http->cli || !http->cli->socket)
---
>     if (!http || !http->cli)
>     {
>         RETURN_FALSE;
>     }
>     if (!http->cli->socket)
1362d1041
< 
1368,1401c1047,1068
< 	http_client *http = swoole_get_object(getThis());
< 	if(!http)
< 	{
< 		swWarn("have no http client object.");
< 		RETURN_FALSE;
< 	}
< 
< 	swClient *cli = http->cli;
< 	if (!cli || cli->released || !cli->socket || cli->socket->closed)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	int ret = 1;
< 	zend_bool force = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &force))
< 	{
< 		return;
< 	}
< 
<     zval* obj = cli->object;
<     /// 将不触发php 回调
<     cli->object = NULL;
< 	ret = cli->close(cli);
< 
< 	/// 手动触发回调
< 	if (obj)
< 	{
< 		cli->object = obj;
< 		cli->released = 1;
< 		SwooleG.main_reactor->defer(SwooleG.main_reactor,defer_close,cli);
< //		http_client_onClose(cli);
< 	}
< 
---
>     http_client *http = swoole_get_object(getThis());
>     swClient *cli = http->cli;
>     if (!cli)
>     {
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_http_client.");
>         RETURN_FALSE;
>     }
>     if (!cli->socket)
>     {
>         swoole_php_error(E_WARNING, "not connected to the server");
>         RETURN_FALSE;
>     }
>     if (cli->socket->closed)
>     {
>         swoole_php_error(E_WARNING, "client socket is closed.");
>         RETURN_FALSE;
>     }
>     int ret = SW_OK;
>     if (!cli->keep || swConnection_error(SwooleG.error) == SW_CLOSE)
>     {
>         ret = cli->close(cli);
>     }
1407,1412c1074,1076
< 	http_client_property *hcc = swoole_get_property(getThis(), swoole_property_common);
< 	if (!hcc)
< 	{
< 		swWarn("http_client_property is NULL ");
< 		RETURN_FALSE;
< 	}
---
>     char *cb_name;
>     zend_size_t cb_name_len;
>     zval *zcallback;
1414,1423c1078
<     char *cb_name = NULL;
<     zend_size_t cb_name_len = 0;
<     zval *zcallback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &cb_name, &cb_name_len, &zcallback))
<     {
<     	swWarn("parse user set parameters error.");
<     	RETURN_FALSE;
<     }
<     
<     if (cb_name_len <= 0 || !cb_name || swoole_check_callable(zcallback TSRMLS_CC) < 0)
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &cb_name, &cb_name_len, &zcallback) == FAILURE)
1425c1080
<     	RETURN_FALSE;
---
>         return;
1428,1434c1083,1084
<     if (cb_name_len == strlen("error") && strncasecmp("error", cb_name, cb_name_len) == 0)
<     {
<     	if (hcc->onError) sw_zval_ptr_dtor(&hcc->onError);
<     	hcc->onError = zcallback;
<         sw_copy_to_stack(hcc->onError ,hcc->_onError);
<     }
<     else if (cb_name_len == strlen("timeout") && strncasecmp("timeout",cb_name,cb_name_len) == 0)
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
>     if (strncasecmp("error", cb_name, cb_name_len) == 0)
1436,1438c1086,1088
<     	if (hcc->onTimeout) sw_zval_ptr_dtor(&hcc->onTimeout);
<     	hcc->onTimeout = zcallback;
<     	sw_copy_to_stack(hcc->onTimeout ,hcc->_onTimeout);
---
>         zend_update_property(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("onError"), zcallback TSRMLS_CC);
>         hcc->onError = sw_zend_read_property(swoole_http_client_class_entry_ptr,  getThis(), ZEND_STRL("onError"), 0 TSRMLS_CC);
>         sw_copy_to_stack(hcc->onError, hcc->_onError);
1440c1090
<     else if (cb_name_len == strlen("connect") && strncasecmp("connect", cb_name, cb_name_len) == 0)
---
>     else if (strncasecmp("close", cb_name, cb_name_len) == 0)
1442,1444c1092,1094
<     	if (hcc->onConnect) sw_zval_ptr_dtor(&hcc->onConnect);
<         hcc->onConnect = zcallback;
<         sw_copy_to_stack(hcc->onConnect,hcc->_onConnect);
---
>         zend_update_property(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("onClose"), zcallback TSRMLS_CC);
>         hcc->onClose = sw_zend_read_property(swoole_http_client_class_entry_ptr,  getThis(), ZEND_STRL("onClose"), 0 TSRMLS_CC);
>         sw_copy_to_stack(hcc->onClose, hcc->_onClose);
1446c1096
<     else if (cb_name_len == strlen("close") && strncasecmp("close", cb_name, cb_name_len) == 0)
---
>     else if (strncasecmp("message", cb_name, cb_name_len) == 0)
1448,1456c1098,1100
<         if (hcc->onClose) sw_zval_ptr_dtor(&hcc->onClose);
<         hcc->onClose = zcallback;
<         sw_copy_to_stack(hcc->onClose,hcc->_onClose);
<     }
<     else if (cb_name_len == strlen("message") && strncasecmp("message", cb_name, cb_name_len) == 0)
<     {    
<         if (hcc->onMessage) sw_zval_ptr_dtor(&hcc->onMessage);
<         hcc->onMessage = zcallback;
<         sw_copy_to_stack(hcc->onMessage,hcc->_onMessage);
---
>         zend_update_property(swoole_http_client_class_entry_ptr, getThis(), ZEND_STRL("onMessage"), zcallback TSRMLS_CC);
>         hcc->onMessage = sw_zend_read_property(swoole_http_client_class_entry_ptr,  getThis(), ZEND_STRL("onMessage"), 0 TSRMLS_CC);
>         sw_copy_to_stack(hcc->onMessage, hcc->_onMessage);
1460c1104
<         swWarn("swoole_http_client: event callback[%s] is unknow", cb_name);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_http_client: event callback[%s] is unknow", cb_name);
1463,1464d1106
< 
<     sw_zval_add_ref(&zcallback);
1470,1477c1112,1116
<     SWOOLE_FETCH_TSRMLS;
< 
< 	http_client* http = (http_client*)parser->data;
<     if (!http)
<     {
<         swWarn("http_client_parser_on_header_field, http is NULL");
<         return SW_ERR;
<     }
---
> // #if PHP_MAJOR_VERSION < 7
> //     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> // #endif
>     http_client* http = (http_client*)parser->data;
>     //zval* zobject = (zval*)http->cli->socket->object;
1481c1120
<     return SW_OK;
---
>     return 0;
1486c1125,1127
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
1489,1494d1129
<     if (!http || !http->cli)
<     {
<         swWarn("http_client_parser_on_header_value http or http->cli is NULL");
<         return SW_ERR;
<     }
< 
1496,1500c1131
<     if (!zobject)
<     {
<         swWarn("http_client_parser_on_header_value http->cli->obejct is NULL");
<         return SW_ERR;
<     }
---
>     zval *headers = sw_zend_read_property(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("headers"), 0 TSRMLS_CC);
1502,1505d1132
<     zval *headers = sw_zend_read_property(swoole_http_client_class_entry_ptr, zobject,
<     																	ZEND_STRL("headers"), 0 TSRMLS_CC);
< 
<     /// zend_str_tolower_dup,会emalloc 并返回给header_name,需要外部来进行释放
1508d1134
< 
1510,1511c1136
<     if (strncasecmp(header_name, "Upgrade",strlen("Upgrade")) == 0 &&
<     					strncasecmp(at, "websocket", length) == 0)
---
>     if (strcasecmp(header_name, "Upgrade") == 0 && strncasecmp(at, "websocket", length) == 0)
1515c1140
<     else if (strncasecmp(header_name, "Set-Cookie",strlen("Set-Cookie")) == 0)
---
>     else if (strcasecmp(header_name, "Set-Cookie") == 0)
1517c1142
<         int l_cookie = strchr(at, ';')? (strchr(at, ';') - at):(strstr(at, "\r\n") - at);
---
>         int l_cookie = strchr(at, ';') - at;
1518a1144
>         char keybuf[SW_HTTP_COOKIE_KEYLEN];
1521c1147
<         if (!cookies || ZVAL_IS_NULL(cookies) || Z_TYPE_P(cookies) != IS_ARRAY)
---
>         if (!cookies || ZVAL_IS_NULL(cookies))
1523,1528c1149,1152
<         	zval* tmp = NULL;
<             SW_MAKE_STD_ZVAL(tmp);
<             array_init(tmp);
<             zend_update_property(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("cookies"), tmp TSRMLS_CC);
<             cookies = sw_zend_read_property(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("cookies"), 1 TSRMLS_CC);
<             sw_zval_ptr_dtor(&tmp);
---
>             SW_MAKE_STD_ZVAL(cookies);
>             array_init(cookies);
>             zend_update_property(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("cookies"), cookies TSRMLS_CC);
>             sw_zval_ptr_dtor(&cookies);
1531d1154
<         char keybuf[SW_HTTP_COOKIE_KEYLEN] = {0};
1537,1538c1160
<     else if (strncasecmp(header_name, "Content-Encoding",strlen("Content-Encoding")) == 0 &&
<     										strncasecmp(at, "gzip", length) == 0)
---
>     else if (strcasecmp(header_name, "Content-Encoding") == 0 && strncasecmp(at, "gzip", length) == 0)
1543,1549c1165
<     else if (strncasecmp(header_name, "Transfer-Encoding",strlen("Transfer-Encoding")) == 0 &&
<     										strncasecmp(at, "chunked", length) == 0)
<     {
<         http->chunked = 1;
<     }
< 
<     swoole_efree(header_name);
---
>     efree(header_name);
1553d1168
< 
1556d1170
< #ifdef SW_HAVE_ZLIB
1560c1174
<     if (Z_OK != inflateInit2(&stream, MAX_WBITS + 16))
---
>     if (Z_OK != inflateInit2(&stream, MAX_WBITS+16))
1565a1180,1181
>     int status = 0;
> 
1571c1187,1191
<     int ret = SW_OK;
---
> #if 0
>     printf(SW_START_LINE"\nstatus=%d\tavail_in=%ld,\tavail_out=%ld,\ttotal_in=%ld,\ttotal_out=%ld\n", status, stream.avail_in, stream.avail_out,
>                         stream.total_in, stream.total_out);
> #endif
> 
1577c1197,1203
<         int status = inflate(&stream, Z_SYNC_FLUSH);
---
>         status = inflate(&stream, Z_SYNC_FLUSH);
> 
> #if 0
>         printf("status=%d\tavail_in=%ld,\tavail_out=%ld,\ttotal_in=%ld,\ttotal_out=%ld\n", status, stream.avail_in, stream.avail_out,
>                 stream.total_in, stream.total_out);
> #endif
> 
1581,1582c1207,1208
<             ret = SW_OK;
<             break;
---
>             inflateEnd(&stream);
>             return SW_OK;
1586,1587c1212
<             if (stream.total_out >= swoole_zlib_buffer->size &&
<             		swString_extend(swoole_zlib_buffer, swoole_zlib_buffer->size * 2) < 0)
---
>             if (stream.total_out >= swoole_zlib_buffer->size)
1589,1590c1214
<             	ret = SW_ERR;
<             	break;
---
>                 swString_extend(swoole_zlib_buffer, swoole_zlib_buffer->size * 2);
1595,1596c1219,1220
<         	ret = SW_ERR;
<         	break;
---
>             inflateEnd(&stream);
>             return SW_ERR;
1599,1604c1223
< 
<     inflateEnd(&stream);
<     return ret;
< #else
<     return SW_OK;
< #endif
---
>     return SW_ERR;
1610,1615d1228
<     if (!http)
<     {
<         swWarn("http client is NULL");
<         return SW_ERR;
<     }
< 
1618,1619c1231
<     	swWarn("append string to http body failed");
<         return SW_ERR;
---
>         return -1;
1621,1622c1233
< 
<     return SW_OK;
---
>     return 0;
1625c1236
< static int http_client_parser_on_headers_complete(php_http_parser *parser)
---
> static int http_client_parser_on_message_complete(php_http_parser *parser)
1626a1238,1241
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
1628c1243,1245
<     if (!http)
---
>     zval* zobject = (zval*) http->cli->object;
> 
>     if (http->keep_alive == 1)
1630,1631c1247,1248
<     	swWarn("http client is NULL");
<     	return SW_ERR;
---
>         //reset http phase for reuse
>         http->state = HTTP_CLIENT_STATE_READY;
1634,1640c1251,1253
<     http->state = (http->chunked == 0 && parser->content_length < 0)? HTTP_CLIENT_STATE_WAIT_CLOSE:http->state;
<     return SW_OK;
< }
< 
< static int http_client_parser_on_message_complete(php_http_parser *parser)
< {
<     SWOOLE_FETCH_TSRMLS;
---
>     zval *retval;
>     http_client_property *hcc = swoole_get_property(zobject, 0);
>     zval *zcallback = hcc->onResponse;
1642,1643c1255,1258
<     http_client* http = (http_client*) parser->data;
<     if (!http || !http->cli)
---
>     zval **args[1];
>     args[0] = &zobject;
>     
>     if (http->gzip)
1645,1646c1260,1265
<         swWarn("http_client_parser_on_message_complete http or http->cli is NULL");
<         return SW_ERR;
---
>         if (http_response_uncompress(http->body->str, http->body->length) == SW_ERR)
>         {
>             swWarn("http_response_uncompress failed.");
>             return 0;
>         }
>         zend_update_property_stringl(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("body"), swoole_zlib_buffer->str, swoole_zlib_buffer->length TSRMLS_CC);
1648,1650c1267
< 
<     zval* zobject = (zval*) http->cli->object;
<     if (!zobject)
---
>     else
1652,1653c1269
<         swWarn("http_client_parser_on_message_complete http->cli->object is NULL");
<         return SW_ERR;
---
>         zend_update_property_stringl(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("body"), http->body->str, http->body->length TSRMLS_CC);
1656,1659c1272,1294
<     char* str = http->body->str;
<     int length = http->body->length;
< #ifdef SW_HAVE_ZLIB
<     if (http->gzip && http->body->length > 0)
---
>     zend_update_property_long(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("statusCode"), http->parser.status_code TSRMLS_CC);
> 
>     if (zcallback == NULL || ZVAL_IS_NULL(zcallback))
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_http_client object have not receive callback.");
>     }
>     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_WARNING, "onReactorCallback handler error");
>     }
>     if (EG(exception))
>     {
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
>     }
>     if (retval)
>     {
>         sw_zval_ptr_dtor(&retval);
>     }
>     sw_zval_ptr_dtor(&zcallback);
>     /**
>      * TODO: Sec-WebSocket-Accept check
>      */
>     if (http->upgrade)
1661c1296,1298
<         if (http_response_uncompress(http->body->str, http->body->length) < 0)
---
>         http->state = HTTP_CLIENT_STATE_UPGRADE;
>         http->buffer =  swString_new(SW_HTTP_RESPONSE_INIT_SIZE);
>         if (http->buffer == NULL)
1663c1300
<             swWarn("uncompress http response failed.");
---
>             swoole_php_fatal_error(E_ERROR, "[1] swString_new(%d) failed.", SW_HTTP_RESPONSE_INIT_SIZE);
1666,1668d1302
< 
<         str = swoole_zlib_buffer->str;
<         length = swoole_zlib_buffer->length;
1670,1676c1304,1308
< #endif
< 
<     http->completed = 1;
<     zend_update_property_stringl(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("body"),str,length TSRMLS_CC);
<     zend_update_property_long(swoole_http_client_class_entry_ptr, zobject, ZEND_STRL("statusCode"), http->parser.status_code TSRMLS_CC);
< 
<     return SW_OK;
---
>     else if (http->keep_alive == 0)
>     {
>         http->cli->close(http->cli);
>     }
>     return 0;
1680a1313
>     int ret;
1683,1684c1316,1318
<     zval *finish_cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &uri, &uri_len, &finish_cb))
---
>     zval *finish_cb;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &uri, &uri_len, &finish_cb) == FAILURE)
1688,1689c1322
< 
<     int ret = http_client_execute(getThis(), uri, uri_len, finish_cb TSRMLS_CC);
---
>     ret = http_client_execute(getThis(), uri, uri_len, finish_cb TSRMLS_CC);
1695,1701c1328
< 	http_client_property *hcc = swoole_get_property(getThis(),swoole_property_common);
< 	if (!hcc)
< 	{
< 		swWarn("http client property is NULL ");
< 		RETURN_FALSE;
< 	}
< 
---
>     int ret;
1704,1705c1331,1333
<     zval *finish_cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &uri, &uri_len, &finish_cb))
---
>     zval *finish_cb;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &uri, &uri_len, &finish_cb) == FAILURE)
1709c1337
< 
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
1711c1339
<     int ret = http_client_execute(getThis(), uri, uri_len, finish_cb TSRMLS_CC);
---
>     ret = http_client_execute(getThis(), uri, uri_len, finish_cb TSRMLS_CC);
1717,1723c1345
< 	http_client_property *hcc = swoole_get_property(getThis(),swoole_property_common);
< 	if (!hcc)
< 	{
< 		swWarn("http_client_property is NULL ");
< 		RETURN_FALSE;
< 	}
< 
---
>     int ret;
1726,1728c1348,1351
<     zval *callback = NULL;
<     zval *post_data = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "szz", &uri, &uri_len, &post_data, &callback))
---
>     zval *callback;
>     zval *post_data;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "szz", &uri, &uri_len, &post_data, &callback) == FAILURE)
1733,1734c1356
<     /// post_data 参数可以为空或者null. post_data存在时，必须为string类型或者array 类型
<     if (post_data && !ZVAL_IS_NULL(post_data) && Z_TYPE_P(post_data) != IS_ARRAY && Z_TYPE_P(post_data) != IS_STRING)
---
>     if (Z_TYPE_P(post_data) != IS_ARRAY && Z_TYPE_P(post_data) != IS_STRING)
1736c1358
<         swWarn("post data must be string or array.");
---
>         swoole_php_fatal_error(E_WARNING, "post data must be string or array.");
1739a1362
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
1742,1745c1365,1366
<     sw_copy_to_stack(hcc->request_body,hcc->_request_body);  //just for PHP7
< 
<     hcc->request_method = "POST";  
<     int ret = http_client_execute(getThis(), uri, uri_len, callback TSRMLS_CC);
---
>     hcc->request_method = "POST";
>     ret = http_client_execute(getThis(), uri, uri_len, callback TSRMLS_CC);
1748,1749c1369
<     
< //websocket method
---
> 
1752,1758c1372
< 	http_client_property *hcc = swoole_get_property(getThis(), swoole_property_common);
< 	if (!hcc)
< 	{
< 		swWarn("http_client_property is NULL ");
< 		RETURN_FALSE;
< 	}
< 
---
>     int ret;
1761,1762c1375,1377
<     zval *finish_cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &uri, &uri_len, &finish_cb))
---
>     zval *finish_cb;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &uri, &uri_len, &finish_cb) == FAILURE)
1767c1382,1384
<     char buf[SW_WEBSOCKET_KEY_LENGTH + 1] = {0};
---
>     http_client_property *hcc = swoole_get_property(getThis(), 0);
> 
>     char buf[SW_WEBSOCKET_KEY_LENGTH + 1];
1785c1402
<     int ret = http_client_execute(getThis(), uri, uri_len, finish_cb TSRMLS_CC);
---
>     ret = http_client_execute(getThis(), uri, uri_len, finish_cb TSRMLS_CC);
1789d1405
< //just for websocket
1792,1793c1408,1410
<     char *data = NULL;
<     zend_size_t length = 0;
---
>     char *data;
>     zend_size_t length;
>     long fd = 0;
1796c1413,1414
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|lb", &data, &length, &opcode, &fin))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|lb", &data, &length, &opcode, &fin) == FAILURE)
1803c1421
<         swWarn("opcode max 10");
---
>         swoole_php_fatal_error(E_WARNING, "opcode max 10");
1807c1425
<     if (length <= 0 || !data)
---
>     if (length == 0)
1809c1427
<         swWarn("data is empty.");
---
>         swoole_php_fatal_error(E_WARNING, "data is empty.");
1814c1432,1438
<     if (!http || !http->cli || !!http->cli->socket)
---
>     if (!http->cli)
>     {
>         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_http_client.");
>         RETURN_FALSE;
>     }
> 
>     if (!http->cli->socket)
1816c1440
<         swWarn("http client or client object or socket is NULL");
---
>         swoole_php_error(E_WARNING, "not connected to the server");
1822c1446
<         swWarn("connection[%d] is not a websocket client.", (int ) http->cli->socket->fd);
---
>         swoole_php_fatal_error(E_WARNING, "connection[%d] is not a websocket client.", (int ) fd);
1829a1454,1455
> 
> #endif
diff -r ./zan-extension/swoole_http_server.c ../swoole-1.8.5-stable/swoole_http_server.c
31,35c31,34
< #include "swError.h"
< #include "swConnection.h"
< #include "swBaseOperator.h"
< #include "swProtocol/websocket.h"
< #include "swProtocol/base64.h"
---
> 
> #include "websocket.h"
> #include "Connection.h"
> #include "base64.h"
46c45,47
< static swArray *http_client_array = NULL;
---
> static swArray *http_client_array;
> static uint8_t http_merge_global_flag = 0;
> static uint8_t http_merge_request_flag = 0;
48,51c49,50
< swString *swoole_http_buffer = NULL;
< #ifdef SW_HAVE_ZLIB
< swString *swoole_zlib_buffer = NULL;
< #endif
---
> swString *swoole_http_buffer;
> swString *swoole_zlib_buffer;
75c74
< static zend_class_entry swoole_http_server_ce;
---
> zend_class_entry swoole_http_server_ce;
78c77
< static zend_class_entry swoole_http_response_ce;
---
> zend_class_entry swoole_http_response_ce;
81c80
< static zend_class_entry swoole_http_request_ce;
---
> zend_class_entry swoole_http_request_ce;
83a83,88
> zval* php_sw_http_server_callbacks[HTTP_SERVER_CALLBACK_NUM];
> 
> #if PHP_MAJOR_VERSION >= 7
> zval _php_sw_http_server_callbacks[HTTP_SERVER_CALLBACK_NUM];
> #endif
> 
95d99
< //multipart/form-data request parser callback head/body
103c107,109
< static void swoole_http_context_free(http_context *ctx TSRMLS_DC);
---
> static void http_global_merge(zval *val, zval *zrequest_object, int type);
> static void http_global_clear(TSRMLS_D);
> static void http_global_init(TSRMLS_D);
104a111
> 
109,112d115
< #define http_strncasecmp(const_str, at, length) ((length >= sizeof(const_str)-1) &&\
<        (strncasecmp(at, ZEND_STRL(const_str)) == 0))
< 
< //header filed format,like:Content-Type
120c123
<             if (key[i] >= 'a' && key[i] <= 'z')
---
>             if (key[i] >= 97 && key[i] <= 122)
122c125
<                 key[i] -= 'a' - 'A';
---
>                 key[i] -= 32;
132c135
<             if (key[i] >= 'A' && key[i] <= 'Z')
---
>             if (key[i] >= 65 && key[i] <= 90)
134c137
<                 key[i] += 'a' - 'A';
---
>                 key[i] += 32;
142,143d144
< voidpf php_zlib_alloc(voidpf opaque, uInt items, uInt size);
< void php_zlib_free(voidpf opaque, voidpf address);
145a147,148
> #define http_merge_php_global(v,r,t)  if (http_merge_global_flag > 0) http_global_merge(v,r,t)
> 
148c151
< 
---
> static PHP_METHOD(swoole_http_server, setglobal);
150d152
< static PHP_METHOD(swoole_http_request, __destruct);
158d159
< #ifdef SW_HAVE_ZLIB
160d160
< #endif
162,264d161
< static PHP_METHOD(swoole_http_response, __destruct);
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_server_on, 0, 0, 2)
<     ZEND_ARG_INFO(0, event_name)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_status, 0, 0, 1)
<     ZEND_ARG_INFO(0, http_code)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_cookie, 0, 0, 1)
<     ZEND_ARG_INFO(0, name)
<     ZEND_ARG_INFO(0, value)
<     ZEND_ARG_INFO(0, expires)
<     ZEND_ARG_INFO(0, path)
<     ZEND_ARG_INFO(0, domain)
<     ZEND_ARG_INFO(0, secure)
<     ZEND_ARG_INFO(0, httponly)
< ZEND_END_ARG_INFO()
< #ifdef SW_HAVE_ZLIB
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_gzip, 0, 0, 0)
<     ZEND_ARG_INFO(0, compress_level)
< ZEND_END_ARG_INFO()
< #endif
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_header, 0, 0, 2)
<     ZEND_ARG_INFO(0, key)
<     ZEND_ARG_INFO(0, value)
<     ZEND_ARG_INFO(0, ucwords)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_write, 0, 0, 1)
<     ZEND_ARG_INFO(0, content)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_end, 0, 0, 0)
<     ZEND_ARG_INFO(0, content)
< ZEND_END_ARG_INFO()
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_response_sendfile, 0, 0, 1)
<     ZEND_ARG_INFO(0, filename)
< 
< ZEND_END_ARG_INFO()
< 
< const zend_function_entry swoole_http_server_methods[] =
< {
<     PHP_ME(swoole_http_server, on,         arginfo_swoole_http_server_on, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_server, start,      arginfo_swoole_http_void, ZEND_ACC_PUBLIC)
<     PHP_FE_END
< };
< 
< const zend_function_entry swoole_http_request_methods[] =
< {
<     PHP_ME(swoole_http_request, rawcontent, arginfo_swoole_http_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_request, __destruct, arginfo_swoole_http_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_FE_END
< };
< 
< const zend_function_entry swoole_http_response_methods[] =
< {
<     PHP_ME(swoole_http_response, cookie, arginfo_swoole_http_response_cookie, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_response, rawcookie, arginfo_swoole_http_response_cookie, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_response, status, arginfo_swoole_http_response_status, ZEND_ACC_PUBLIC)
< #ifdef SW_HAVE_ZLIB
<     PHP_ME(swoole_http_response, gzip, arginfo_swoole_http_response_gzip, ZEND_ACC_PUBLIC)
< #endif
<     PHP_ME(swoole_http_response, header, arginfo_swoole_http_response_header, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_response, write, arginfo_swoole_http_response_write, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_response, end, arginfo_swoole_http_response_end, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_response, sendfile, arginfo_swoole_http_response_sendfile, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_http_response, __destruct, arginfo_swoole_http_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_FE_END
< };
< 
< void swoole_http_server_init(int module_number TSRMLS_DC)
< {
<     SWOOLE_INIT_CLASS_ENTRY(swoole_http_server_ce, "swoole_http_server", "Swoole\\Http\\Server", swoole_http_server_methods);
<     swoole_http_server_class_entry_ptr = sw_zend_register_internal_class_ex(&swoole_http_server_ce, swoole_server_class_entry_ptr, "swoole_server" TSRMLS_CC);
<     zend_declare_property_long(swoole_http_server_class_entry_ptr, ZEND_STRL("global"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
<     zend_declare_property_null(swoole_http_server_class_entry_ptr, SW_STRL("onRequest")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_server_class_entry_ptr, SW_STRL("onHandshake")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_server_class_entry_ptr, SW_STRL("setting")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     SWOOLE_INIT_CLASS_ENTRY(swoole_http_response_ce, "swoole_http_response", "Swoole\\Http\\Response", swoole_http_response_methods);
<     swoole_http_response_class_entry_ptr = zend_register_internal_class(&swoole_http_response_ce TSRMLS_CC);
<     zend_declare_property_long(swoole_http_response_class_entry_ptr, SW_STRL("fd")-1, 0,  ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_response_class_entry_ptr, SW_STRL("cookie")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_response_class_entry_ptr, SW_STRL("header")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     SWOOLE_INIT_CLASS_ENTRY(swoole_http_request_ce, "swoole_http_request", "Swoole\\Http\\Request", swoole_http_request_methods);
<     swoole_http_request_class_entry_ptr = zend_register_internal_class(&swoole_http_request_ce TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("request")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("get")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("cookie")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("files")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("post")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_http_request_class_entry_ptr, SW_STRL("fd")-1, 0,  ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("header")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_http_request_class_entry_ptr, SW_STRL("server")-1, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
< }
326a224,227
> ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_http_server_on, 0, 0, 2)
>     ZEND_ARG_INFO(0, ha_name)
>     ZEND_ARG_INFO(0, cb)
> ZEND_END_ARG_INFO()
342c243
< static const multipart_parser_settings mt_parser_settings =
---
> static const multipart_parser_settings mt_parser_settings = 
352a254,280
> const zend_function_entry swoole_http_server_methods[] =
> {
>     PHP_ME(swoole_http_server, on,         arginfo_swoole_http_server_on, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_server, setglobal,  NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_server, start,      NULL, ZEND_ACC_PUBLIC)
>     PHP_FE_END
> };
> 
> const zend_function_entry swoole_http_request_methods[] =
> {
>     PHP_ME(swoole_http_request, rawcontent,         NULL, ZEND_ACC_PUBLIC)
>     PHP_FE_END
> };
> 
> const zend_function_entry swoole_http_response_methods[] =
> {
>     PHP_ME(swoole_http_response, cookie, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, rawcookie, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, status, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, gzip, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, header, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, write, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, end, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_http_response, sendfile, NULL, ZEND_ACC_PUBLIC)
>     PHP_FE_END
> };
> 
361c289
< static int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length)
---
> static void http_global_clear(TSRMLS_D)
363c291,297
< 	SWOOLE_FETCH_TSRMLS;
---
>     sw_zend_hash_del(&EG(symbol_table), "_GET", sizeof("_GET"));
>     sw_zend_hash_del(&EG(symbol_table), "_POST", sizeof("_POST"));
>     sw_zend_hash_del(&EG(symbol_table), "_COOKIE", sizeof("_COOKIE"));
>     sw_zend_hash_del(&EG(symbol_table), "_REQUEST", sizeof("_REQUEST"));
>     sw_zend_hash_del(&EG(symbol_table), "_SERVER", sizeof("_SERVER"));
>     sw_zend_hash_del(&EG(symbol_table), "_FILES", sizeof("_FILES"));
> }
364a299,455
> static void http_global_init(TSRMLS_D)
> {
>     zval *val = NULL, *array = NULL;
>     if (sw_zend_hash_find(&EG(symbol_table), "_GET", sizeof("_GET"), (void **) &val) == FAILURE)
>     {
>         SW_ALLOC_INIT_ZVAL(array);
>         array_init(array);
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_GET", array);
>     }
>     if (sw_zend_hash_find(&EG(symbol_table), "_POST", sizeof("_POST"), (void **) &val) == FAILURE)
>     {
>         SW_ALLOC_INIT_ZVAL(array);
>         array_init(array);
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_POST", array);
>     }
>     if (sw_zend_hash_find(&EG(symbol_table), "_COOKIE", sizeof("_COOKIE"), (void **) &val) == FAILURE)
>     {
>         SW_ALLOC_INIT_ZVAL(array);
>         array_init(array);
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_COOKIE", array);
>     }
>     if (sw_zend_hash_find(&EG(symbol_table), "_REQUEST", sizeof("_REQUEST"), (void **) &val) == FAILURE)
>     {
>         SW_ALLOC_INIT_ZVAL(array);
>         array_init(array);
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_REQUEST", array);
>     }
>     if (sw_zend_hash_find(&EG(symbol_table), "_SERVER", sizeof("_SERVER"), (void **) &val) == FAILURE)
>     {
>         SW_ALLOC_INIT_ZVAL(array);
>         array_init(array);
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_SERVER", array);
>     }
>     if (sw_zend_hash_find(&EG(symbol_table), "_FILES", sizeof("_FILES"), (void **) &val) == FAILURE)
>     {
>         SW_ALLOC_INIT_ZVAL(array);
>         array_init(array);
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_FILES", array);
>     }
> }
> 
> static void http_global_merge(zval *val, zval *zrequest_object, int type)
> {
>     zval *zrequest;
> 
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     if (type == HTTP_GLOBAL_SERVER)
>     {
>         zval *php_global_server;
>         SW_MAKE_STD_ZVAL(php_global_server);
>         array_init(php_global_server);
> 
>         char *key;
>         char _php_key[128];
>         int keytype;
>         uint32_t keylen;
>         zval *value;
> 
>         SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(val), key, keylen, keytype, value)
>             if (HASH_KEY_IS_STRING != keytype)
>             {
>                 continue;
>             }
>             strncpy(_php_key, key, sizeof(_php_key));
>             php_strtoupper(_php_key, keylen);
>             convert_to_string(value);
>             sw_add_assoc_stringl_ex(php_global_server, _php_key, keylen + 1, Z_STRVAL_P(value), Z_STRLEN_P(value), 1);
>         SW_HASHTABLE_FOREACH_END();
> 
>         zval *header = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL("header"), 1 TSRMLS_CC);
>         if (header || !ZVAL_IS_NULL(header))
>         {
>             SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(header), key, keylen, keytype, value)
>                 if (HASH_KEY_IS_STRING != keytype)
>                 {
>                     continue;
>                 }
>                 int i;
>                 //replace '-' to '_'
>                 for (i = 0; i < keylen; i++)
>                 {
>                     if (key[i] == '-')
>                     {
>                         key[i] = '_';
>                     }
>                 }
>                 keylen = snprintf(_php_key, sizeof(_php_key), "HTTP_%s", key);
>                 php_strtoupper(_php_key, keylen);
>                 convert_to_string(value);
>                 sw_add_assoc_stringl_ex(php_global_server, _php_key, keylen + 1, Z_STRVAL_P(value), Z_STRLEN_P(value), 1);
>              SW_HASHTABLE_FOREACH_END();
>         }
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_SERVER", php_global_server);
>         return;
>     }
> 
>     switch (type)
>     {
>     case HTTP_GLOBAL_GET:
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_GET", val);
>         break;
> 
>     case HTTP_GLOBAL_POST:
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_POST", val);
>         break;
> 
>     case HTTP_GLOBAL_COOKIE:
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_COOKIE", val);
>         break;
> 
>     case HTTP_GLOBAL_REQUEST:
>         if (!http_merge_request_flag)
>         {
>             return;
>         }
>         zrequest = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL("request"), 1 TSRMLS_CC);
>         if (zrequest && !(ZVAL_IS_NULL(zrequest)))
>         {
>             ZEND_SET_SYMBOL(&EG(symbol_table), "_REQUEST", zrequest);
>         }
>         return;
> 
>     case HTTP_GLOBAL_FILES:
>         ZEND_SET_SYMBOL(&EG(symbol_table), "_FILES", val);
>         return;
> 
>     default:
>         swWarn("unknow global type [%d]", type);
>         return;
>     }
> 
>     if (http_merge_request_flag & type)
>     {
>         zrequest = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL("request"), 1 TSRMLS_CC);
>         if (!zrequest || ZVAL_IS_NULL(zrequest))
>         {
>             http_context *ctx = http_get_context(zrequest_object, 0 TSRMLS_CC);
>             if (!ctx)
>             {
>                 return;
>             }
>             http_alloc_zval(ctx, request, zrequest);
>             array_init(zrequest);
>             zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("request"), zrequest TSRMLS_CC);
>         }
>         sw_php_array_merge(Z_ARRVAL_P(zrequest), Z_ARRVAL_P(val));
>     }
> }
> 
> static int http_request_on_query_string(php_http_parser *parser, const char *at, size_t length)
> {
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
371d461
<     zval *zrequest_object = ctx->request.zobject;
373c463,465
<     swoole_http_server_array_init(get, request,ctx);
---
>     http_alloc_zval(ctx, request, zget);
>     array_init(zget);
>     zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("get"), zget TSRMLS_CC);
377a470,472
>     //merge php global variable
>     http_merge_php_global(zget, ctx->request.zrequest_object, HTTP_GLOBAL_GET);
> 
384c479
<     if (!ctx)
---
>     if (ctx->current_header_name_allocated)
386c481,482
<     	return SW_ERR;
---
>         efree(ctx->current_header_name);
>         ctx->current_header_name_allocated = 0;
388,394d483
< 
<     if (ctx->current_header_name_allocated)
< 	{
< 		swoole_efree(ctx->current_header_name);
< 		ctx->current_header_name_allocated = 0;
< 	}
< 
397c486
<     return SW_OK;
---
>     return 0;
405c494
<         swWarn("multipart_parser_init() failed.");
---
>         swoole_php_fatal_error(E_WARNING, "multipart_parser_init() failed.");
417,418c506,507
<     char keybuf[SW_HTTP_COOKIE_KEYLEN] = {0};
<     char valbuf[SW_HTTP_COOKIE_VALLEN] = {0};
---
>     char keybuf[SW_HTTP_COOKIE_KEYLEN];
>     char valbuf[SW_HTTP_COOKIE_VALLEN];
423c512
<     int state = -1;
---
>     int state = 0;
428c517
<         if (state <= 0 && *_c == '=')
---
>         if (state == 0 && *_c == '=')
447,464c536,538
<             if (klen > 1)
<             {
<                 sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);
<             }
<             j = i + 1;
<             state = -1;
<         }
<         else if (state < 0)
<         {
<             if (isspace(*_c))
<             {
<                 //Remove leading spaces from cookie names
<                 ++j;
<             }
<             else
<             {
<                 state = 0;
<             }
---
>             sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);
>             j = i + 2;
>             state = 0;
475,478c549
<         if (klen > 1)
<         {
<             sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);
<         }
---
>         sw_add_assoc_stringl_ex(array, keybuf, klen, valbuf, vlen, 1);
503c574,576
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
506,508c579
<     zval *zrequest_object = ctx->request.zobject;
<     size_t header_len = ctx->current_header_name_len;
<     char *header_name = zend_str_tolower_dup(ctx->current_header_name, header_len);
---
>     char *header_name = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);
510c581
<     if (strncmp(header_name, "cookie", header_len) == 0)
---
>     if (strncasecmp(header_name, "cookie", ctx->current_header_name_len) == 0)
512d582
<         zval *zcookie;
519c589,593
<             swoole_http_server_array_init(cookie, request,ctx);
---
>             zval *zcookie;
>             http_alloc_zval(ctx, request, zcookie);
>             array_init(zcookie);
>             zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("cookie"), zcookie TSRMLS_CC);
> 
520a595
>             http_merge_php_global(zcookie, ctx->request.zrequest_object, HTTP_GLOBAL_COOKIE);
524c599
<     else if (SwooleG.serv->listen_list->open_websocket_protocol && strncmp(header_name, "upgrade", header_len) == 0 && strncasecmp(at, "websocket", length) == 0)
---
>     else if (strncasecmp(header_name, ZEND_STRL("upgrade")) == 0 && strncasecmp(at, ZEND_STRL("websocket")) == 0)
536c611
<         if (strncasecmp(header_name, "content-type", header_len) == 0)
---
>         if (memcmp(header_name, ZEND_STRL("content-type")) == 0)
538c613
<             if (http_strncasecmp("application/x-www-form-urlencoded",at,length))
---
>             if (strncasecmp(at, ZEND_STRL("application/x-www-form-urlencoded")) == 0)
542c617
<             else if (http_strncasecmp("multipart/form-data",at, length))
---
>             else if (memcmp(header_name, ZEND_STRL("content-type")) == 0 && strncasecmp(at, ZEND_STRL("multipart/form-data")) == 0)
545,549d619
<                 if (boundary_len <= 0)
<                 {
<                     swWarn("[%d] invalid multipart/form-data body.", ctx->fd);
<                     goto free_memory;
<                 }
558,559c628,629
< free_memory:
< 	if (ctx->current_header_name_allocated)
---
>     free_memory:
>     if (ctx->current_header_name_allocated)
561c631
< 		swoole_efree(ctx->current_header_name);
---
>         efree(ctx->current_header_name);
564,565c634
< 
<     swoole_efree(header_name);
---
>     efree(header_name);
574,577c643,647
< 	{
< 		swoole_efree(ctx->current_header_name);
< 		ctx->current_header_name_allocated = 0;
< 	}
---
>     {
>         efree(ctx->current_header_name);
>         ctx->current_header_name_allocated = 0;
>     }
>     ctx->current_header_name = NULL;
590c660,662
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
593d664
<     zval *zrequest_object = ctx->request.zobject;
597c668,670
<         swoole_http_server_array_init(files, request,ctx);
---
>         http_alloc_zval(ctx, request, zfiles);
>         array_init(zfiles);
>         zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("files"), zfiles TSRMLS_CC);
600,601c673
<     size_t header_len = ctx->current_header_name_len;
<     char *headername = zend_str_tolower_dup(ctx->current_header_name, header_len);
---
>     char *headername = zend_str_tolower_dup(ctx->current_header_name, ctx->current_header_name_len);
637c709
<             zval *multipart_header = NULL;
---
>             zval *multipart_header;
639a712
>             add_assoc_zval(zfiles, ctx->current_input_name, multipart_header);
649d721
<             add_assoc_zval(zfiles, ctx->current_input_name, multipart_header);
651d722
< 
664c735
<         swoole_efree(ctx->current_header_name);
---
>         efree(ctx->current_header_name);
667,668c738
< 
<     swoole_efree(headername);
---
>     efree(headername);
689c759,760
<         zval *files = ctx->request.zfiles;
---
>         swoole_http_client *client = (swoole_http_client*) p->data;
>         zval *files = client->context.request.zfiles;
703,704c774
< #if 0
< static void get_random_file_name(char *des, const char *src)
---
> void get_random_file_name(char *des, const char *src)
708c778
<     int n = sprintf(buf, "%s%d", src, swoole_system_random(0, 9999));
---
>     sprintf(buf, "%s%d", src, swoole_system_random(0,9999));
712c782
<     PHP_MD5Update(&ctx, buf, n);
---
>     PHP_MD5Update(&ctx, buf, strlen(buf));
716d785
< #endif
741,743c810,812
< 	char file_path[sizeof(SW_HTTP_UPLOAD_TMP_FILE)];
< 	memcpy(file_path, SW_HTTP_UPLOAD_TMP_FILE, sizeof(SW_HTTP_UPLOAD_TMP_FILE));
< 	int tmpfile = swoole_tmpfile(file_path);
---
>     char file_path[sizeof(SW_HTTP_UPLOAD_TMP_FILE)];
>     memcpy(file_path, SW_HTTP_UPLOAD_TMP_FILE, sizeof(SW_HTTP_UPLOAD_TMP_FILE));
>     int tmpfile = swoole_tmpfile(file_path);
746c815
<     if (fp == NULL)
---
>     if (fp < 0)
761c830,832
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
764d834
<     zval *zrequest_object = ctx->request.zobject;
767,768c837,838
<         zval *zpost = sw_zend_read_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL("post"), 1 TSRMLS_CC);
<         if (!zpost || ZVAL_IS_NULL(zpost))
---
>         zval *zpost = sw_zend_read_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("post"), 1 TSRMLS_CC);
>         if (ZVAL_IS_NULL(zpost))
770c840,842
<             swoole_http_server_array_init(post, request,ctx);
---
>             http_alloc_zval(ctx, request, zpost);
>             array_init(zpost);
>             zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("post"), zpost TSRMLS_CC);
773,774c845,846
<         char *name = ctx->current_form_data_name;
<         int len = ctx->current_form_data_name_len;
---
> 		char *name = ctx->current_form_data_name;
> 		int len = ctx->current_form_data_name_len;
776,784c848,856
<         if ((name[len-1] == ']') && (name[len-2] == '['))
<         {
<             zval *array_value;
<             if (sw_zend_hash_find(Z_ARRVAL_P(zpost), name, len + 1, (void **) &array_value) == FAILURE)
<             {
<                 SW_MAKE_STD_ZVAL(array_value);
<                 array_init(array_value);
<                 add_assoc_zval(zpost, name, array_value);
<             }
---
> 		if ((name[len-1] == ']') && (name[len-2] == '['))
> 		{
> 			zval *array_value;
> 			if (sw_zend_hash_find(Z_ARRVAL_P(zpost), name, len + 1, (void **) &array_value) == FAILURE)
> 			{
> 				SW_MAKE_STD_ZVAL(array_value);
> 				array_init(array_value);
> 				add_assoc_zval(zpost, name, array_value);
> 			}
786,788c858,860
<         }
<         else
<         {
---
> 		}
> 		else
> 		{
791c863
<         }
---
> 		}
793c865,866
<         swoole_efree(ctx->current_form_data_name);
---
>         efree(ctx->current_form_data_name);
>         ctx->current_form_data_name = NULL;
805c878
<     if (!files || ZVAL_IS_NULL(files))
---
>     if (ZVAL_IS_NULL(files))
822c895
<     swoole_efree(ctx->current_input_name);
---
>     efree(ctx->current_input_name);
829c902,904
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
835c910,912
<     SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(files), value)
---
>     http_merge_php_global(files, ctx->request.zrequest_object, HTTP_GLOBAL_FILES);
> 
>     SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(ctx->request.zfiles), value)
856c933,935
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
859d937
<     zval *zrequest_object = ctx->request.zobject;
862a941
> 
866c945,947
<         swoole_http_server_array_init(post, request,ctx);
---
>         http_alloc_zval(ctx, request, zpost);
>         array_init(zpost);
> 
867a949
>         zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("post"), zpost TSRMLS_CC);
869a952
>         http_merge_php_global(zpost, ctx->request.zrequest_object, HTTP_GLOBAL_POST);
877c960
<             swWarn("parse multipart body failed. at: %s,length: %d,n: %d",at,length,n);
---
>             swoole_php_fatal_error(E_WARNING, "parse multipart body failed.");
914c997
< static int http_onReceive(swServer *serv, swEventData *req)
---
> static void http_onClose(swServer *serv, swDataHead *info)
916c999,1000
<     if (swEventData_is_dgram(req->info.type))
---
>     swConnection *conn = swWorker_get_connection(SwooleG.serv, info->fd);
>     if (!conn)
918c1002,1021
<         return php_swoole_onReceive(serv, req);
---
>         swWarn("connection[%d] is closed.", info->fd);
>         return;
>     }
>     //other server port
>     if (serv->listen_list->sock != info->from_fd)
>     {
>         return php_swoole_onClose(serv, info);
>     }
> 
>     swoole_http_client *client = swArray_fetch(http_client_array, conn->fd);
>     if (client)
>     {
>         http_context *ctx = &client->context;
>         if (ctx->request.zrequest_object && !ctx->end)
>         {
> #if PHP_MAJOR_VERSION < 7
>             TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
>             swoole_http_context_free(ctx TSRMLS_CC);
>         }
920a1024,1035
>     if (php_sw_server_callbacks[SW_SERVER_CB_onClose] != NULL)
>     {
>         php_swoole_onClose(serv, info);
>     }
> }
> 
> #ifdef SW_USE_HTTP2
> 
> #endif
> 
> static int http_onReceive(swServer *serv, swEventData *req)
> {
921a1037
> 
928d1043
< 
941d1055
<    //http_client_array created at swoole_http_server_start
947d1060
< 
958c1071,1073
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
959a1075
>     php_http_parser *parser = &client->context.parser;
961,963d1076
<     php_http_parser *parser = &ctx->parser;
<     parser->data = ctx;
< 
966c1079,1080
<     //request parser init here
---
>     parser->data = ctx;
> 
969,973c1083,1085
<     zval *zdata = NULL;
<     SW_MAKE_STD_ZVAL(zdata);
<     php_swoole_get_recv_data(zdata, req, NULL, 0);
<     ctx->request.zdata = zdata;
<     sw_copy_to_stack(ctx->request.zdata,ctx->request._zdata);
---
>     zval *zdata;
>     http_alloc_zval(ctx, request, zdata);
>     zdata = php_swoole_get_recv_data(zdata, req TSRMLS_CC);
975c1087
<     swTrace("httpRequest %d bytes:\n---------------------------------------\n%s\n", (int)Z_STRLEN_P(zdata), Z_STRVAL_P(zdata));
---
>     swTrace("httpRequest %d bytes:\n---------------------------------------\n%s\n", Z_STRLEN_P(zdata), Z_STRVAL_P(zdata));
977,978d1088
< 	zval *zrequest_object = ctx->request.zobject;
< 	zval *zresponse_object = ctx->response.zobject;
982,985c1092
< 		sw_zval_ptr_dtor(&zdata);
< 		sw_zval_ptr_dtor(&zrequest_object);
< 		sw_zval_ptr_dtor(&zresponse_object);
<         bzero(client, sizeof(swoole_http_client));
---
>         sw_zval_ptr_dtor(&zdata);
986a1094
> 
994c1102
<         zval *retval = NULL;
---
>         zval *retval;
996a1105,1112
>         zval *zrequest_object = ctx->request.zrequest_object;
>         zval *zresponse_object = ctx->response.zresponse_object;
> 
>         if (http_merge_global_flag > 0)
>         {
>             http_global_init(TSRMLS_C);
>         }
> 
1000d1115
<        //--------------start build zserver string struct
1012a1128
>             sw_zval_ptr_dtor(&zdata);
1014,1018c1130
< 			sw_zval_ptr_dtor(&zdata);
< 			sw_zval_ptr_dtor(&zrequest_object);
< 			sw_zval_ptr_dtor(&zresponse_object);
< 			bzero(client, sizeof(swoole_http_client));
< 			return SW_ERR;
---
>             return SW_ERR;
1023,1025c1135,1144
<         char addr[SW_IP_MAX_LENGTH] = {0}; //just means ip cache len
< 		swConnection_get_ip(conn,addr,SW_IP_MAX_LENGTH);
< 		sw_add_assoc_string(zserver, "remote_addr", addr, 1);
---
>         sw_add_assoc_string(zserver, "remote_addr", swConnection_get_ip(conn), 1);
> 
>         if (ctx->request.version == 101)
>         {
>             sw_add_assoc_string(zserver, "server_protocol", "HTTP/1.1", 1);
>         }
>         else
>         {
>             sw_add_assoc_string(zserver, "server_protocol", "HTTP/1.0", 1);
>         }
1027d1145
< 		sw_add_assoc_string(zserver, "server_protocol", ctx->request.version == 101? "HTTP/1.1":"HTTP/1.0", 1);
1030c1148,1150
<         zval *zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onHandShake);
---
>         http_merge_php_global(zserver, zrequest_object, HTTP_GLOBAL_SERVER);
>         http_merge_php_global(NULL, zrequest_object, HTTP_GLOBAL_REQUEST);
> 
1032c1152
<         if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION && zcallback == NULL)
---
>         if (conn->websocket_status == WEBSOCKET_STATUS_CONNECTION && php_sw_http_server_callbacks[HTTP_CALLBACK_onHandShake] == NULL)
1034,1038c1154
<         	int iRet = swoole_websocket_onHandshake(port, ctx);
< 			sw_zval_ptr_dtor(&zdata);
< 			sw_zval_ptr_dtor(&zrequest_object);
< 			sw_zval_ptr_dtor(&zresponse_object);
< 			return iRet;
---
>             return swoole_websocket_onHandshake(client);
1040a1157,1166
> #if PHP_MEMORY_DEBUG
>         php_vmstat.new_http_response++;
> #endif
> 
> #ifdef __CYGWIN__
>         //TODO: memory error on cygwin.
>         zval_add_ref(&zrequest_object);
>         zval_add_ref(&zresponse_object);
> #endif
>         
1043a1170,1171
>         int callback = 0;
> 
1045a1174
>             callback = HTTP_CALLBACK_onHandShake;
1047d1175
<             zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onHandShake);
1051c1179
<             zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onRequest);
---
>             callback = HTTP_CALLBACK_onRequest;
1053c1181
<             if (zcallback == NULL)
---
>             if (php_sw_http_server_callbacks[callback] == NULL)
1055,1059c1183
<                 swoole_websocket_onRequest(ctx);
<                 sw_zval_ptr_dtor(&zdata);
< 				sw_zval_ptr_dtor(&zrequest_object);
< 				sw_zval_ptr_dtor(&zresponse_object);
<                 bzero(client, sizeof(swoole_http_client));
---
>                 swoole_websocket_onReuqest(client);
1064c1188
<         if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>         if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_http_server_callbacks[callback], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
1068d1191
< 
1073d1195
< 
1083d1204
< 
1088,1092d1208
< 
<         sw_zval_ptr_dtor(&zdata);
< 		sw_zval_ptr_dtor(&zrequest_object);
< 		sw_zval_ptr_dtor(&zresponse_object);
< 		bzero(client, sizeof(swoole_http_client));
1094d1209
< 
1098c1213
< static void http_onClose(swServer *serv, swDataHead *ev)
---
> void swoole_http_server_init(int module_number TSRMLS_DC)
1100,1105c1215,1216
<     int fd = ev->fd;
<     swConnection *conn = swWorker_get_connection(SwooleG.serv, fd);
<     if (!conn)
<     {
<         return;
<     }
---
>     SWOOLE_INIT_CLASS_ENTRY(swoole_http_server_ce, "swoole_http_server", "Swoole\\Http\\Server", swoole_http_server_methods);
>     swoole_http_server_class_entry_ptr = sw_zend_register_internal_class_ex(&swoole_http_server_ce, swoole_server_class_entry_ptr, "swoole_server" TSRMLS_CC);
1107,1111c1218
<     swoole_http_client *client = swArray_fetch(http_client_array, conn->fd);
<     if (!client)
<     {
<         return;
<     }
---
>     zend_declare_property_long(swoole_http_server_class_entry_ptr, ZEND_STRL("global"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
1113,1118c1220,1221
< #ifdef SW_USE_HTTP2
<     if (client->http2)
<     {
<         swoole_http2_free(client);
<     }
< #endif
---
>     SWOOLE_INIT_CLASS_ENTRY(swoole_http_response_ce, "swoole_http_response", "Swoole\\Http\\Response", swoole_http_response_methods);
>     swoole_http_response_class_entry_ptr = zend_register_internal_class(&swoole_http_response_ce TSRMLS_CC);
1120c1223,1224
<     php_swoole_onClose(serv, ev);
---
>     SWOOLE_INIT_CLASS_ENTRY(swoole_http_request_ce, "swoole_http_request", "Swoole\\Http\\Request", swoole_http_request_methods);
>     swoole_http_request_class_entry_ptr = zend_register_internal_class(&swoole_http_request_ce TSRMLS_CC);
1122c1226,1229
< 	bzero(client, sizeof(swoole_http_client));
---
>     REGISTER_LONG_CONSTANT("HTTP_GLOBAL_GET", HTTP_GLOBAL_GET, CONST_CS | CONST_PERSISTENT);
>     REGISTER_LONG_CONSTANT("HTTP_GLOBAL_POST", HTTP_GLOBAL_POST, CONST_CS | CONST_PERSISTENT);
>     REGISTER_LONG_CONSTANT("HTTP_GLOBAL_COOKIE", HTTP_GLOBAL_COOKIE, CONST_CS | CONST_PERSISTENT);
>     REGISTER_LONG_CONSTANT("HTTP_GLOBAL_ALL", HTTP_GLOBAL_GET| HTTP_GLOBAL_POST| HTTP_GLOBAL_COOKIE | HTTP_GLOBAL_REQUEST |HTTP_GLOBAL_SERVER | HTTP_GLOBAL_FILES, CONST_CS | CONST_PERSISTENT);
1126a1234,1236
>     zval *callback;
>     zval *event_name;
> 
1129c1239
<         swWarn("Server is running. Unable to set event callback now.");
---
>         swoole_php_error(E_WARNING, "Server is running. Unable to set event callback now.");
1133,1135c1243
<     zval *callback = NULL;;
<     zval *event_name = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &event_name, &callback))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &event_name, &callback) == FAILURE)
1137c1245
<         RETURN_FALSE;
---
>         return;
1140c1248,1249
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))
1142,1143c1251,1253
<     	swoole_php_fatal_error(E_WARNING,"user must set callback.");
<     	RETURN_FALSE;
---
>         swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
>         RETURN_FALSE;
1144a1255
>     efree(func_name);
1149,1150c1260,1261
<         php_sw_server_callbacks[SW_SERVER_CB_onRequest] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL("onRequest"), 0 TSRMLS_CC);
<         sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onRequest], _php_sw_server_callbacks[SW_SERVER_CB_onRequest]);
---
>         php_sw_http_server_callbacks[0] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL("onRequest"), 0 TSRMLS_CC);
>         sw_copy_to_stack(php_sw_http_server_callbacks[0], _php_sw_http_server_callbacks[0]);
1155,1156c1266,1267
<         php_sw_server_callbacks[SW_SERVER_CB_onHandShake] =  sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL("onHandshake"), 0 TSRMLS_CC);
<         sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onHandShake], _php_sw_server_callbacks[SW_SERVER_CB_onHandShake]);
---
>         php_sw_http_server_callbacks[1] = sw_zend_read_property(swoole_http_server_class_entry_ptr, getThis(), ZEND_STRL("onHandshake"), 0 TSRMLS_CC);
>         sw_copy_to_stack(php_sw_http_server_callbacks[1], _php_sw_http_server_callbacks[1]);
1167,1173c1278,1279
< 	if (!client)
< 	{
< 		return NULL;
< 	}
< 
<     http_context *ctx = emalloc(sizeof(http_context));
<     if (!ctx)
---
>     http_context *ctx;
>     if (client->http2)
1175,1176c1281,1290
<         swoole_error_log(SW_LOG_ERROR, SW_ERROR_MALLOC_FAIL, "emalloc(%ld) failed.", sizeof(http_context));
<         return NULL;
---
>         ctx = emalloc(sizeof(http_context));
>         if (!ctx)
>         {
>             swoole_error_log(SW_LOG_ERROR, SW_ERROR_MALLOC_FAIL, "emalloc(%ld) failed.", sizeof(http_context));
>             return NULL;
>         }
>     }
>     else
>     {
>         ctx = &client->context;
1181,1183c1295,1296
<     zval *zrequest_object = NULL;
<     SW_ALLOC_INIT_THE_ZVAL(zrequest_object,ctx->request._zobject);
<     ctx->request.zobject = zrequest_object;
---
>     zval *zrequest_object;
>     http_alloc_zval(ctx, request, zrequest_object);
1186d1298
<     ctx->refcount += 1;
1188,1190c1300,1301
<     zval *zresponse_object = NULL;
<     SW_ALLOC_INIT_THE_ZVAL(zresponse_object,ctx->response._zobject);
<     ctx->response.zobject = zresponse_object;
---
>     zval *zresponse_object;
>     http_alloc_zval(ctx, response, zresponse_object);
1193,1194d1303
<     ctx->refcount += 1;
<     ctx->response.release = 0;
1205c1314,1316
<     swoole_http_server_array_init(header, request,ctx);
---
>     http_alloc_zval(ctx, request, zheader);
>     array_init(zheader);
>     zend_update_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL("header"), zheader TSRMLS_CC);
1208c1319,1321
<     swoole_http_server_array_init(server, request,ctx);
---
>     http_alloc_zval(ctx, request, zserver);
>     array_init(zserver);
>     zend_update_property(swoole_http_request_class_entry_ptr, zrequest_object, ZEND_STRL("server"), zserver TSRMLS_CC);
1216c1329
< static void swoole_http_context_free(http_context *ctx TSRMLS_DC)
---
> void swoole_http_context_free(http_context *ctx TSRMLS_DC)
1218,1236c1331,1377
< 	if (!ctx)
< 	{
< 		return;
< 	}
< 
< 	if (ctx->mt_parser)
< 	{
< 		multipart_parser_free(ctx->mt_parser);
< 		ctx->mt_parser = NULL;
< 	}
< 
< 	swoole_efree(ctx->current_input_name);
< 	swoole_efree(ctx->current_form_data_name);
< 
< 	if (ctx->current_header_name_allocated)
< 	{
< 		swoole_efree(ctx->current_header_name);
< 		ctx->current_header_name_allocated = 0;
< 	}
---
>     swoole_set_object(ctx->request.zrequest_object, NULL);
>     swoole_set_object(ctx->response.zresponse_object, NULL);
> 
>     http_request *req = &ctx->request;
>     if (req->path)
>     {
>         efree(req->path);
>     }
>     if (req->post_content)
>     {
>         efree(req->post_content);
>     }
>     /**
>      * Free request object
>      */
>     if (req->zheader)
>     {
>         sw_zval_ptr_dtor(&req->zheader);
>     }
>     //get
>     if (req->zget)
>     {
>         sw_zval_ptr_dtor(&req->zget);
>     }
>     //post
>     if (req->zpost)
>     {
>         sw_zval_ptr_dtor(&req->zpost);
>     }
>     //cookie
>     if (req->zcookie)
>     {
>         sw_zval_ptr_dtor(&req->zcookie);
>     }
>     //request data
>     if (req->zdata)
>     {
>         sw_zval_ptr_dtor(&req->zdata);
>     }
>     //upload files
>     if (req->zfiles)
>     {
>         zval *zfiles = req->zfiles;
>         zval *value;
>         char *key;
>         int keytype;
>         uint32_t keylen;
1238,1239c1379,1413
<     http_request *req = &ctx->request;
<     swoole_efree(req->path);
---
>         SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(zfiles), key, keylen, keytype, value)
>         {
>             if (HASH_KEY_IS_STRING != keytype)
>             {
>                 continue;
>             }
>             zval *file_path;
>             if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS("tmp_name"), (void **) &file_path) == SUCCESS)
>             {
>                 unlink(Z_STRVAL_P(file_path));
>                 sw_zend_hash_del(SG(rfc1867_uploaded_files), Z_STRVAL_P(file_path), Z_STRLEN_P(file_path) + 1);
>             }
>             sw_zval_ptr_dtor(&value);
>         }
>         SW_HASHTABLE_FOREACH_END();
> #if PHP_MAJOR_VERSION < 7
>         sw_zval_ptr_dtor(&zfiles);
> #endif
>     }
>     //request server info
>     if (req->zserver)
>     {
>         sw_zval_ptr_dtor(&req->zserver);
>     }
>     //get + post + cookie array
>     if (req->zrequest)
>     {
>         sw_zval_ptr_dtor(&req->zrequest);
>     }
>     //swoole_http_request object
>     if (req->zrequest_object)
>     {
>         sw_zval_ptr_dtor(&req->zrequest_object);
>         req->zrequest_object = NULL;
>     }
1240a1415,1433
>     //swoole_http_response object
>     http_response *resp = &ctx->response;
>     if (resp->zresponse_object)
>     {
>         sw_zval_ptr_dtor(&resp->zresponse_object);
>         resp->zresponse_object = NULL;
>     }
>     //set-cookies
>     if (resp->zcookie)
>     {
>         sw_zval_ptr_dtor(&resp->zcookie);
>         resp->zcookie = NULL;
>     }
>     //http headers
>     if (resp->zheader)
>     {
>         sw_zval_ptr_dtor(&resp->zheader);
>         resp->zheader = NULL;
>     }
1242c1435
<     if (req->post_buffer)
---
>     if (ctx->buffer)
1244,1245c1437
<         swString_free(req->post_buffer);
<         req->post_buffer = NULL;
---
>         swString_free(ctx->buffer);
1248,1253c1440,1442
< 
<     ctx->request.zdata = NULL;
<     ctx->request.zobject = NULL;
<     ctx->response.zobject = NULL;
< 
<     swoole_efree(ctx);
---
>     ctx->end = 1;
>     ctx->send_header = 0;
>     ctx->gzip_enable = 0;
1375a1565,1580
> static PHP_METHOD(swoole_http_server, setglobal)
> {
>     long global_flag = 0;
>     long request_flag = HTTP_GLOBAL_GET | HTTP_GLOBAL_POST;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|l", &global_flag, &request_flag) == FAILURE)
>     {
>         return;
>     }
> 
>     http_merge_global_flag = global_flag;
>     http_merge_request_flag = request_flag;
> 
>     RETURN_TRUE;
> }
> 
1382c1587
<         swWarn("Server is running. Unable to execute swoole_server::start.");
---
>         swoole_php_error(E_WARNING, "Server is running. Unable to execute swoole_server::start.");
1391c1596
<         if (php_sw_server_callbacks[SW_SERVER_CB_onMessage] == NULL)
---
>         if (!swoole_websocket_isset_onMessage())
1402c1607
<     else if (php_sw_server_callbacks[SW_SERVER_CB_onRequest] == NULL)
---
>     else if (php_sw_http_server_callbacks[0] == NULL)
1408c1613
<     http_client_array = swArray_create(1024, sizeof(swoole_http_client));
---
>     http_client_array = swArray_new(1024, sizeof(swoole_http_client));
1411c1616
<         swoole_php_fatal_error(E_ERROR, "swArray_create(1024, %ld) failed.", sizeof(swoole_http_client));
---
>         swoole_php_fatal_error(E_ERROR, "swArray_new(1024, %ld) failed.", sizeof(swoole_http_client));
1444,1449c1649,1651
<     	zval* tmp = NULL;
<         SW_MAKE_STD_ZVAL(tmp);
<         array_init(tmp);
<         zend_update_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL("setting"), tmp TSRMLS_CC);
<         zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL("setting"), 1 TSRMLS_CC);
<         sw_zval_ptr_dtor(&tmp);
---
>         SW_MAKE_STD_ZVAL(zsetting);
>         array_init(zsetting);
>         zend_update_property(swoole_server_class_entry_ptr, getThis(), ZEND_STRL("setting"), zsetting TSRMLS_CC);
1452,1460c1654,1657
<     serv->listen_list->open_http_protocol = 1;
< 	serv->listen_list->open_mqtt_protocol = 0;
< 	serv->listen_list->open_eof_check = 0;
< 	serv->listen_list->open_length_check = 0;
< 
< 	add_assoc_bool(zsetting, "open_http_protocol", serv->listen_list->open_http_protocol);
<     add_assoc_bool(zsetting, "open_mqtt_protocol", serv->listen_list->open_mqtt_protocol);
<     add_assoc_bool(zsetting, "open_eof_check", serv->listen_list->open_eof_check);
<     add_assoc_bool(zsetting, "open_length_check", serv->listen_list->open_length_check);
---
>     add_assoc_bool(zsetting, "open_http_protocol", 1);
>     add_assoc_bool(zsetting, "open_mqtt_protocol", 0);
>     add_assoc_bool(zsetting, "open_eof_check", 0);
>     add_assoc_bool(zsetting, "open_length_check", 0);
1466a1664,1668
>     serv->listen_list->open_http_protocol = 1;
>     serv->listen_list->open_mqtt_protocol = 0;
>     serv->listen_list->open_eof_check = 0;
>     serv->listen_list->open_length_check = 0;
> 
1481d1682
< 
1487,1493d1687
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx)
< 	{
< 		swWarn("swoole_http_request rawcontent failed: ctx is NULL");
< 		RETURN_FALSE;
< 	}
< 
1495c1689
<     if (!zfd || ZVAL_IS_NULL(zfd))
---
>     if (ZVAL_IS_NULL(zfd))
1497c1691
<         swWarn("http client not exists.");
---
>         swoole_php_error(E_WARNING, "http client not exists.");
1501,1502c1695,1705
<     http_request *req = &ctx->request;
<     if (req->post_length > 0 && req->zdata)
---
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
>     {
>         RETURN_FALSE;
>     }
> 
>     if (ctx->request.post_content)
>     {
>         SW_RETVAL_STRINGL(ctx->request.post_content, ctx->request.post_length, 1);
>     }
>     else if (ctx->request.post_length > 0)
1504c1707
<         SW_RETVAL_STRINGL(Z_STRVAL_P(req->zdata) + Z_STRLEN_P(req->zdata) - req->post_length, req->post_length, 1);
---
>         SW_RETVAL_STRINGL(Z_STRVAL_P(ctx->request.zdata) + Z_STRLEN_P(ctx->request.zdata) - ctx->request.post_length, ctx->request.post_length, 1);
1507c1710
<     else if (req->post_buffer)
---
>     else if (ctx->http2 && ctx->buffer)
1509c1712
<         SW_RETVAL_STRINGL(req->post_buffer->str, req->post_buffer->length, 1);
---
>         SW_RETVAL_STRINGL(ctx->buffer->str, ctx->buffer->length, 1);
1518c1721
< static PHP_METHOD(swoole_http_request, __destruct)
---
> static PHP_METHOD(swoole_http_response, write)
1520,1549c1723,1724
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
<     zval *zfiles = sw_zend_read_property(swoole_http_request_class_entry_ptr, getThis(), ZEND_STRL("files"), 1 TSRMLS_CC);
<     //upload files
<     if (zfiles && Z_TYPE_P(zfiles) == IS_ARRAY)
<     {
<         zval *value;
<         char *key;
<         int keytype;
<         uint32_t keylen;
< 
<         SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(zfiles), key, keylen, keytype, value)
<         {
<             if (HASH_KEY_IS_STRING != keytype)
<             {
<                 continue;
<             }
<             zval *file_path;
<             if (sw_zend_hash_find(Z_ARRVAL_P(value), ZEND_STRS("tmp_name"), (void **) &file_path) == SUCCESS)
<             {
<                 unlink(Z_STRVAL_P(file_path));
<                 sw_zend_hash_del(SG(rfc1867_uploaded_files), Z_STRVAL_P(file_path), Z_STRLEN_P(file_path) + 1);
<             }
<         }
<         SW_HASHTABLE_FOREACH_END();
<         (void)key;
<         (void)keylen;
<     }
< 
<     swoole_set_object(getThis(), NULL);
<     if (ctx && ctx->refcount-- == 1)
---
>     zval *zdata;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zdata) == FAILURE)
1551c1726
<     	swoole_http_context_free(ctx TSRMLS_CC);
---
>         return;
1553,1561d1727
< }
< 
< static PHP_METHOD(swoole_http_response, write)
< {
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		RETURN_FALSE;
< 	}
1563,1564c1729,1730
<     zval *zdata = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zdata))
---
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
1566c1732
<     	RETURN_FALSE;
---
>         return;
1591c1757
<         swWarn("data is empty.");
---
>        swoole_php_error(E_WARNING, "data is empty.");
1601,1602c1767,1768
<     char *hex_string = NULL;
<     int hex_len = 0;
---
>     char *hex_string;
>     int hex_len;
1632c1798
<     sw_strdup_free(hex_string);
---
>     free(hex_string);
1640a1807
>         swoole_php_fatal_error(E_WARNING, "http client is not exist.");
1643d1809
< 
1646c1812
<         swWarn("http client is response end.");
---
>         swoole_php_fatal_error(E_WARNING, "http client is response end.");
1649d1814
< 
1655,1659d1819
< 	if (!ctx)
< 	{
< 		return;
< 	}
< 
1661,1662d1820
<     char buf[SW_HTTP_HEADER_MAX_SIZE] = {0};
<     char *date_str = NULL;
1664,1666c1822,1829
<     /// http status line
<     int n = snprintf(buf, sizeof(buf), "HTTP/1.1 %s\r\n", http_status_message(ctx->response.status));
<     n = n > SW_HTTP_HEADER_MAX_SIZE?SW_HTTP_HEADER_MAX_SIZE:n;
---
>     char buf[SW_HTTP_HEADER_MAX_SIZE];
>     int n;
>     char *date_str;
> 
>     /**
>      * http status line
>      */
>     n = snprintf(buf, sizeof(buf), "HTTP/1.1 %s\r\n", http_status_message(ctx->response.status));
1669c1832,1834
<     /// http header
---
>     /**
>      * http header
>      */
1671d1835
<     int flag = 0x0;
1673a1838,1844
>         int flag = 0x0;
>         char *key_server = "Server";
>         char *key_connection = "Connection";
>         char *key_content_length = "Content-Length";
>         char *key_content_type = "Content-Type";
>         char *key_date = "Date";
> 
1682c1853
<             if (!key || keylen <= 0)
---
>             if (!key)
1686c1857
<             if (strncasecmp(key, "Server", keylen) == 0)
---
>             if (strcmp(key, key_server) == 0)
1690c1861
<             else if (strncasecmp(key, "Connection", keylen) == 0)
---
>             else if (strcmp(key, key_connection) == 0)
1694c1865
<             else if (strncasecmp(key, "Content-Length", keylen) == 0)
---
>             else if (strcmp(key, key_content_length) == 0)
1698c1869
<             else if (strncasecmp(key, "Date", keylen) == 0)
---
>             else if (strcmp(key, key_date) == 0)
1702c1873
<             else if (strncasecmp(key, "Content-Type", keylen) == 0)
---
>             else if (strcmp(key, key_content_type) == 0)
1706d1876
< 
1708,1710c1878
<             n = n > SW_HTTP_HEADER_MAX_SIZE?SW_HTTP_HEADER_MAX_SIZE:n;
< 
<             swString_append_ptr(response, buf,n);
---
>             swString_append_ptr(response, buf, n);
1712d1879
< 
1714,1715d1880
<         (void)type;
<     }
1717,1733c1882,1904
<     if (!(flag & HTTP_RESPONSE_SERVER))
< 	{
< 		swString_append_ptr(response, ZEND_STRL("Server: "SW_HTTP_SERVER_SOFTWARE"\r\n"));
< 	}
< 
< 	if (!(flag & HTTP_RESPONSE_CONNECTION))
< 	{
< 		char* conStr = ctx->keepalive? "Connection: keep-alive\r\n":"Connection: close\r\n";
< 		swString_append_ptr(response,conStr,strlen(conStr));
< 	}
< 
< 	if (ctx->request.method == PHP_HTTP_OPTIONS)
< 	{
< 		swString_append_ptr(response, ZEND_STRL("Allow: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\r\nContent-Length: 0\r\n"));
< 	}
< 	else if (body_length > 0)
< 	{
---
>         if (!(flag & HTTP_RESPONSE_SERVER))
>         {
>             swString_append_ptr(response, ZEND_STRL("Server: "SW_HTTP_SERVER_SOFTWARE"\r\n"));
>         }
>         if (!(flag & HTTP_RESPONSE_CONNECTION))
>         {
>             if (ctx->keepalive)
>             {
>                 swString_append_ptr(response, ZEND_STRL("Connection: keep-alive\r\n"));
>             }
>             else
>             {
>                 swString_append_ptr(response, ZEND_STRL("Connection: close\r\n"));
>             }
>         }
>         if (ctx->request.method == PHP_HTTP_OPTIONS)
>         {
>             swString_append_ptr(response, ZEND_STRL("Allow: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS\r\nContent-Length: 0\r\n"));
>         }
>         else
>         {
>             if (!(flag & HTTP_RESPONSE_CONTENT_LENGTH) && body_length >= 0)
>             {
1735c1906,1909
< 		body_length = ctx->gzip_enable? swoole_zlib_buffer->length:body_length;
---
>                 if (ctx->gzip_enable)
>                 {
>                     body_length = swoole_zlib_buffer->length;
>                 }
1737,1739c1911,1937
< 		n = snprintf(buf, sizeof(buf), "Content-Length: %d\r\n", body_length);
< 		n = n > SW_HTTP_HEADER_MAX_SIZE?SW_HTTP_HEADER_MAX_SIZE:n;
< 		swString_append_ptr(response, buf, n);
---
>                 n = snprintf(buf, sizeof(buf), "Content-Length: %d\r\n", body_length);
>                 swString_append_ptr(response, buf, n);
>             }
>         }
>         if (!(flag & HTTP_RESPONSE_DATE))
>         {
>             date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);
>             n = snprintf(buf, sizeof(buf), "Date: %s\r\n", date_str);
>             swString_append_ptr(response, buf, n);
>             efree(date_str);
>         }
>         if (!(flag & HTTP_RESPONSE_CONTENT_TYPE))
>         {
>             swString_append_ptr(response, ZEND_STRL("Content-Type: text/html\r\n"));
>         }
>     }
>     else
>     {
>         swString_append_ptr(response, ZEND_STRL("Server: "SW_HTTP_SERVER_SOFTWARE"\r\nContent-Type: text/html\r\n"));
>         if (ctx->keepalive)
>         {
>             swString_append_ptr(response, ZEND_STRL("Connection: keep-alive\r\n"));
>         }
>         else
>         {
>             swString_append_ptr(response, ZEND_STRL("Connection: close\r\n"));
>         }
1741,1745c1939,1942
< 		if (!(flag & HTTP_RESPONSE_CONTENT_TYPE))
< 		{
< 			swString_append_ptr(response, ZEND_STRL("Content-Type: text/html\r\n"));
< 		}
< 	}
---
>         date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);
>         n = snprintf(buf, sizeof(buf), "Date: %s\r\n", date_str);
>         efree(date_str);
>         swString_append_ptr(response, buf, n);
1747,1754c1944,1960
< 	if (!(flag & HTTP_RESPONSE_DATE))
< 	{
< 		date_str = sw_php_format_date(ZEND_STRL(SW_HTTP_DATE_FORMAT), SwooleGS->now, 0 TSRMLS_CC);
< 		n = snprintf(buf, sizeof(buf), "Date: %s\r\n", date_str);
< 		n = n > SW_HTTP_HEADER_MAX_SIZE?SW_HTTP_HEADER_MAX_SIZE:n;
< 		swString_append_ptr(response, buf, n);
< 		swoole_efree(date_str);
< 	}
---
>         if (ctx->request.method == PHP_HTTP_OPTIONS)
>         {
>             n = snprintf(buf, sizeof(buf), "Allow: GET, POST, PUT, DELETE, HEAD, OPTIONS\r\nContent-Length: %d\r\n", 0);
>             swString_append_ptr(response, buf, n);
>         }
>         else if (body_length >= 0)
>         {
> #ifdef SW_HAVE_ZLIB
>             if (ctx->gzip_enable)
>             {
>                 body_length = swoole_zlib_buffer->length;
>             }
> #endif
>             n = snprintf(buf, sizeof(buf), "Content-Length: %d\r\n", body_length);
>             swString_append_ptr(response, buf, n);
>         }
>     }
1756d1961
< 	/// 与context 相关
1759c1964
<         swString_append_ptr(response, ZEND_STRL("Transfer-Encoding: chunked\r\n"));
---
>         swString_append_ptr(response, SW_STRL("Transfer-Encoding: chunked\r\n") - 1);
1764c1969
<         zval *value = NULL;
---
>         zval *value;
1771c1976
<             swString_append_ptr(response, ZEND_STRL("Set-Cookie: "));
---
>             swString_append_ptr(response, SW_STRL("Set-Cookie: ") - 1);
1773c1978
<             swString_append_ptr(response, ZEND_STRL("\r\n"));
---
>             swString_append_ptr(response, SW_STRL("\r\n") - 1);
1786d1990
< 
1792,1802d1995
< voidpf php_zlib_alloc(voidpf opaque, uInt items, uInt size)
< {
<     return (voidpf)safe_emalloc(items, size, 0);
< }
< 
< void php_zlib_free(voidpf opaque, voidpf address)
< {
< 	void* addrptr = (void*)address;
<     swoole_efree(addrptr);
< }
< 
1809c2002
<     if (memory_size > swoole_zlib_buffer->size && swString_extend(swoole_zlib_buffer, memory_size) < 0)
---
>     if (memory_size > swoole_zlib_buffer->size)
1811c2004
<         return SW_ERR;
---
>         swString_extend(swoole_zlib_buffer, memory_size);
1825,1828c2018
<     zstream.zalloc = php_zlib_alloc;
<     zstream.zfree = php_zlib_free;
< 
<     if (Z_OK == deflateInit2(&zstream, level, Z_DEFLATED, encoding, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY))
---
>     if (Z_OK == deflateInit2(&zstream, -1, Z_DEFLATED, encoding, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY))
1854,1859d2043
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		RETURN_FALSE;
< 	}
< 
1862c2046,2047
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &zdata))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &zdata) == FAILURE)
1872c2057,2058
<         if (length < 0 || !http_body.str)
---
> 
>         if (length < 0)
1886a2073,2078
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
>     {
>         RETURN_FALSE;
>     }
> 
1895d2086
<     int fd = ctx->fd;
1898,1899c2089
<     	ctx->chunk = 0;
<         ret = swServer_tcp_send(SwooleG.serv,fd, SW_STRL("0\r\n\r\n") - 1);
---
>         ret = swServer_tcp_send(SwooleG.serv, ctx->fd, SW_STRL("0\r\n\r\n") - 1);
1903a2094
>         ctx->chunk = 0;
1937c2128
<         ret = swServer_tcp_send(SwooleG.serv,fd, swoole_http_buffer->str, swoole_http_buffer->length);
---
>         ret = swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);
1944a2136,2137
>     swoole_http_context_free(ctx TSRMLS_CC);
> 
1947c2140,2144
<         SwooleG.serv->factory.end(&SwooleG.serv->factory, fd);
---
>         SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);
>     }
>     if (http_merge_global_flag > 0)
>     {
>         http_global_clear(TSRMLS_C);
1949,1950d2145
< 
<     ctx->response.release = 1;
1956,1965c2151,2155
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		RETURN_FALSE;
< 	}
< 
<     char *filename = NULL;
<     zend_size_t filename_length = 0;
<     int ret = -1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &filename, &filename_length))
---
>     char *filename;
>     zend_size_t filename_length;
>     int ret;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &filename, &filename_length) == FAILURE)
1970c2160
<     if (filename_length <= 0 || !filename)
---
>     if (filename_length <= 0)
1976,1977c2166,2167
< #ifdef SW_HAVE_ZLIB
<     if (ctx->gzip_enable)
---
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
1979d2168
<         swoole_php_error(E_ERROR, "cannot use sendfile when enable gzip compression.");
1982d2170
< #endif
1986c2174,2188
<     	swWarn("cannot use sendfile when enable Http-Chunk.");
---
>         swoole_php_error(E_WARNING, "cannot use HTTP-Chunk.");
>         RETURN_FALSE;
>     }
> 
>     int file_fd = open(filename, O_RDONLY);
>     if (file_fd < 0)
>     {
>         swoole_php_sys_error(E_WARNING, "open(%s) failed.", filename);
>         RETURN_FALSE;
>     }
> 
>     struct stat file_stat;
>     if (fstat(file_fd, &file_stat) < 0)
>     {
>         swoole_php_sys_error(E_WARNING, "fstat(%s) failed.", filename);
1990,1991c2192
<     size_t filelen = get_filelen_byname(filename);
<     if (filelen <= 0)
---
>     if (file_stat.st_size <= 0)
1993c2194
<         swWarn("file[offset=%ld] is empty.");
---
>         swoole_php_error(E_WARNING, "file is empty.");
1998c2199
<     http_build_header(ctx, getThis(), swoole_http_buffer, filelen TSRMLS_CC);
---
>     http_build_header(ctx, getThis(), swoole_http_buffer, file_stat.st_size TSRMLS_CC);
2013a2215
>     swoole_http_context_free(ctx TSRMLS_CC);
2018,2019c2220,2223
< 
<     ctx->response.release = 1;
---
>     if (http_merge_global_flag > 0)
>     {
>         http_global_clear(TSRMLS_C);
>     }
2025,2032c2229
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		swWarn("swoole_http_response cookie failed: ctx->response is release.");
< 		RETURN_FALSE;
< 	}
< 
< 	char *name = NULL, *value = NULL, *path = NULL, *domain = NULL;
---
>     char *name, *value = NULL, *path = NULL, *domain = NULL;
2036c2233
<     zend_size_t name_len = 0, value_len = 0, path_len = 0, domain_len = 0;
---
>     zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;
2038,2039c2235,2236
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|slssbb", &name, &name_len, &value, &value_len, &expires,
<                 						&path, &path_len, &domain, &domain_len, &secure, &httponly))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|slssbb", &name, &name_len, &value, &value_len, &expires,
>                 &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)
2043a2241,2246
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
>     {
>         RETURN_FALSE;
>     }
> 
2045d2247
<     zval *zresponse_object = ctx->response.zobject;
2048c2250,2252
<         swoole_http_server_array_init(cookie, response,ctx);
---
>         http_alloc_zval(ctx, response, zcookie);
>         array_init(zcookie);
>         zend_update_property(swoole_http_response_class_entry_ptr, getThis(), ZEND_STRL("cookie"), zcookie TSRMLS_CC);
2051c2255
<     char *cookie = NULL, *encoded_value = NULL;
---
>     char *cookie, *encoded_value = NULL;
2053c2257
<     char *dt = NULL;
---
>     char *dt;
2070c2274
<         encoded_value = estrndup(value,value_len);
---
>         encoded_value = estrdup(value);
2073,2075c2277,2284
< 
<     len += (path)? path_len:0;
<     len += (domain)? domain_len:0;
---
>     if (path)
>     {
>         len += path_len;
>     }
>     if (domain)
>     {
>         len += domain_len;
>     }
2078c2287
<     bzero(cookie,len+100);
---
> 
2083c2292
<         swoole_efree(dt);
---
>         efree(dt);
2089a2299
>             const char *p;
2092c2302
<             const char *p = zend_memrchr(dt, '-', strlen(dt));
---
>             p = zend_memrchr(dt, '-', strlen(dt));
2095,2098c2305,2308
<             	swoole_efree(dt);
<             	swoole_efree(cookie);
<             	swoole_efree(encoded_value);
<                 swWarn("Expiry date cannot have a year greater than 9999");
---
>                 efree(dt);
>                 efree(cookie);
>                 efree(encoded_value);
>                 swoole_php_error(E_WARNING, "Expiry date cannot have a year greater than 9999");
2102c2312
<             swoole_efree(dt);
---
>             efree(dt);
2105,2107c2315,2318
< 
<     swoole_efree(encoded_value);
< 
---
>     if (encoded_value)
>     {
>         efree(encoded_value);
>     }
2126,2127c2337,2340
<     sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 1);
<     swoole_efree(cookie);
---
>     sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);
> #if PHP_MAJOR_VERSION >= 7
>     efree(cookie);
> #endif
2132,2139c2345
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		swWarn("swoole_http_response rawcookie failed: ctx->response is release.");
< 		RETURN_FALSE;
< 	}
< 
< 	char *name = NULL, *value = NULL, *path = NULL, *domain = NULL;
---
>     char *name, *value = NULL, *path = NULL, *domain = NULL;
2143,2145c2349,2352
<     zend_size_t name_len = 0, value_len = 0, path_len = 0, domain_len = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|slssbb", &name, &name_len, &value, &value_len, &expires,
<                 						&path, &path_len, &domain, &domain_len, &secure, &httponly))
---
>     zend_size_t name_len, value_len = 0, path_len = 0, domain_len = 0;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|slssbb", &name, &name_len, &value, &value_len, &expires,
>                 &path, &path_len, &domain, &domain_len, &secure, &httponly) == FAILURE)
2149a2357,2362
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
>     {
>         RETURN_FALSE;
>     }
> 
2151d2363
<     zval *zresponse_object = ctx->response.zobject;
2154c2366,2368
<         swoole_http_server_array_init(cookie, response,ctx);
---
>         http_alloc_zval(ctx, response, zcookie);
>         array_init(zcookie);
>         zend_update_property(swoole_http_response_class_entry_ptr, getThis(), ZEND_STRL("cookie"), zcookie TSRMLS_CC);
2157c2371
<     char *cookie = NULL, *encoded_value = NULL;
---
>     char *cookie, *encoded_value = NULL;
2159c2373
<     char *dt = NULL;
---
>     char *dt;
2163c2377
<         swWarn("Cookie names cannot contain any of the following '=,; \\t\\r\\n\\013\\014'");
---
>         swoole_php_error(E_WARNING, "Cookie names cannot contain any of the following '=,; \\t\\r\\n\\013\\014'");
2176c2390
<         encoded_value = estrndup(value,value_len);
---
>         encoded_value = estrdup(value);
2179,2181c2393,2400
< 
<     len += (path)? path_len:0;
<     len += (domain)? domain_len:0;
---
>     if (path)
>     {
>         len += path_len;
>     }
>     if (domain)
>     {
>         len += domain_len;
>     }
2184c2403
<     bzero(cookie,len+100);
---
> 
2189c2408
<         swoole_efree(dt);
---
>         efree(dt);
2202,2205c2421,2424
<             	swoole_efree(dt);
<             	swoole_efree(cookie);
<             	swoole_efree(encoded_value);
<                 swWarn("Expiry date cannot have a year greater than 9999");
---
>                 efree(dt);
>                 efree(cookie);
>                 efree(encoded_value);
>                 swoole_php_error(E_WARNING, "Expiry date cannot have a year greater than 9999");
2209c2428
<             swoole_efree(dt);
---
>             efree(dt);
2212,2214c2431,2434
< 
< 	swoole_efree(encoded_value);
< 
---
>     if (encoded_value)
>     {
>         efree(encoded_value);
>     }
2233,2235c2453,2456
<     sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 1);
< 
<     swoole_efree(cookie);
---
>     sw_add_next_index_stringl(zcookie, cookie, strlen(cookie), 0);
> #if PHP_MAJOR_VERSION >= 7
>     efree(cookie);
> #endif
2240,2248c2461,2462
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		swWarn("swoole_http_response status failed: ctx->response is release.");
< 		RETURN_FALSE;
< 	}
< 
< 	long http_status;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &http_status))
---
>     long http_status;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &http_status) == FAILURE)
2253c2467,2473
<     ctx->response.status = http_status;
---
>     http_context *client = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!client)
>     {
>         RETURN_FALSE;
>     }
> 
>     client->response.status = http_status;
2258,2265c2478
< 	http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!ctx || ctx->response.release)
< 	{
< 		swWarn("swoole_http_response header failed: ctx->response is release.");
< 		RETURN_FALSE;
< 	}
< 
<     char *k = NULL, *v = NULL;
---
>     char *k, *v;
2267d2479
<     zend_bool ucwords = 1;
2269c2481
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|b", &k, &klen, &v, &vlen, &ucwords))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss", &k, &klen, &v, &vlen) == FAILURE)
2274,2276c2486,2487
<     zval *zheader = ctx->response.zheader;
<     zval *zresponse_object = ctx->response.zobject;
<     if (!zheader)
---
>     http_context *ctx = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!ctx)
2278c2489
<         swoole_http_server_array_init(header, response,ctx);
---
>         RETURN_FALSE;
2281c2492,2493
<     if (klen > SW_HTTP_HEADER_KEY_SIZE - 1)
---
>     zval *zheader = ctx->response.zheader;
>     if (!zheader)
2283,2284c2495,2497
<         swWarn("header key is too long.");
<         RETURN_FALSE;
---
>         http_alloc_zval(ctx, response, zheader);
>         array_init(zheader);
>         zend_update_property(swoole_http_response_class_entry_ptr, getThis(), ZEND_STRL("header"), zheader TSRMLS_CC);
2287c2500
<     if (ucwords)
---
>     if (ctx->http2)
2289,2301c2502
<         char key_buf[SW_HTTP_HEADER_KEY_SIZE] = {0};
<         memcpy(key_buf, k, klen);
<         key_buf[klen] = '\0';
<         if (ctx->http2)
<         {
<             swoole_strtolower(key_buf, klen);
<         }
<         else
<         {
<             http_header_key_format(key_buf, klen);
<         }
< 
<         sw_add_assoc_stringl_ex(zheader, key_buf, klen + 1, v, vlen, 1);
---
>         swoole_strtolower(k, klen);
2305c2506
<         sw_add_assoc_stringl_ex(zheader, k, klen + 1, v, vlen, 1);
---
>         http_header_key_format(k, klen);
2307c2508
< 
---
>     sw_add_assoc_stringl_ex(zheader, k, klen + 1, v, vlen, 1);
2310d2510
< #ifdef SW_HAVE_ZLIB
2313,2318c2513,2518
< 	http_context *context = http_get_context(getThis(), 0 TSRMLS_CC);
< 	if (!context || context->response.release)
< 	{
< 		swWarn("swoole_http_response gzip failed: ctx->response is release.");
< 		RETURN_FALSE;
< 	}
---
> #ifndef SW_HAVE_ZLIB
>     swoole_php_error(E_WARNING, "zlib library is not installed, cannot use gzip.");
>     RETURN_FALSE;
> #endif
>     
>     long level = 1;
2320,2321c2520
< 	long level = Z_DEFAULT_COMPRESSION;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &level))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &level) == FAILURE)
2326c2525,2526
<     if (context->send_header)
---
>     http_context *client = http_get_context(getThis(), 0 TSRMLS_CC);
>     if (!client)
2328d2527
<         swoole_php_fatal_error(E_WARNING, "must use before send header.");
2332,2335c2531,2535
<     context->gzip_enable = 1;
<     context->gzip_level = (level > 9)? 9:(level < 0? 0:level);
< }
< #endif
---
>     if (client->send_header)
>     {
>         swoole_php_fatal_error(E_WARNING, "must use before send header.");
>         RETURN_FALSE;
>     }
2337,2340c2537
< static PHP_METHOD(swoole_http_response, __destruct)
< {
<     http_context *context = swoole_get_object(getThis());
<     if (context && !context->response.release)
---
>     if (level > 9)
2342,2348c2539
<         zval *zobject = getThis();
<         zval *retval = NULL;
<         sw_zend_call_method_with_0_params(&zobject, swoole_http_response_class_entry_ptr, NULL, "end", &retval);
<         if (retval)
<         {
<             sw_zval_ptr_dtor(&retval);
<         }
---
>         level = 9;
2351,2360c2542,2543
<     swoole_set_object(getThis(), NULL);
< 	if (context)
< 	{
< 		context->response.release = 1;
< 	}
< 
< 	if (context && context->refcount-- == 1)
< 	{
< 		swoole_http_context_free(context TSRMLS_CC);
< 	}
---
>     client->gzip_enable = 1;
>     client->gzip_level = level;
diff -r ./zan-extension/swoole_http_v2_server.c ../swoole-1.8.5-stable/swoole_http_v2_server.c
33c33
< static sw_inline void http2_onRequest(http_context *ctx, int server_fd TSRMLS_DC)
---
> static void http2_onRequest(http_context *ctx TSRMLS_DC)
38,39c38,39
<     zval *zrequest_object = ctx->request.zobject;
<     zval *zresponse_object = ctx->response.zobject;
---
>     zval *zrequest_object = ctx->request.zrequest_object;
>     zval *zresponse_object = ctx->response.zresponse_object;
44,46c44,50
<     zval *zcallback = php_swoole_server_get_callback(SwooleG.serv, server_fd, SW_SERVER_CB_onRequest);
<     ctx->release = ctx_can_not_release;
<     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
---
> #ifdef __CYGWIN__
>     //TODO: memory error on cygwin.
>     zval_add_ref(&zrequest_object);
>     zval_add_ref(&zresponse_object);
> #endif
> 
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_http_server_callbacks[HTTP_CALLBACK_onRequest], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
58,59d61
<     sw_zval_ptr_dtor(&zrequest_object);
<     sw_zval_ptr_dtor(&zresponse_object);
93a96,99
>         char *key_server = "server";
>         char *key_content_length = "content-length";
>         char *key_content_type = "content-type";
>         char *key_date = "date";
107c113
<             if (strncmp(key, "server", keylen) == 0)
---
>             if (strcmp(key, key_server) == 0)
111c117
<             else if (strncmp(key, "content-length", keylen) == 0)
---
>             else if (strcmp(key, key_content_length) == 0)
115c121
<             else if (strncmp(key, "date", keylen) == 0)
---
>             else if (strcmp(key, key_date) == 0)
119c125
<             else if (strncmp(key, "content-type", keylen) == 0)
---
>             else if (strcmp(key, key_content_type) == 0)
126d131
<         (void)type;
218c223
<         swWarn("nghttp2_hd_deflate_init failed with error: %s\n", nghttp2_strerror(ret));
---
>         swoole_php_error(E_WARNING, "nghttp2_hd_deflate_init failed with error: %s\n", nghttp2_strerror(ret));
231c236
<         swWarn("nghttp2_hd_deflate_hd() failed with error: %s\n", nghttp2_strerror((int ) rv));
---
>         swoole_php_error(E_WARNING, "nghttp2_hd_deflate_hd() failed with error: %s\n", nghttp2_strerror((int ) rv));
237c242
<         swoole_efree(date_str);
---
>         efree(date_str);
247c252,254
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
249c256
<     char header_buffer[8192] = {0};
---
>     char header_buffer[8192];
267c274
<     char frame_header[9] = {0};
---
>     char frame_header[9];
282,283c289,291
<     swoole_http_client *client = ctx->client;
<     if (client->streams)
---
>     swoole_http_context_free(ctx TSRMLS_CC);
> 
>     if (ctx->client->streams)
285c293
<         swHashMap_del_int(client->streams, ctx->stream_id);
---
>         swHashMap_del_int(ctx->client->streams, ctx->stream_id);
286a295
>     efree(ctx);
288d296
<     ctx->response.release = 1;
294c302,304
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
303c313
<             swWarn("nghttp2_hd_inflate_init() failed, Error: %s[%d].", nghttp2_strerror(ret), ret);
---
>             swoole_php_error(E_WARNING, "nghttp2_hd_inflate_init() failed, Error: %s[%d].", nghttp2_strerror(ret), ret);
330c340
<             swWarn("inflate failed, Error: %s[%zd].", nghttp2_strerror(rv), rv);
---
>             swoole_php_error(E_WARNING, "inflate failed, Error: %s[%zd].", nghttp2_strerror(rv), rv);
345c355
<                 if (strncasecmp((char *) nv.name + 1, "method", nv.namelen -1) == 0)
---
>                 if (strncasecmp((char *) nv.name + 1, ZEND_STRL("method")) == 0)
349c359
<                 else if (strncasecmp((char *) nv.name + 1, "path", nv.namelen -1) == 0)
---
>                 else if (strncasecmp((char *) nv.name + 1, ZEND_STRL("path")) == 0)
364,365c374,376
<                         zval *zrequest_object = ctx->request.zobject;
<                         swoole_http_server_array_init(get, request,ctx);
---
>                         http_alloc_zval(ctx, request, zget);
>                         array_init(zget);
>                         zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("get"), zget TSRMLS_CC);
377c388
<                 else if (strncasecmp((char *) nv.name + 1, "authority", nv.namelen -1) == 0)
---
>                 else if (strncasecmp((char *) nv.name + 1, ZEND_STRL("authority")) == 0)
384c395
<                 if (strncasecmp((char *) nv.name, "content-type", nv.namelen) == 0)
---
>                 if (memcmp(nv.name, ZEND_STRL("content-type")) == 0)
386c397
<                     if (http_strncasecmp("application/x-www-form-urlencoded", (char *) nv.value, nv.valuelen))
---
>                     if (strncasecmp((char *) nv.value, ZEND_STRL("application/x-www-form-urlencoded")) == 0)
390c401
<                     else if (http_strncasecmp("multipart/form-data", (char *) nv.value, nv.valuelen))
---
>                     else if (strncasecmp((char *) nv.value, ZEND_STRL("multipart/form-data")) == 0)
393,397d403
<                         if (boundary_len <= 0)
<                         {
<                             swWarn("invalid multipart/form-data body.", ctx->fd);
<                             return 0;
<                         }
402c408
<                 else if (strncasecmp((char *) nv.name, "cookie", nv.namelen) == 0)
---
>                 else if (memcmp(nv.name, ZEND_STRL("cookie")) == 0)
405d410
<                     zval *zrequest_object = ctx->request.zobject;
408c413,415
<                         swoole_http_server_array_init(cookie, request,ctx);
---
>                         http_alloc_zval(ctx, request, zcookie);
>                         array_init(zcookie);
>                         zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("cookie"), zcookie TSRMLS_CC);
449c456,458
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
457c466
<     php_swoole_get_recv_data(zdata, req, NULL, 0);
---
>     zdata = php_swoole_get_recv_data(zdata, req TSRMLS_CC);
487,488d495
<             sw_zval_ptr_dtor(&(ctx->request.zobject));
<             sw_zval_ptr_dtor(&(ctx->response.zobject));
508c515
<             http2_onRequest(ctx, req->info.from_fd TSRMLS_CC);
---
>             http2_onRequest(ctx TSRMLS_CC);
514c521
<                 client->streams = swHashMap_create(SW_HTTP2_MAX_CONCURRENT_STREAMS, NULL);
---
>                 client->streams = swHashMap_new(SW_HTTP2_MAX_CONCURRENT_STREAMS, NULL);
529c536
<         swString *buffer = ctx->request.post_buffer;
---
>         swString *buffer = ctx->buffer;
533c540
<             ctx->request.post_buffer = buffer;
---
>             ctx->buffer = buffer;
542,545c549,553
<                 zval *zrequest_object = ctx->request.zobject;
<                 swoole_http_server_array_init(post, request,ctx);
<                 char *post_content = estrndup(buffer->str, buffer->length);
<                 sapi_module.treat_data(PARSE_STRING, post_content, zpost TSRMLS_CC);
---
>                 http_alloc_zval(ctx, request, zpost);
>                 array_init(zpost);
>                 ctx->request.post_content = estrndup(buffer->str, buffer->length);
>                 zend_update_property(swoole_http_request_class_entry_ptr, ctx->request.zrequest_object, ZEND_STRL("post"), zpost TSRMLS_CC);
>                 sapi_module.treat_data(PARSE_STRING, ctx->request.post_content, zpost TSRMLS_CC);
556c564
<             http2_onRequest(ctx, req->info.from_fd TSRMLS_CC);
---
>             http2_onRequest(ctx TSRMLS_CC);
573,581d580
< 
< void swoole_http2_free(swoole_http_client *client)
< {
<     if (client->inflater)
<     {
<         nghttp2_hd_inflate_del(client->inflater);
<         client->inflater = NULL;
<     }
< }
Only in ../swoole-1.8.5-stable/: swoole_lock.c
diff -r ./zan-extension/swoole_mysql.c ../swoole-1.8.5-stable/swoole_mysql.c
20,21d19
< #include "php7_wrapper.h"
< #include "swoole_mysql.h"
22a21
> #ifdef SW_ASYNC_MYSQL
24,96c23,63
< static PHP_METHOD(swoole_mysql, __construct);
< static PHP_METHOD(swoole_mysql, __destruct);
< static PHP_METHOD(swoole_mysql, connect);
< static PHP_METHOD(swoole_mysql, isConnected);
< static PHP_METHOD(swoole_mysql, setConnectTimeout);
< static PHP_METHOD(swoole_mysql, setQueryTimeout);
< #ifdef SW_USE_MYSQLND
< static PHP_METHOD(swoole_mysql, escape);
< #endif
< static PHP_METHOD(swoole_mysql, begin);
< static PHP_METHOD(swoole_mysql, commit);
< static PHP_METHOD(swoole_mysql, rollback);
< static PHP_METHOD(swoole_mysql, isUsedindex);
< static PHP_METHOD(swoole_mysql, query);
< static PHP_METHOD(swoole_mysql, safe_query);
< static PHP_METHOD(swoole_mysql, close);
< static PHP_METHOD(swoole_mysql, on);
< 
< static zend_class_entry swoole_mysql_ce;
< zend_class_entry *swoole_mysql_class_entry_ptr;
< 
< static swString *mysql_request_buffer = NULL;
< static int isset_event_callback = 0;
< 
< #define SERVER_QUERY_NO_GOOD_INDEX_USED 16
< #define SERVER_QUERY_NO_INDEX_USED      32
< 
< #define SW_MYSQL_DEFAULT_PORT            3306
< #define SW_MYSQL_QUERY_INIT_SIZE         8192
< #define SW_MYSQL_CONNECT_TIMEOUT         1.0
< #define SW_MYSQL_DEFAULT_CHARSET         33  //0x21, utf8_general_ci
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_on, 0, 0, 2)
<     ZEND_ARG_INFO(0, event_name)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_connect, 0, 0, 2)
<     ZEND_ARG_ARRAY_INFO(0, server_config, 0)
< 	ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< #ifdef SW_USE_MYSQLND
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_escape, 0, 0, 1)
<     ZEND_ARG_INFO(0, string)
<     ZEND_ARG_INFO(0, flags)
< ZEND_END_ARG_INFO()
< #endif
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_setTimeout, 0, 0, 1)
<     ZEND_ARG_INFO(0, timeout)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_query, 0, 0, 2)
<     ZEND_ARG_INFO(0, sql)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_mysql_prepare,0,0,3)
< 	ZEND_ARG_INFO(0, sql)
< 	ZEND_ARG_ARRAY_INFO(0,input_params,1)
< 	ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< static const zend_function_entry swoole_mysql_methods[] =
< {
<     PHP_ME(swoole_mysql, __construct, arginfo_swoole_void, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_mysql, __destruct, arginfo_swoole_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_ME(swoole_mysql, connect, arginfo_swoole_mysql_connect, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, isConnected, arginfo_swoole_void, ZEND_ACC_PUBLIC)
---
> #include "ext/mysqlnd/mysqlnd.h"
> #include "ext/mysqli/mysqli_mysqlnd.h"
> #include "ext/mysqli/php_mysqli_structs.h"
> 
> //#define SW_MYSQL_STRICT_TYPE
> //#define SW_MYSQL_DEBUG
> 
> enum mysql_command
> {
>     SW_MYSQL_COM_SLEEP = 0,
>     SW_MYSQL_COM_QUIT,
>     SW_MYSQL_SW_MYSQL_COM_INIT_DB,
>     SW_MYSQL_COM_QUERY = 3,
>     SW_MYSQL_COM_FIELD_LIST,
>     SW_MYSQL_COM_CREATE_DB,
>     SW_MYSQL_COM_DROP_DB,
>     SW_MYSQL_COM_REFRESH,
>     SW_MYSQL_COM_SHUTDOWN,
>     SW_MYSQL_COM_STATISTICS,
>     SW_MYSQL_COM_PROCESS_INFO,
>     SW_MYSQL_COM_CONNECT,
>     SW_MYSQL_COM_PROCESS_KILL,
>     SW_MYSQL_COM_DEBUG,
>     SW_MYSQL_COM_PING,
>     SW_MYSQL_COM_TIME,
>     SW_MYSQL_COM_DELAYED_INSERT,
>     SW_MYSQL_COM_CHANGE_USER,
>     SW_MYSQL_COM_BINLOG_DUMP,
>     SW_MYSQL_COM_TABLE_DUMP,
>     SW_MYSQL_COM_CONNECT_OUT,
>     SW_MYSQL_COM_REGISTER_SLAVE,
>     SW_MYSQL_COM_STMT_PREPARE,
>     SW_MYSQL_COM_STMT_EXECUTE,
>     SW_MYSQL_COM_STMT_SEND_LONG_DATA,
>     SW_MYSQL_COM_STMT_CLOSE,
>     SW_MYSQL_COM_STMT_RESET,
>     SW_MYSQL_COM_SET_OPTION,
>     SW_MYSQL_COM_STMT_FETCH,
>     SW_MYSQL_COM_DAEMON,
>     SW_MYSQL_COM_END
> };
98,100c65,72
< #ifdef SW_USE_MYSQLND
<     PHP_ME(swoole_mysql, escape, arginfo_swoole_mysql_escape, ZEND_ACC_PUBLIC)
< #endif
---
> enum mysql_read_state
> {
>     SW_MYSQL_STATE_QUERY,
>     SW_MYSQL_STATE_READ_START,
>     SW_MYSQL_STATE_READ_FIELD,
>     SW_MYSQL_STATE_READ_ROW,
>     SW_MYSQL_STATE_READ_END,
> };
102,112c74,100
< 	PHP_ME(swoole_mysql, setConnectTimeout, arginfo_swoole_mysql_setTimeout, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, setQueryTimeout, arginfo_swoole_mysql_setTimeout, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, begin, arginfo_swoole_void, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, commit, arginfo_swoole_void, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, rollback, arginfo_swoole_void, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, isUsedindex, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_mysql, query, arginfo_swoole_mysql_query, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_mysql, safe_query, arginfo_swoole_mysql_prepare, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_mysql, close, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_mysql, on, arginfo_swoole_mysql_on, ZEND_ACC_PUBLIC)
<     PHP_FE_END
---
> enum mysql_error_code
> {
>     SW_MYSQL_ERR_PROTOCOL_ERROR = 1,
>     SW_MYSQL_ERR_BUFFER_OVERSIZE,
>     SW_MYSQL_ERR_PACKET_CORRUPT,
>     SW_MYSQL_ERR_WANT_READ,
>     SW_MYSQL_ERR_WANT_WRITE,
>     SW_MYSQL_ERR_UNKNOWN_ERROR,
>     SW_MYSQL_ERR_MYSQL_ERROR,
>     SW_MYSQL_ERR_SERVER_LOST,
>     SW_MYSQL_ERR_BAD_PORT,
>     SW_MYSQL_ERR_RESOLV_HOST,
>     SW_MYSQL_ERR_SYSTEM,
>     SW_MYSQL_ERR_CANT_CONNECT,
>     SW_MYSQL_ERR_BUFFER_TOO_SMALL,
>     SW_MYSQL_ERR_UNEXPECT_R_STATE,
>     SW_MYSQL_ERR_STRFIELD_CORRUPT,
>     SW_MYSQL_ERR_BINFIELD_CORRUPT,
>     SW_MYSQL_ERR_BAD_LCB,
>     SW_MYSQL_ERR_LEN_OVER_BUFFER,
>     SW_MYSQL_ERR_CONVLONG,
>     SW_MYSQL_ERR_CONVLONGLONG,
>     SW_MYSQL_ERR_CONVFLOAT,
>     SW_MYSQL_ERR_CONVDOUBLE,
>     SW_MYSQL_ERR_CONVTIME,
>     SW_MYSQL_ERR_CONVTIMESTAMP,
>     SW_MYSQL_ERR_CONVDATE
115,117c103,132
< static void mysql_Client_timeout(swTimer* timer,swTimer_node* node);
< static void mysql_client_free(mysql_client *client);
< static void mysql_close(mysql_client *client);
---
> enum mysql_field_types
> {
>     SW_MYSQL_TYPE_DECIMAL,
>     SW_MYSQL_TYPE_TINY,
>     SW_MYSQL_TYPE_SHORT,
>     SW_MYSQL_TYPE_LONG,
>     SW_MYSQL_TYPE_FLOAT,
>     SW_MYSQL_TYPE_DOUBLE,
>     SW_MYSQL_TYPE_NULL,
>     SW_MYSQL_TYPE_TIMESTAMP,
>     SW_MYSQL_TYPE_LONGLONG,
>     SW_MYSQL_TYPE_INT24,
>     SW_MYSQL_TYPE_DATE,
>     SW_MYSQL_TYPE_TIME,
>     SW_MYSQL_TYPE_DATETIME,
>     SW_MYSQL_TYPE_YEAR,
>     SW_MYSQL_TYPE_NEWDATE,
>     SW_MYSQL_TYPE_VARCHAR,
>     SW_MYSQL_TYPE_BIT,
>     SW_MYSQL_TYPE_NEWDECIMAL = 246,
>     SW_MYSQL_TYPE_ENUM = 247,
>     SW_MYSQL_TYPE_SET = 248,
>     SW_MYSQL_TYPE_TINY_BLOB = 249,
>     SW_MYSQL_TYPE_MEDIUM_BLOB = 250,
>     SW_MYSQL_TYPE_LONG_BLOB = 251,
>     SW_MYSQL_TYPE_BLOB = 252,
>     SW_MYSQL_TYPE_VAR_STRING = 253,
>     SW_MYSQL_TYPE_STRING = 254,
>     SW_MYSQL_TYPE_GEOMETRY = 255
> };
119c134,220
< static void mysql_free_cb(mysql_client *client);
---
> typedef struct
> {
>     char *name; /* Name of column */
>     char *org_name; /* Original column name, if an alias */
>     char *table; /* Table of column if column was a field */
>     char *org_table; /* Org table name, if table was an alias */
>     char *db; /* Database for table */
>     char *catalog; /* Catalog for table */
>     char *def; /* Default value (set by mysql_list_fields) */
>     unsigned long length; /* Width of column (create length) */
>     unsigned long max_length; /* Max width for selected set */
>     unsigned int name_length;
>     unsigned int org_name_length;
>     unsigned int table_length;
>     unsigned int org_table_length;
>     unsigned int db_length;
>     unsigned int catalog_length;
>     unsigned int def_length;
>     unsigned int flags; /* Div flags */
>     unsigned int decimals; /* Number of decimals in field */
>     unsigned int charsetnr; /* Character set */
>     enum mysql_field_types type; /* Type of field. See mysql_com.h for types */
>     void *extension;
> } mysql_field;
> 
> typedef union
> {
>     signed char stiny;
>     unsigned char utiny;
>     unsigned char mbool;
>     short ssmall;
>     unsigned short small;
>     int sint;
>     unsigned int uint;
>     long long sbigint;
>     unsigned long long ubigint;
>     float mfloat;
>     double mdouble;
> } mysql_row;
> 
> typedef struct
> {
>     uint8_t state;
>     swString *buffer;
>     zval *callback;
> #if PHP_MAJOR_VERSION >= 7
>     zval _callback;
> #endif
>     struct
>     {
>         mysql_field *columns;
>         uint16_t num_column;
>         uint32_t num_row;
>         uint8_t wait_recv;
>         uint8_t response_type;
>         uint32_t packet_length :24;
>         uint32_t packet_number :8;
>         uint32_t error_code;
>         uint32_t warnings;
>         uint16_t status_code;
>         char status_msg[6];
>         char *server_msg;
>         ulong_t affected_rows;
>         ulong_t insert_id;
>         zval *result_array;
>     } response;
> 
> } mysql_client;
> 
> #define mysql_uint2korr(A)  (uint16_t) (((uint16_t) ((zend_uchar) (A)[0])) +\
>                                ((uint16_t) ((zend_uchar) (A)[1]) << 8))
> #define mysql_uint3korr(A)  (uint32_t) (((uint32_t) ((zend_uchar) (A)[0])) +\
>                                (((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
>                                (((uint32_t) ((zend_uchar) (A)[2])) << 16))
> #define mysql_uint4korr(A)  (uint32_t) (((uint32_t) ((zend_uchar) (A)[0])) +\
>                                (((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
>                                (((uint32_t) ((zend_uchar) (A)[2])) << 16) +\
>                                (((uint32_t) ((zend_uchar) (A)[3])) << 24))
> 
> #define mysql_uint8korr(A)    ((uint64_t)(((uint32_t) ((zend_uchar) (A)[0])) +\
>                                     (((uint32_t) ((zend_uchar) (A)[1])) << 8) +\
>                                     (((uint32_t) ((zend_uchar) (A)[2])) << 16) +\
>                                     (((uint32_t) ((zend_uchar) (A)[3])) << 24)) +\
>                                     (((uint64_t) (((uint32_t) ((zend_uchar) (A)[4])) +\
>                                     (((uint32_t) ((zend_uchar) (A)[5])) << 8) +\
>                                     (((uint32_t) ((zend_uchar) (A)[6])) << 16) +\
>                                     (((uint32_t) ((zend_uchar) (A)[7])) << 24))) << 32))
121,127d221
< static int swoole_mysql_onRead(swReactor *reactor, swEvent *event);
< static int swoole_mysql_onWrite(swReactor *reactor, swEvent *event);
< static int swoole_mysql_onError(swReactor *reactor, swEvent *event);
< static void swoole_mysql_onConnect(mysql_client *client TSRMLS_DC);
< static int swoole_mysql_onQuery(mysql_client *client TSRMLS_DC);
< static int query_handler(mysql_client *client,zval* zobject,swString* sql);
< static int really_register_bound_param(struct mysql_bound_param_data *param, struct mysql_bound_param_stmt *stmt);
128a223
> static int mysql_request(swString *sql, swString *buffer);
130,131c225,226
< static void debug_mysql_client_info(mysql_client *client);
< static void debug_mysql_column_info(mysql_field *field);
---
> static void mysql_client_info(mysql_client *client);
> static void mysql_column_info(mysql_field *field);
132a228,230
> static int mysql_decode_field(char *buf, int len, mysql_field *col);
> static int mysql_decode_row(mysql_client *client, char *buf, int packet_len);
> static int swoole_mysql_onRead(swReactor *reactor, swEvent *event);
134,141c232
< static sw_inline void defer_close(void* data)
< {
< 	mysql_client* client = (mysql_client*)data;
< 	client->released = 0;
< 	mysql_close(client);
< }
< 
< void swoole_mysql_init(int module_number TSRMLS_DC)
---
> static sw_inline void mysql_pack_length(int length, char *buf)
143,159c234,236
<     SWOOLE_INIT_CLASS_ENTRY(swoole_mysql_ce, "swoole_mysql", "Swoole\\Mysql", swoole_mysql_methods);
<     swoole_mysql_class_entry_ptr = zend_register_internal_class(&swoole_mysql_ce TSRMLS_CC);
< 
<     zend_declare_property_null(swoole_mysql_class_entry_ptr,ZEND_STRL("serverInfo"),ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_bool(swoole_mysql_class_entry_ptr, SW_STRL("internal_user")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("sock"), -1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_bool(swoole_mysql_class_entry_ptr, ZEND_STRL("connected"), 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("errno"), 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("connectTimeout"), 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("queryTimeout"), 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_stringl(swoole_mysql_class_entry_ptr, ZEND_STRL("error"),"",0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_stringl(swoole_mysql_class_entry_ptr, ZEND_STRL("connect_error"),"",0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("connect_errno"), 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("affected_rows"), 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("insert_id"),-1, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("warnings"),0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_mysql_class_entry_ptr, ZEND_STRL("status_code"),0, ZEND_ACC_PUBLIC TSRMLS_CC);
---
>     buf[2] = length >> 16;
>     buf[1] = length >> 8;
>     buf[0] = length;
162c239
< static void mysql_Client_timeout(swTimer* timer,swTimer_node* node)
---
> static sw_inline int mysql_lcb_ll(char *m, ulong_t *r, char *nul, int len)
164,196c241,244
< 	mysql_client *client = node? node->data:NULL;
< 	uint8_t timer_type = client && client->cli? client->cli->timeout_type:SW_CLIENT_INVAILED_TIMEOUT;
< 	if (timer_type == SW_CLIENT_CONNECT_TIMEOUT || timer_type == SW_CLIENT_RECV_TIMEOUT)
< 	{
< 		client->cli->timer_id = 0;
< 		zval *zobject = client->object;
< 		if (client->onTimeout)
< 		{
< 			zval* callback = client->onTimeout;
< 			zval* eventType = NULL;
< 			SW_MAKE_STD_ZVAL(eventType);
< 			ZVAL_LONG(eventType,timer_type);
< 			zval **args[2];
< 			args[0] = &zobject;
< 			args[1] = &eventType;
< 			zval *retval = NULL;
< 			if (sw_call_user_function_ex(EG(function_table), NULL,callback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
< 			{
< 				swWarn("timeout event handler error.");
< 			}
< 
< 			if (EG(exception))
< 			{
< 				zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 			}
< 
< 			if (retval) sw_zval_ptr_dtor(&retval);
< 			if (eventType) sw_zval_ptr_dtor(&eventType);
< 		}
< 	}
< 
< 	swTimer_del(timer,node->id);
< }
---
>     if (len < 1)
>         return -1;
>     switch ((unsigned char) m[0])
>     {
198,230c246,249
< static void mysql_client_free(mysql_client *client)
< {
< 	if (client->buffer)
< 	{
< 		swString_free(client->buffer);
< 		client->buffer = NULL;
< 	}
< 
< 	if (client->response.result_array)
< 	{
< 		zval* result_array = client->response.result_array;
< 		client->response.result_array = NULL;
< 		sw_zval_free(result_array);
< 	}
< 
< 	if (client->response.columns)
< 	{
< 		int i;
< 		for (i = 0; i < client->response.num_column; i++)
< 		{
< 			swoole_efree(client->response.columns[i].buffer);
< 		}
< 
< 		swoole_efree(client->response.columns);
< 	}
< 
< //	mysql_free_cb(client);
< 	mysql_close(client);
< 
< //	client->fd = -1;
< 	client->handshake = SW_MYSQL_HANDSHAKE_INIT;
< 	client->state = SW_MYSQL_STATE_INIT;
< }
---
>     case 251: /* fb : 1 octet */
>         *r = 0;
>         *nul = 1;
>         return 1;
232,242c251,258
< #ifdef SW_MYSQL_DEBUG
< static void debug_mysql_client_info(mysql_client *client)
< {
<     printf("\n"SW_START_LINE"\nmysql_client\nbuffer->offset=%ld\nbuffer->length=%ld\nstatus=%d\n"
<             "packet_length=%d\npacket_number=%d\n"
<             "insert_id=%d\naffected_rows=%d\n"
<             "warnings=%d\n"SW_END_LINE, client->buffer->offset, client->buffer->length, client->response.status_code,
<             client->response.packet_length, client->response.packet_number,
<             client->response.insert_id, client->response.affected_rows,
<             client->response.warnings);
<     int i;
---
>     case 252: /* fc : 2 octets */
>         if (len < 3)
>         {
>             return -1;
>         }
>         *r = mysql_uint2korr(m + 1);
>         *nul = 0;
>         return 3;
244,246c260,261
<     if (client->response.num_column)
<     {
<         for (i = 0; i < client->response.num_column; i++)
---
>     case 253: /* fd : 3 octets */
>         if (len < 5)
248c263
<             mysql_column_info(&client->response.columns[i]);
---
>             return -1;
250,251c265,267
<     }
< }
---
>         *r = mysql_uint3korr(m + 1);
>         *nul = 0;
>         return 4;
253,263c269,276
< static void debug_mysql_column_info(mysql_field *field)
< {
<     printf("\n"SW_START_LINE"\nname=%s, table=%s, db=%s\n"
<             "name_length=%d, table_length=%d, db_length=%d\n"
<             "catalog=%s, default_value=%s\n"
<             "length=%ld, type=%d\n"SW_END_LINE,
<             field->name, field->table, field->db,
<             field->name_length, field->table_length, field->db_length,
<             field->catalog, field->def,
<             field->length, field->type
<            );
---
>     case 254: /* fe */
>         if (len < 9)
>         {
>             return -1;
>         }
>         *r = mysql_uint8korr(m + 1);
>         *nul = 0;
>         return 9;
264a278,282
>     default:
>         *r = (unsigned char) m[0];
>         *nul = 0;
>         return 1;
>     }
266d283
< #endif
268c285
< static void mysql_close(mysql_client *client)
---
> static sw_inline int mysql_length_coded_binary(char *m, ulong_t *r, char *nul, int len)
270,319c287,290
< 	if (!client)
< 	{
< 		return;
< 	}
< 
< 	if (client->fd > 0)
< 	{
< 		SwooleG.main_reactor->del(SwooleG.main_reactor, client->fd);
< 		swConnection *socket = swReactor_get(SwooleG.main_reactor, client->fd);
< 		socket->object = NULL;
< 		client->fd = -1;
< 	}
< 
< 	if (client->cli)
< 	{
< 		client->cli->close(client->cli);
< 		swoole_efree(client->cli);
< 	}
< 
< 	if (client->released)
< 	{
< 		return;
< 	}
< 
< 	client->released = 1;
< 	zval *object = client->object;
< 	if (client->onClose && object)
< 	{
< 		zval *retval = NULL;
< 		zval **args[1];
< 		args[0] = &object;
< 
< 		if (sw_call_user_function_ex(EG(function_table), NULL, client->onClose, &retval, 1, args, 0, NULL TSRMLS_CC) != SUCCESS)
< 		{
< 			swoole_php_fatal_error(E_WARNING, "swoole_mysql onClose callback error.");
< 		}
< 
< 		if (retval)
< 		{
< 			sw_zval_ptr_dtor(&retval);
< 		}
< 	}
< 
< 	mysql_free_cb(client);
< 	if (client->object)
< 	{
< 		zval* obj = client->object;
< 		client->object = NULL;
< 		sw_zval_ptr_dtor(&obj);
< 	}
---
>     ulong_t val = 0;
>     int retcode = mysql_lcb_ll(m, &val, nul, len);
>     *r = val;
>     return retcode;
322c293
< static void mysql_free_cb(mysql_client *client)
---
> static sw_inline void mysql_get_socket(zval *mysql_link, zval *return_value, int *sock TSRMLS_DC)
324,333c295,297
< 	if (!client)
< 	{
< 		return ;
< 	}
< 
< 	if (client->onClose) {sw_zval_ptr_dtor(&client->onClose);client->onClose = NULL;}
< 	if (client->onTimeout) {sw_zval_ptr_dtor(&client->onTimeout);client->onTimeout = NULL;}
< 	if (client->onConnect) {sw_zval_free(client->onConnect);client->onConnect = NULL;}
< 	if (client->callback) {sw_zval_free(client->callback);client->callback = NULL;}
< }
---
>     MY_MYSQL *mysql;
>     php_stream *stream;
>     *sock = -1;
335,337c299
< static PHP_METHOD(swoole_mysql, __construct)
< {
<     if (!mysql_request_buffer)
---
>     if (Z_TYPE_P(mysql_link) != IS_OBJECT || strcasecmp(Z_OBJCE_P(mysql_link)->name, "mysqli") != 0)
339,344c301
<         mysql_request_buffer = swString_new(SW_MYSQL_QUERY_INIT_SIZE);
<         if (!mysql_request_buffer)
<         {
<             swoole_php_fatal_error(E_ERROR, "[1] swString_new(%d) failed.", SW_HTTP_RESPONSE_INIT_SIZE);
<             RETURN_FALSE;
<         }
---
>         return;
347,359c304,314
<     mysql_client *client = emalloc(sizeof(mysql_client));
<     bzero(client, sizeof(mysql_client));
<     client->fd = -1;
< 	client->handshake = SW_MYSQL_HANDSHAKE_INIT;
< 	client->state = SW_MYSQL_STATE_INIT;
< 
< 	swoole_set_object(getThis(), client);
< }
< 
< static PHP_METHOD(swoole_mysql, __destruct)
< {
<     mysql_client *client = swoole_get_object(getThis());
<     if (client)
---
> #if PHP_MAJOR_VERSION > 5
>     MYSQLI_FETCH_RESOURCE_CONN(mysql, mysql_link, MYSQLI_STATUS_VALID);
>     stream = mysql->mysql->data->net->data->m.get_stream(mysql->mysql->data->net TSRMLS_CC);
> #elif PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION > 4
>     MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
>     stream = mysql->mysql->data->net->data->m.get_stream(mysql->mysql->data->net TSRMLS_CC);
> #else
>     MYSQLI_FETCH_RESOURCE_CONN(mysql, &mysql_link, MYSQLI_STATUS_VALID);
>     stream = mysql->mysql->data->net->stream;
> #endif
>     if (php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void* )sock, 1) != SUCCESS || *sock <= 2)
361,362c316
<     	client->object = NULL;   /// 对象析构不回调至php层
<     	mysql_client_free(client);
---
>         return;
364,368d317
< 
<     releaseConnobj(getThis());
< 
<     swoole_efree(client);
<     swoole_set_object(getThis(), NULL);
371c320
< static PHP_METHOD(swoole_mysql, on)
---
> static sw_inline int mysql_decode_field(char *buf, int len, mysql_field *col)
373,381c322,326
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client)
< 	{
< 		swWarn("object is not instanceof swoole_mysql.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval *internal_user = sw_zend_read_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	int disable_set = internal_user && Z_BVAL_P(internal_user);
---
>     int i;
>     unsigned long size;
>     char nul;
>     char *wh;
>     int tmp_len;
383,389c328
<     char *name = NULL;
<     zend_size_t len = 0;
<     zval *cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &name, &len, &cb))
<     {
<     	RETURN_FALSE;
<     }
---
>     wh = buf;
391,395c330
<     if (!name || len <= 0 || swoole_check_callable(cb TSRMLS_CC) < 0)
<     {
<     	swWarn("error callback.");
<     	RETURN_FALSE;
<     }
---
>     i = 0;
397c332,333
<     if (len == strlen("close") && strncasecmp("close", name, len) == 0)
---
>     tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>     if (tmp_len == -1)
399,407c335
<     	if (disable_set)
< 		{
< 			swWarn("object created by connection pool,disable set close event");
< 			RETURN_FALSE;
< 		}
< 
<         if (client->onClose) sw_zval_ptr_dtor(&client->onClose);
<         client->onClose = cb;
<         sw_copy_to_stack(client->onClose, client->_onClose);
---
>         return -SW_MYSQL_ERR_BAD_LCB;
409c337,338
<     else if (len == strlen("timeout") && strncasecmp("timeout", name, len) == 0)
---
>     i += tmp_len;
>     if (i + size > len)
411,413c340
<     	if (client->onTimeout) sw_zval_ptr_dtor(&client->onTimeout);
< 		client->onTimeout = cb;
< 		sw_copy_to_stack(client->onTimeout, client->_onTimeout);
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
415c342,351
<     else
---
>     col->catalog_length = size;
>     memmove(wh, &buf[i], size);
>     col->catalog = wh;
>     col->catalog[size] = '\0';
>     wh += size + 1;
>     i += size;
> 
>     /* n (Length Coded String)    db */
>     tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>     if (tmp_len == -1)
417,418c353
<         swWarn("Unknown callback type[%s]", name);
<         RETURN_FALSE;
---
>         return -SW_MYSQL_ERR_BAD_LCB;
420,447c355,356
< 
<     sw_zval_add_ref(&cb);
<     RETURN_TRUE;
< }
< 
< static PHP_METHOD(swoole_mysql, connect)
< {
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || client->released)
< 	{
< 		swWarn("please construct swoole_mysql first");
< 		RETURN_FALSE;
< 	}
< 
< 	if (client->cli)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	zval *internal_user = sw_zend_read_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	if (internal_user && Z_BVAL_P(internal_user))
< 	{
< 		return;
< 	}
< 
<     zval *server_info = NULL;
<     zval *callback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "az", &server_info, &callback))
---
>     i += tmp_len;
>     if (i + size > len)
449c358
<         RETURN_FALSE;
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
450a360,365
>     col->db_length = size;
>     memmove(wh, &buf[i], size);
>     col->db = wh;
>     col->db[size] = '\0';
>     wh += size + 1;
>     i += size;
452,463c367,369
<     php_swoole_array_separate(server_info);
<     HashTable *_ht = Z_ARRVAL_P(server_info);
< 
<     mysql_connector *connector = &client->connector;
<     zval *value = NULL;
<     if (php_swoole_array_get_value(_ht, "host", value))
<     {
<         convert_to_string(value);
<         connector->host = Z_STRVAL_P(value);
<         connector->host_len = Z_STRLEN_P(value);
<     }
<     else
---
>     /* n (Length Coded String)    table */
>     tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>     if (tmp_len == -1)
465,466c371
<         swWarn("HOST parameter is required.");
<         RETURN_FALSE;
---
>         return -SW_MYSQL_ERR_BAD_LCB;
468,471c373,374
< 
<     value = NULL;
<     connector->port = SW_MYSQL_DEFAULT_PORT;
<     if (php_swoole_array_get_value(_ht, "port", value))
---
>     i += tmp_len;
>     if (i + size > len)
473,474c376
<         convert_to_long(value);
<         connector->port = Z_LVAL_P(value);
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
475a378,383
>     col->table_length = size;
>     memmove(wh, &buf[i], size);
>     col->table = wh;
>     col->table[size] = '\0';
>     wh += size + 1;
>     i += size;
477,478c385,387
<     value = NULL;
<     if (php_swoole_array_get_value(_ht, "user", value))
---
>     /* n (Length Coded String)    org_table */
>     tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>     if (tmp_len == -1)
480,482c389
<         convert_to_string(value);
<         connector->user = Z_STRVAL_P(value);
<         connector->user_len = Z_STRLEN_P(value);
---
>         return -SW_MYSQL_ERR_BAD_LCB;
484c391,392
<     else
---
>     i += tmp_len;
>     if (i + size > len)
486,487c394
<         swWarn("USER parameter is required.");
<         RETURN_FALSE;
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
488a396,401
>     col->org_table_length = size;
>     memmove(wh, &buf[i], size);
>     col->org_table = wh;
>     col->org_table[size] = '\0';
>     wh += size + 1;
>     i += size;
490c403,405
<     if (php_swoole_array_get_value(_ht, "password", value))
---
>     /* n (Length Coded String)    name */
>     tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>     if (tmp_len == -1)
492,494c407
<         convert_to_string(value);
<         connector->password = Z_STRVAL_P(value);
<         connector->password_len = Z_STRLEN_P(value);
---
>         return -SW_MYSQL_ERR_BAD_LCB;
496c409,410
<     else
---
>     i += tmp_len;
>     if (i + size > len)
498,499c412
<         connector->password = NULL;
<         connector->password_len = 0;
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
501c414,423
<     if (php_swoole_array_get_value(_ht, "database", value))
---
>     col->name_length = size;
>     memmove(wh, &buf[i], size);
>     col->name = wh;
>     col->name[size] = '\0';
>     wh += size + 1;
>     i += size;
> 
>     /* n (Length Coded String)    org_name */
>     tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>     if (tmp_len == -1)
503,505c425
<         convert_to_string(value);
<         connector->database = Z_STRVAL_P(value);
<         connector->database_len = Z_STRLEN_P(value);
---
>         return -SW_MYSQL_ERR_BAD_LCB;
507c427,428
<     else
---
>     i += tmp_len;
>     if (i + size > len)
509,510c430
<         swWarn("DATABASE parameter is required.");
<         RETURN_FALSE;
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
511a432,437
>     col->org_name_length = size;
>     memmove(wh, &buf[i], size);
>     col->org_name = wh;
>     col->org_name[size] = '\0';
>     wh += size + 1;
>     i += size;
513,525c439,440
< //    value = NULL;
< //    int  use_connector_times = 0;
< //    connector->timeout = 1;
< //    if (php_swoole_array_get_value(_ht, "timeout", value))
< //    {
< //        convert_to_double(value);
< //        connector->timeout = Z_DVAL_P(value);
< //        use_connector_times = 1;
< //    }
< 
<     value = NULL;
<     connector->character_set = 0;
<     if (php_swoole_array_get_value(_ht, "charset", value))
---
>     /* check len */
>     if (i + 13 > len)
527,535c442
<         convert_to_string(value);
<         connector->character_set = mysql_get_charset(Z_STRVAL_P(value));
<         if (connector->character_set < 0)
<         {
< 			char buf[1024] = {0};
< 			snprintf(buf, sizeof(buf), "unknown charset [%s].", Z_STRVAL_P(value));
< 			swWarn("%s",buf);
< 			RETURN_FALSE;
<         }
---
>         return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
538,548c445,446
<     int type = SW_SOCK_TCP;
<     if (strncasecmp(connector->host, ZEND_STRL("unix:/")) == 0)
<     {
<         connector->host = connector->host + 5;
<         connector->host_len = connector->host_len - 5;
<         type = SW_SOCK_UNIX_STREAM;
<     }
<     else if (strchr(connector->host, ':'))
<     {
<         type = SW_SOCK_TCP6;
<     }
---
>     /* (filler) */
>     i += 1;
550,557c448,450
<     php_swoole_check_reactor();
<     if (!isset_event_callback)
<     {
<         SwooleG.main_reactor->setHandle(SwooleG.main_reactor, PHP_SWOOLE_FD_MYSQL | SW_EVENT_READ, swoole_mysql_onRead);
<         SwooleG.main_reactor->setHandle(SwooleG.main_reactor, PHP_SWOOLE_FD_MYSQL | SW_EVENT_WRITE, swoole_mysql_onWrite);
<         SwooleG.main_reactor->setHandle(SwooleG.main_reactor, PHP_SWOOLE_FD_MYSQL | SW_EVENT_ERROR, swoole_mysql_onError);
<         isset_event_callback = 1;
<     }
---
>     /* charset */
>     col->charsetnr = uint2korr(&buf[i]);
>     i += 2;
559,564c452,454
<     swClient *cli = emalloc(sizeof(swClient));
<     if (!cli)
<     {
<     	swWarn("emalloc swoole Client failed.");
<     	RETURN_FALSE;
<     }
---
>     /* length */
>     col->length = uint4korr(&buf[i]);
>     i += 4;
566,572c456,458
<     client->cli = cli;
<     bzero(cli,sizeof(swClient));
<     if (swClient_create(cli, type, 0) < 0)
<     {
<         swWarn("swClient_create failed.");
<         RETURN_FALSE;
<     }
---
>     /* type */
>     col->type = (unsigned char) buf[i];
>     i += 1;
574,582c460,462
<     if (type != SW_SOCK_UNIX_STREAM)
<     {
<         int tcp_nodelay = 1;
<         //tcp nodelay
<         if (setsockopt(cli->socket->fd, IPPROTO_TCP, TCP_NODELAY, (const void *) &tcp_nodelay, sizeof(int)) == -1)
<         {
<             swoole_php_sys_error(E_WARNING, "setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) failed.", cli->socket->fd);
<         }
<     }
---
>     /* flags */
>     col->flags = uint3korr(&buf[i]);
>     i += 2;
584,589c464,466
<     swConnection *_socket = swReactor_get(SwooleG.main_reactor, cli->socket->fd);
<     if (!_socket)
<     {
<     	swWarn("get socket from reactor error.");
<     	RETURN_FALSE;
<     }
---
>     /* decimals */
>     col->decimals = buf[i];
>     i += 1;
591,593c468,469
<     bzero(_socket,sizeof(swConnection));
<     _socket->object = client;
<     _socket->fd = cli->socket->fd;
---
>     /* filler */
>     i += 2;
595,597c471,472
<     //connect to mysql server
<     int ret = cli->connect(cli, connector->host, connector->port, 0,1);
<     if ((ret < 0 && errno == EINPROGRESS) || ret == 0)
---
>     /* default - a priori facultatif */
>     if (len - i > 0)
599c474,480
<         if (SwooleG.main_reactor->add(SwooleG.main_reactor, cli->socket->fd, PHP_SWOOLE_FD_MYSQL | SW_EVENT_WRITE) < 0)
---
>         tmp_len = mysql_length_coded_binary(&buf[i], &size, &nul, len - i);
>         if (tmp_len == -1)
>         {
>             return -SW_MYSQL_ERR_BAD_LCB;
>         }
>         i += tmp_len;
>         if (i + size > len)
601c482
<             RETURN_FALSE;
---
>             return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
602a484,489
>         col->def_length = size;
>         memmove(wh, &buf[i], size);
>         col->def = wh;
>         col->def[size] = '\0';
>         wh += size + 1;
>         i += size;
606,609c493,494
<     	char buf[1024] = {0};
<         snprintf(buf, sizeof(buf), "connect to mysql server[%s:%d] failed.", connector->host, connector->port);
<         swWarn("%s", buf);
<         RETURN_FALSE;
---
>         col->def = NULL;
>         col->def_length = 0;
612,625c497,499
<     client->fd = cli->socket->fd;
<     if (!callback || ZVAL_IS_NULL(callback))
<     {
<     	client->onConnect = NULL;
<     }
<     else if (swoole_check_callable(callback TSRMLS_CC) < 0)
<     {
<     	RETURN_FALSE;
<     }
<     else
<     {
<     	sw_zval_add_ref(&callback);
<     	client->onConnect = sw_zval_dup(callback);
<     }
---
>     /* set write pointer */
>     return wh - buf;
> }
627,628c501,506
<     zend_update_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("serverInfo"), server_info TSRMLS_CC);
<     zend_update_property_long(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("sock"), cli->socket->fd TSRMLS_CC);
---
> static sw_inline int mysql_decode_row(mysql_client *client, char *buf, int packet_len)
> {
>     int read_n = 0, i;
>     int tmp_len;
>     unsigned long len;
>     char nul;
630,656c508,514
<     client->buffer = swString_new(SW_BUFFER_SIZE_BIG);
<     client->object = getThis();
<     sw_zval_add_ref(&(client->object));
< 	sw_copy_to_stack(client->object, client->_object);
<     sw_zval_ptr_dtor(&server_info);
< 
<     long timeout = 0;
<     zval* connectTimeout = sw_zend_read_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connectTimeout"), 1 TSRMLS_CC);
< 	if (connectTimeout)
< 	{
< 		convert_to_long(connectTimeout);
< 		timeout = Z_LVAL_P(connectTimeout);
< 	}
< 
<     if (client->cli && timeout > 0)
< 	{
<     		client->cli->timer_id = 0;
<     		client->cli->timer_id = swTimer_add(&SwooleG.timer,timeout,0,client,MYSQL_USED);
< 		if (cli->timer_id <= 0)
< 		{
< 			swWarn("set connect timeout timer failed.");
< 			RETURN_FALSE;
< 		}
< 
< 		client->cli->timeout_type = SW_CLIENT_CONNECT_TIMEOUT;
< 		register_after_cb(&SwooleG.timer,MYSQL_USED,mysql_Client_timeout);
< 	}
---
> #ifdef SW_MYSQL_STRICT_TYPE
>     mysql_row row;
>     char value_buffer[32];
>     bzero(&row, sizeof(row));
>     char *error;
>     char mem;
> #endif
658,659c516,519
<     RETURN_TRUE;
< }
---
>     zval *result_array = client->response.result_array;
>     zval *row_array;
>     SW_ALLOC_INIT_ZVAL(row_array);
>     array_init(row_array);
661,667c521,527
< static PHP_METHOD(swoole_mysql,isConnected)
< {
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || client->released || !client->cli)
< 	{
< 		RETURN_FALSE;
< 	}
---
>     for (i = 0; i < client->response.num_column; i++)
>     {
>         tmp_len = mysql_length_coded_binary(&buf[read_n], &len, &nul, packet_len - read_n);
>         if (tmp_len == -1)
>         {
>             return -SW_MYSQL_ERR_BAD_LCB;
>         }
669,670c529,533
< 	zval* value = sw_zend_read_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connected"), 1 TSRMLS_CC);
< 	int connected = (value && Z_BVAL_P(value))? 1:0;
---
>         read_n += tmp_len;
>         if (read_n + len > packet_len)
>         {
>             return -SW_MYSQL_ERR_LEN_OVER_BUFFER;
>         }
672,673c535,538
< 	RETURN_BOOL(connected && client->fd > 0);
< }
---
>         if (nul == 1)
>         {
>             continue;
>         }
675,682c540,597
< static PHP_METHOD(swoole_mysql, setConnectTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &timeout))
< 	{
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
< 	}
---
>         int type = client->response.columns[i].type;
>         switch (type)
>         {
>         case MYSQL_TYPE_NULL:
>             add_assoc_null(row_array, client->response.columns[i].name);
>             break;
>         /* String */
>         case MYSQL_TYPE_TINY_BLOB:
>         case MYSQL_TYPE_MEDIUM_BLOB:
>         case MYSQL_TYPE_LONG_BLOB:
>         case MYSQL_TYPE_BLOB:
>         case MYSQL_TYPE_DECIMAL:
>         case MYSQL_TYPE_NEWDECIMAL:
>         case MYSQL_TYPE_BIT:
>         case MYSQL_TYPE_STRING:
>         case MYSQL_TYPE_VAR_STRING:
>         case MYSQL_TYPE_VARCHAR:
>         case MYSQL_TYPE_NEWDATE:
>         /* Date Time */
>         case MYSQL_TYPE_TIME:
>         case MYSQL_TYPE_YEAR:
>         case MYSQL_TYPE_TIMESTAMP:
>         case MYSQL_TYPE_DATETIME:
>         case MYSQL_TYPE_DATE:
>             sw_add_assoc_stringl(row_array, client->response.columns[i].name, buf + read_n, len, 1);
>             break;
>         /* Integer */
>         case MYSQL_TYPE_TINY:
>         case MYSQL_TYPE_SHORT:
>         case MYSQL_TYPE_INT24:
>         case MYSQL_TYPE_LONG:
> #ifdef SW_MYSQL_STRICT_TYPE
>             memcpy(value_buffer, buf + read_n, len);
>             value_buffer[len] = 0;
>             row.sint = strtol(value_buffer, &error, 10);
>             if (*error != '\0')
>             {
>                 return -SW_MYSQL_ERR_CONVLONG;
>             }
>             add_assoc_long(row_array, client->response.columns[i].name, row.sint);
> #else
>             sw_add_assoc_stringl(row_array, client->response.columns[i].name, buf + read_n, len, 1);
> #endif
>             break;
>         case MYSQL_TYPE_LONGLONG:
> #ifdef SW_MYSQL_STRICT_TYPE
>             memcpy(value_buffer, buf + read_n, len);
>             value_buffer[len] = 0;
>             row.sbigint = strtoll(value_buffer, &error, 10);
>             if (*error != '\0')
>             {
>                 return -SW_MYSQL_ERR_CONVLONG;
>             }
>             add_assoc_long(row_array, client->response.columns[i].name, row.sbigint);
> #else
>             sw_add_assoc_stringl(row_array, client->response.columns[i].name, buf + read_n, len, 1);
> #endif
>             break;
684,686c599,612
< 	zend_update_property_long(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connectTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE;
< }
---
>         case MYSQL_TYPE_FLOAT:
> #ifdef SW_MYSQL_STRICT_TYPE
>             memcpy(value_buffer, buf + read_n, len);
>             value_buffer[len] = 0;
>             row.mfloat = strtof(value_buffer, &error);
>             if (*error != '\0')
>             {
>                 return -SW_MYSQL_ERR_CONVFLOAT;
>             }
>             add_assoc_double(row_array, client->response.columns[i].name, row.mfloat);
> #else
>             sw_add_assoc_stringl(row_array, client->response.columns[i].name, buf + read_n, len, 1);
> #endif
>             break;
688,695c614,630
< static PHP_METHOD(swoole_mysql, setQueryTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &timeout))
< 	{
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
< 	}
---
>         case MYSQL_TYPE_DOUBLE:
> #ifdef SW_MYSQL_STRICT_TYPE
>             memcpy(value_buffer, buf + read_n, len);
>             value_buffer[len] = 0;
>             row.mdouble = strtod(value_buffer, &error);
>             if (*error != '\0')
>             {
>                 return -SW_MYSQL_ERR_CONVDOUBLE;
>             }
>             add_assoc_double(row_array, client->response.columns[i].name, row.mdouble);
> #else
>             sw_add_assoc_stringl(row_array, client->response.columns[i].name, buf + read_n, len, 1);
> #endif
>             break;
>         }
>         read_n += len;
>     }
697,698c632,633
< 	zend_update_property_long(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("queryTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE;
---
>     add_next_index_zval(result_array, row_array);
>     return read_n;
701c636
< static PHP_METHOD(swoole_mysql, close)
---
> static sw_inline int mysql_read_eof(mysql_client *client, char *buffer, int n_buf)
703,704c638,639
<     mysql_client *client = swoole_get_object(getThis());
<     if (!client || client->released)
---
>     //EOF, length (3byte) + id(1byte) + 0xFE + warning(2byte) + status(2byte)
>     if (n_buf < 9)
706c641,652
<         return;
---
>         client->response.wait_recv = 1;
>         return SW_ERR;
>     }
> 
>     client->response.packet_length = mysql_uint3korr(buffer);
>     client->response.packet_number = buffer[3];
> 
>     //not EOF packet
>     uint8_t eof = buffer[4];
>     if (eof != 0xfe)
>     {
>         return SW_ERR;
709,730c655,656
<     zval *internal_user = sw_zend_read_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	if (internal_user && Z_BVAL_P(internal_user))
< 	{
< 		return;
< 	}
< 
<     zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connected"), 0 TSRMLS_CC);
< 
<     client->released = 1;
<     if (client->fd > 0)
< 	{
< 		SwooleG.main_reactor->del(SwooleG.main_reactor, client->fd);
< 		swConnection *socket = swReactor_get(SwooleG.main_reactor, client->fd);
< 		socket->object = NULL;
< 		client->fd = -1;
< 	}
< 
< 	if (client->cli)
< 	{
< 		client->cli->close(client->cli);
< 		swoole_efree(client->cli);
< 	}
---
>     client->response.warnings = mysql_uint2korr(buffer + 5);
>     client->response.status_code = mysql_uint2korr(buffer + 7);
732,733c658
<     SwooleG.main_reactor->defer(SwooleG.main_reactor,defer_close,client);
<     RETURN_TRUE;
---
>     return SW_OK;
736c661
< static PHP_METHOD(swoole_mysql, query)
---
> static sw_inline int mysql_read_columns(mysql_client *client)
738,748c663,666
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || !client->cli || client->released)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	if (client->state != SW_MYSQL_STATE_QUERY)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "mysql client is waiting response, cannot send new sql query.");
< 		RETURN_FALSE;
< 	}
---
>     int i;
>     char *buffer = client->buffer->str + client->buffer->offset;
>     uint32_t n_buf = client->buffer->length - client->buffer->offset;
>     int ret;
750,754c668
<     swString sql;
<     bzero(&sql, sizeof(sql));
<     zval* callback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz",
<     					&sql.str, &sql.length, &callback))
---
>     for (i = client->response.packet_number - 1; i < client->response.num_column; i++)
756,757c670,673
<     	RETURN_FALSE;
<     }
---
>         client->response.packet_length = mysql_uint3korr(buffer);
>         client->response.packet_number = buffer[3];
>         buffer += 4;
>         n_buf -= 4;
759,762c675,692
<     if (sql.length <= 0 || !sql.str)
<     {
<         swoole_php_fatal_error(E_WARNING, "Query is empty.");
<         RETURN_FALSE;
---
>         //no enough data
>         if (n_buf < client->response.packet_length)
>         {
>             wait_recv: client->buffer->offset += buffer - (client->buffer->str + client->buffer->offset);
>             client->response.wait_recv = 1;
>             return SW_ERR;
>         }
> 
>         ret = mysql_decode_field(buffer, client->response.packet_length, &client->response.columns[i]);
>         if (ret > 0)
>         {
>             buffer += client->response.packet_length;
>             n_buf -= client->response.packet_length;
>         }
>         else
>         {
>             break;
>         }
765c695
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     if (mysql_read_eof(client, buffer, n_buf) < 0)
767c697
<     	RETURN_FALSE
---
>         goto wait_recv;
770,771c700,701
<     sw_zval_add_ref(&callback);
<     client->callback = sw_zval_dup(callback);
---
>     buffer += 9;
>     n_buf -= 9;
773c703,704
<     if (query_handler(client,getThis(),&sql) < 0)
---
>     zval *result_array = client->response.result_array;
>     if (!result_array)
775c706,708
<     	RETURN_FALSE;
---
>         SW_ALLOC_INIT_ZVAL(result_array);
>         array_init(result_array);
>         client->response.result_array = result_array;
776a710
>     client->buffer->offset += buffer - (client->buffer->str + client->buffer->offset);
778c712
<     RETURN_TRUE;
---
>     return SW_OK;
781c715
< static PHP_METHOD(swoole_mysql, safe_query)
---
> static sw_inline int mysql_read_rows(mysql_client *client)
783,822c717,719
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || !client->cli || client->released)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	if (client->state != SW_MYSQL_STATE_QUERY)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "mysql client is waiting response, cannot send new sql query.");
< 		RETURN_FALSE;
< 	}
< 
< 	swString sql;
< 	bzero(&sql, sizeof(sql));
< 	zval* input_params = NULL;
< 	zval* callback = NULL;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "saz",
< 						&sql.str, &sql.length, &input_params,&callback))
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	if (sql.length <= 0 || !sql.str)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "Query is empty.");
< 		RETURN_FALSE;
< 	}
< 
< 	if (swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
< 		RETURN_FALSE
< 	}
< 
< 	sw_zval_add_ref(&callback);
< 	client->callback = sw_zval_dup(callback);
< 
< 	struct mysql_bound_param_stmt stmt;
< 	memset(&stmt,0,sizeof(stmt));
< 	stmt.supports_placeholders = MYSQL_PLACEHOLDER_NONE;
< 	struct mysql_bound_param_data param;
---
>     char *buffer = client->buffer->str + client->buffer->offset;
>     uint32_t n_buf = client->buffer->length - client->buffer->offset;
>     int ret;
824,855c721,732
< #if PHP_MAJOR_VERSION < 7
< 	zval **tmp;
< 	uint str_len = 0;
< 	ulong num_index = 0;
< 
< 	zend_hash_internal_pointer_reset(Z_ARRVAL_P(input_params));
< 	while (zend_hash_get_current_data(Z_ARRVAL_P(input_params), (void*)&tmp) == SUCCESS)
< 	 {
< 		memset(&param, 0, sizeof(param));
< 
< 		if ( zend_hash_get_current_key_ex(Z_ARRVAL_P(input_params),&param.name, &str_len,
< 				&num_index, 0, NULL) == HASH_KEY_IS_STRING)
< 		 {
< 			param.name_len = str_len - 1;
< 			param.paramno = -1;
< 		}
< 		 else
< 		 {
< 			param.paramno = num_index;
< 		}
< 
< 		MAKE_STD_ZVAL(param.parameter);
< 		MAKE_COPY_ZVAL(tmp, param.parameter);
< 
< 		if (!really_register_bound_param(&param, &stmt))
< 		 {
< 			if (param.parameter)
< 			 {
< 				zval_ptr_dtor(&param.parameter);
< 			}
< 			RETURN_FALSE;
< 		}
---
>     //RecordSet parse
>     while (n_buf > 0)
>     {
>         if (n_buf < 4)
>         {
>             client->response.wait_recv = 1;
>             return SW_ERR;
>         }
>         else if (n_buf == 9 && mysql_read_eof(client, buffer, n_buf) == 0)
>         {
>             return SW_OK;
>         }
857c734,737
< 		zend_hash_move_forward(Z_ARRVAL_P(input_params));
---
>         client->response.packet_length = mysql_uint3korr(buffer);
>         client->response.packet_number = buffer[3];
>         buffer += 4;
>         n_buf -= 4;
859,907c739,751
< 	}
< #else
< 	zval *tmp = NULL;
< 	zend_string *key = NULL;
< 	zend_ulong num_index = 0;
< 
< 	ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(input_params), num_index, key, tmp)
< 	{
< 		memset(&param, 0, sizeof(param));
< 		if (key) {
< 			/* yes this is correct.  we don't want to count the null byte. */
< 			param.name = key;
< 			param.paramno = -1;
< 		} else {
< 			param.paramno = num_index;
< 		}
< 
< 		//param.param_type = MYSQL_PARAM_STR;
< 		ZVAL_COPY(&param.parameter, tmp);
< 
< 		if (!really_register_bound_param(&param, &stmt)) {
< 			if (!Z_ISUNDEF(param.parameter)) {
< 				zval_ptr_dtor(&param.parameter);
< 			}
< 
< 			RETURN_FALSE
< 		}
< 	}
< 	ZEND_HASH_FOREACH_END();
< #endif
< 	char *nsql = NULL;
< 	size_t nsql_len = 0;
< 	int ret = mysql_parse_params(stmt, sql.str, sql.length, &nsql, &nsql_len);
< 	if (ret == 1) {
< 		sql.str = nsql;
< 		sql.length = nsql_len;
< 	}
< 	else if(ret == -1) {
< 		/* failed to parse */
< 		RETURN_FALSE;
< 	}
< 
< 	ret = query_handler(client,getThis(),&sql);
< 	swoole_efree(nsql);
< 
< 	if (ret < 0)
< 	{
< 		RETURN_FALSE;
< 	}
---
>         //no enough data
>         if (n_buf < client->response.packet_length)
>         {
>             client->response.wait_recv = 1;
>             return SW_ERR;
>         }
> 
>         //decode
>         ret = mysql_decode_row(client, buffer, client->response.packet_length);
>         if (ret < 0)
>         {
>             break;
>         }
909c753,758
< 	RETURN_TRUE;
---
>         //next row
>         client->response.num_row++;
>         buffer += client->response.packet_length;
>         n_buf -= client->response.packet_length;
>         client->buffer->offset += client->response.packet_length + 4;
>     }
910a760
>     return SW_ERR;
913c763,766
< static PHP_METHOD(swoole_mysql, begin)
---
> static swString *mysql_request_buffer = NULL;
> static int isset_event_callback = 0;
> 
> void swoole_mysql_init(int module_number TSRMLS_DC)
915,920c768,769
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || !client->cli)
< 	{
< 		swWarn("please construct swoole_mysql first.and mysql connection must be active.");
< 		RETURN_FALSE;
< 	}
---
>     mysql_request_buffer = swString_new(65536);
> }
922,936c771,780
<     zval *callback = NULL;
<     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &callback) == FAILURE)
<     {
<     	RETURN_FALSE;
<     }
<     if(client->in_txn)
<     {
<         zend_throw_exception(zend_exception_get_default(), "There is already an active transaction", 0 TSRMLS_CC);
<         RETURN_FALSE;
<     }
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
<     {
<     	swWarn("callback is invailed.");
<     	RETURN_FALSE;
<     }
---
> static int mysql_request(swString *sql, swString *buffer)
> {
>     bzero(buffer->str, 5);
>     //length
>     mysql_pack_length(sql->length + 1, buffer->str);
>     //command
>     buffer->str[4] = SW_MYSQL_COM_QUERY;
>     buffer->length = 5;
>     return swString_append(buffer, sql);
> }
938,939c782,784
<     sw_zval_add_ref(&callback);
<     client->callback = sw_zval_dup(callback);
---
> static int mysql_response(mysql_client *client)
> {
>     swString *buffer = client->buffer;
941,944c786,789
<     swString sql;
<     bzero(&sql, sizeof(sql));
<     swString_append_ptr(&sql, ZEND_STRL("START TRANSACTION"));
<     swString_clear(mysql_request_buffer);
---
>     char *p = buffer->str + buffer->offset;
>     int ret;
>     char nul;
>     int n_buf = buffer->length - buffer->offset;
946,951c791
<     if (mysql_request(&sql, mysql_request_buffer) < 0)
<     {
<         RETURN_FALSE;
<     }
<     //send
<     if (SwooleG.main_reactor->write(SwooleG.main_reactor, client->fd, mysql_request_buffer->str, mysql_request_buffer->length) < 0)
---
>     while (n_buf > 0)
953,954c793
<         //connection is closed
<         if (swConnection_error(errno) == SW_CLOSE)
---
>         switch (client->state)
956,967c795,804
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connected"), 0 TSRMLS_CC);
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("errno"), 2006 TSRMLS_CC);
<         }
<         RETURN_FALSE;
<     }
<     else
<     {
<         client->state = SW_MYSQL_STATE_READ_START;
<         client->in_txn = 1;
<         RETURN_TRUE;
<     }
< }
---
>         case SW_MYSQL_STATE_READ_START:
>             if (buffer->length - buffer->offset < 5)
>             {
>                 client->response.wait_recv = 1;
>                 return SW_ERR;
>             }
>             client->response.packet_length = mysql_uint3korr(p);
>             client->response.packet_number = p[3];
>             p += 4;
>             n_buf -= 4;
969,976c806,810
< static PHP_METHOD(swoole_mysql, commit)
< {
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || !client->cli)
< 	{
< 		swWarn("please construct swoole_mysql first.and mysql connection must be active.");
< 		RETURN_FALSE;
< 	}
---
>             if (n_buf < client->response.packet_length)
>             {
>                 client->response.wait_recv = 1;
>                 return SW_ERR;
>             }
978,982c812,814
<     zval *callback = NULL;
<     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &callback) == FAILURE)
<     {
<     	RETURN_FALSE;
<     }
---
>             client->response.response_type = p[0];
>             p ++;
>             n_buf --;
984,988c816,850
<     if(!client->in_txn)
<     {
<         zend_throw_exception(zend_exception_get_default(), "There is no active transaction", 0 TSRMLS_CC);
<         RETURN_FALSE;
<     }
---
>             /* error */
>             if (client->response.response_type == 0xFF)
>             {
>                 client->response.error_code = mysql_uint2korr(p);
>                 /* status flag 1byte (#), skip.. */
>                 memcpy(client->response.status_msg, p + 3, 5);
>                 client->response.server_msg = p + 8;
>                 client->state = SW_MYSQL_STATE_READ_END;
>                 return SW_OK;
>             }
>             /* eof */
>             else if (client->response.response_type == 254)
>             {
>                 client->response.warnings = mysql_uint2korr(p);
>                 client->response.status_code = mysql_uint2korr(p + 2);
>                 client->state = SW_MYSQL_STATE_READ_END;
>                 return SW_ERR;
>             }
>             /* ok */
>             else if (client->response.response_type == 0)
>             {
>                 /* affected rows */
>                 ret = mysql_length_coded_binary(p, (ulong_t *) &client->response.affected_rows, &nul, n_buf);
>                 n_buf -= ret;
>                 p += ret;
> 
>                 /* insert id */
>                 ret = mysql_length_coded_binary(p, (ulong_t *) &client->response.insert_id, &nul, n_buf);
>                 n_buf -= ret;
>                 p += ret;
> 
>                 /* server status */
>                 client->response.status_code = mysql_uint2korr(p);
>                 n_buf -= 2;
>                 p += 2;
990,994c852,853
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
<     {
<     	swWarn("callback is invailed.");
<     	RETURN_FALSE;
<     }
---
>                 /* server warnings */
>                 client->response.warnings = mysql_uint2korr(p);
996,997c855,866
<     sw_zval_add_ref(&callback);
<     client->callback = sw_zval_dup(callback);
---
>                 client->state = SW_MYSQL_STATE_READ_END;
>                 return SW_OK;
>             }
>             /* result set */
>             else
>             {
>                 client->buffer->offset += 5;
>                 client->response.num_column = client->response.response_type;
>                 client->response.columns = ecalloc(client->response.num_column, sizeof(mysql_field));
>                 client->state = SW_MYSQL_STATE_READ_FIELD;
>                 break;
>             }
999,1001c868,877
<     swString sql;
<     bzero(&sql, sizeof(sql));
<     swString_append_ptr(&sql, ZEND_STRL("COMMIT"));
---
>         case SW_MYSQL_STATE_READ_FIELD:
>             if (mysql_read_columns(client) < 0)
>             {
>                 return SW_ERR;
>             }
>             else
>             {
>                 client->state = SW_MYSQL_STATE_READ_ROW;
>                 break;
>             }
1003,1014c879,891
<     if (mysql_request(&sql, mysql_request_buffer) < 0)
<     {
<         RETURN_FALSE;
<     }
<     //send
<     if (SwooleG.main_reactor->write(SwooleG.main_reactor, client->fd, mysql_request_buffer->str, mysql_request_buffer->length) < 0)
<     {
<         //connection is closed
<         if (swConnection_error(errno) == SW_CLOSE)
<         {
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connected"), 0 TSRMLS_CC);
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("errno"), 2006 TSRMLS_CC);
---
>         case SW_MYSQL_STATE_READ_ROW:
>             if (mysql_read_rows(client) < 0)
>             {
>                 return SW_ERR;
>             }
>             else
>             {
>                 client->state = SW_MYSQL_STATE_READ_END;
>                 return SW_OK;
>             }
> 
>         default:
>             return SW_ERR;
1016,1022d892
<         RETURN_FALSE;
<     }
<     else
<     {
<         client->state = SW_MYSQL_STATE_READ_START;
<         client->in_txn = 0;
<         RETURN_TRUE;
1024a895
>     return SW_OK;
1026,1033d896
< static PHP_METHOD(swoole_mysql, rollback)
< {
< 	mysql_client *client = swoole_get_object(getThis());
< 	if (!client || !client->cli)
< 	{
< 		swWarn("please construct swoole_mysql first.and mysql connection must be active.");
< 		RETURN_FALSE;
< 	}
1035,1052c898
<     zval *callback = NULL;
<     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &callback) == FAILURE)
<     {
<     	RETURN_FALSE;
<     }
<     if(!client->in_txn)
<     {
<         zend_throw_exception(zend_exception_get_default(), "There is no active transaction", 0 TSRMLS_CC);
<         RETURN_FALSE;
<     }
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
<     {
<     	swWarn("callback is invailed.");
<     	RETURN_FALSE;
<     }
< 
<     sw_zval_add_ref(&callback);
<     client->callback = sw_zval_dup(callback);
---
> #ifdef SW_MYSQL_DEBUG
1054,1056c900,909
<     swString sql;
<     bzero(&sql, sizeof(sql));
<     swString_append_ptr(&sql, ZEND_STRL("ROLLBACK"));
---
> static void mysql_client_info(mysql_client *client)
> {
>     printf("\n"SW_START_LINE"\nmysql_client\nbuffer->offset=%ld\nbuffer->length=%ld\nstatus=%d\n"
>             "packet_length=%d\npacket_number=%d\n"
>             "insert_id=%d\naffected_rows=%d\n"
>             "warnings=%d\n"SW_END_LINE, client->buffer->offset, client->buffer->length, client->response.status_code,
>             client->response.packet_length, client->response.packet_number,
>             client->response.insert_id, client->response.affected_rows,
>             client->response.warnings);
>     int i;
1058,1064c911
<     //client->state = SW_MYSQL_STATE_ROLLBACK;
<     if (mysql_request(&sql, mysql_request_buffer) < 0)
<     {
<         RETURN_FALSE;
<     }
<     //send
<     if (SwooleG.main_reactor->write(SwooleG.main_reactor, client->fd, mysql_request_buffer->str, mysql_request_buffer->length) < 0)
---
>     if (client->response.num_column)
1066,1067c913
<         //connection is closed
<         if (swConnection_error(errno) == SW_CLOSE)
---
>         for (i = 0; i < client->response.num_column; i++)
1069,1070c915
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("connected"), 0 TSRMLS_CC);
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("errno"), 2006 TSRMLS_CC);
---
>             mysql_column_info(&client->response.columns[i]);
1072,1078d916
<         RETURN_FALSE;
<     }
<     else
<     {
<         client->state = SW_MYSQL_STATE_READ_START;
<         client->in_txn = 0;
<         RETURN_TRUE;
1082c920
< static PHP_METHOD(swoole_mysql, isUsedindex)
---
> static void mysql_column_info(mysql_field *field)
1084,1093c922,930
<     mysql_client *client = swoole_get_object(getThis());
<     if (!client || !client->cli)
<     {
<         swWarn("please construct swoole_mysql first.and mysql connection must be active.");
<         RETURN_FALSE;
<     }
<     zval *status_code = sw_zend_read_property(swoole_mysql_class_entry_ptr, getThis(), ZEND_STRL("status_code"), 0 TSRMLS_CC);
<     long status_value = Z_LVAL_P(status_code);
<     RETURN_BOOL(!(status_value & SERVER_QUERY_NO_INDEX_USED) &&
<     			!(status_value & SERVER_QUERY_NO_GOOD_INDEX_USED));
---
>     printf("\n"SW_START_LINE"\nname=%s, table=%s, db=%s\n"
>             "name_length=%d, table_length=%d, db_length=%d\n"
>             "catalog=%s, default_value=%s\n"
>             "length=%ld, type=%d\n"SW_END_LINE,
>             field->name, field->table, field->db,
>             field->name_length, field->table_length, field->db_length,
>             field->catalog, field->def,
>             field->length, field->type
>            );
1096,1172d932
< static int really_register_bound_param(struct mysql_bound_param_data *param, struct mysql_bound_param_stmt *stmt)
< {
< 	struct mysql_bound_param_data *pparam = NULL;
< 	HashTable *hash = stmt->bound_params;
< 	if (!hash)
<     {
< 		ALLOC_HASHTABLE(hash);
< 		zend_hash_init(hash, 13, NULL, NULL, 0);  //param_dtor
<         stmt->bound_params = hash;
< 	}
< 
< #if PHP_MAJOR_VERSION < 7
< 	convert_to_string(param->parameter);
< 
<  	if (param->name)
<      {
<  		if (param->name[0] != ':')
<          {
<  			char *temp = emalloc(++param->name_len + 1);
<  			temp[0] = ':';
<  			memmove(temp + 1, param->name, param->name_len + 1);
<  			param->name = temp;
<  		}
< 		else
< 		{
< 			param->name = estrndup(param->name, param->name_len);
< 		}
<  	}
< 
<  	/* delete any other parameter registered with this number.
<  	 * If the parameter is named, it will be removed and correctly
<  	 * disposed of by the hash_update call that follows */
< 	if (param->paramno >= 0)
< 	{
< 		zend_hash_index_del(hash, param->paramno);
< 	}
< 
<  	/* allocate storage for the parameter, keyed by its "canonical" name */
< 	if (param->name)
< 	{
< 		zend_hash_update(hash, param->name, param->name_len, param, sizeof(*param), (void**)&pparam);
< 	}
< 	else
< 	{
< 		zend_hash_index_update(hash, param->paramno, param, sizeof(*param), (void**)&pparam);
< 	}
< 
<  #else
< 	zval *parameter = Z_ISREF(param->parameter)? Z_REFVAL(param->parameter):&param->parameter;
< 	convert_to_string(parameter);
< 
< 	if (param->name)
< 	{
< 		if (ZSTR_VAL(param->name)[0] != ':')
< 		{
< 			zend_string *temp = zend_string_alloc(ZSTR_LEN(param->name) + 1, 0);
< 			ZSTR_VAL(temp)[0] = ':';
< 			memmove(ZSTR_VAL(temp) + 1, ZSTR_VAL(param->name), ZSTR_LEN(param->name) + 1);
< 			param->name = temp;
< 		}
< 		else
< 		{
< 			param->name = zend_string_init(ZSTR_VAL(param->name), ZSTR_LEN(param->name), 0);
< 		}
< 	}
< 
< 	/* delete any other parameter registered with this number.
< 	 * If the parameter is named, it will be removed and correctly
< 	 * disposed of by the hash_update call that follows */
< 	if (param->paramno >= 0)
< 	{
< 		zend_hash_index_del(hash, param->paramno);
< 	}
< 
< 	/* allocate storage for the parameter, keyed by its "canonical" name */
< 	pparam = (param->name)? zend_hash_update_mem(hash, param->name, param, sizeof(struct mysql_bound_param_data)):
< 			zend_hash_index_update_mem(hash, param->paramno, param, sizeof(struct mysql_bound_param_data));
1174,1175d933
< 	return 1;
< }
1177c935
< static int swoole_mysql_onError(swReactor *reactor, swEvent *event)
---
> PHP_FUNCTION(swoole_get_mysqli_sock)
1179,1180c937,938
< 
<     if (event->socket->active)
---
>     zval *mysql_link;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &mysql_link) == FAILURE)
1182,1189c940,941
<         SWOOLE_FETCH_TSRMLS;
<         mysql_client *client = event->socket->object;
<         if (!client)
<         {
< //            close(event->fd);
<         	reactor->close(reactor, event->fd);
<             return SW_ERR;
<         }
---
>         return;
>     }
1191,1198c943,948
<         if (client->cli && client->cli->timer_id > 0)
<         {
< 			long timer_id = client->cli->timer_id;
< 			client->cli->timer_id = 0;
< 			swTimer_del(&SwooleG.timer,timer_id);
<         }
<         mysql_close(client);
<         return SW_OK;
---
>     int sock = -1;
>     mysql_get_socket(mysql_link, return_value, &sock TSRMLS_CC);
> 
>     if (sock <= 0)
>     {
>         RETURN_FALSE;
1202c952
<         return swoole_mysql_onWrite(reactor, event);
---
>         RETURN_LONG(sock);
1206c956
< static void swoole_mysql_onConnect(mysql_client *client TSRMLS_DC)
---
> PHP_FUNCTION(swoole_mysql_query)
1208,1215c958,963
<     if (client->cli && client->cli->timer_id > 0)
< 	{
< 		long timer_id = client->cli->timer_id;
< 		client->cli->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
<     zval *zobject = client->object;
<     if (!zobject)
---
>     zval *mysql_link;
>     zval *callback;
>     swString sql;
>     bzero(&sql, sizeof(sql));
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zsz", &mysql_link, &sql.str, &sql.length, &callback) == FAILURE)
1217c965
<     	return;
---
>         return;
1220,1222c968
<     zval *callback = client->onConnect;
<     client->onConnect = NULL;
<     if (client->connector.error_code > 0)
---
>     if (sql.length <= 0)
1224,1225c970,971
<     	zend_update_property_stringl(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("connect_error"), client->connector.error_msg, client->connector.error_length TSRMLS_CC);
<     	zend_update_property_long(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("connect_errno"), client->connector.error_code TSRMLS_CC);
---
>         swoole_php_fatal_error(E_WARNING, "Query is empty.");
>         RETURN_FALSE;
1228c974,979
<     zend_update_property_bool(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("connected"), client->connector.error_code > 0? 0:1 TSRMLS_CC);
---
>     int sock = -1;
>     mysql_get_socket(mysql_link, return_value, &sock TSRMLS_CC);
>     if (sock <= 0)
>     {
>         RETURN_FALSE;
>     }
1230,1258c981,987
<     zval *retval = NULL;
<     sw_zval_add_ref(&zobject);
<     if (callback && !ZVAL_IS_NULL(callback)){
<     	zval *result;
< 		zval **args[2];
<     	SW_MAKE_STD_ZVAL(result);
<     	ZVAL_BOOL(result, client->connector.error_code > 0? 0:1);
< 		args[0] = &zobject;
< 		args[1] = &result;
<     	if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
< 		{
< 			swoole_php_fatal_error(E_WARNING, "swoole_mysql onConnect handler error.");
< 		}
< 		if (EG(exception))
< 		{
< 			zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 		}
< 		if (retval != NULL)
< 		{
< 			sw_zval_ptr_dtor(&retval);
< 		}
< 		sw_zval_ptr_dtor(&result);
<     }
< 
<     if (client->connector.error_code > 0)
< 	{
< 		//close
< 		mysql_close(client);
< 	}
---
>     mysql_client *client = swoole_get_object(mysql_link);
>     if (!client)
>     {
>         client = emalloc(sizeof(mysql_client));
>         bzero(client, sizeof(mysql_client));
>         client->buffer = swString_new(SW_BUFFER_SIZE_BIG);
>         swoole_set_object(mysql_link, client);
1260,1262c989,990
<     if (callback) sw_zval_free(callback);
<     sw_zval_ptr_dtor(&zobject);
< }
---
>         php_swoole_check_reactor();
>         swSetNonBlock(sock);
1264,1266c992,993
< static int swoole_mysql_onWrite(swReactor *reactor, swEvent *event)
< {
<     SWOOLE_FETCH_TSRMLS;
---
>         zend_class_entry *class_entry = zend_get_class_entry(mysql_link TSRMLS_CC);
>         zend_update_property_bool(class_entry, mysql_link, ZEND_STRL("_connected"), 1 TSRMLS_CC);
1268,1272c995
<     mysql_client *client = event->socket->object;
<     if (event->socket->active)
<     {
<     	int iRet = swReactor_onWrite(SwooleG.main_reactor, event);
<         if (iRet != SW_OK && client)
---
>         if (!isset_event_callback)
1274,1281c997
< 			client->fd = -1;
< 			if (client->cli && client->cli->socket)
< 			{
< 				client->cli->socket->closed = 1;
< 				client->cli->socket->removed = 1;
< 			}
< 
< 			mysql_close(client);
---
>             SwooleG.main_reactor->setHandle(SwooleG.main_reactor, PHP_SWOOLE_FD_MYSQL | SW_EVENT_READ, swoole_mysql_onRead);
1283,1301c999,1007
< 
<         return SW_OK;
<     }
< 
<     socklen_t len = sizeof(SwooleG.error);
<     if (getsockopt(event->fd, SOL_SOCKET, SO_ERROR, &SwooleG.error, &len) < 0)
<     {
<         swWarn("getsockopt(%d) failed. Error: %s[%d]", event->fd, strerror(errno), errno);
<         return SW_ERR;
<     }
< 
<     //success
<     if (SwooleG.error == 0)
<     {
<         //listen read event
<         SwooleG.main_reactor->set(SwooleG.main_reactor, event->fd, PHP_SWOOLE_FD_MYSQL | SW_EVENT_READ);
<         //connected
<         event->socket->active = 1;
<         client->handshake = SW_MYSQL_HANDSHAKE_WAIT_REQUEST;
---
>         swConnection *socket = swReactor_get(SwooleG.main_reactor, sock);
>         socket->active = 1;
> #if PHP_MAJOR_VERSION >= 7
>         zval *new_zval = emalloc(sizeof(zval));
>         ZVAL_COPY(new_zval, mysql_link);
>         socket->object = new_zval;
> #else
>         socket->object = mysql_link;
> #endif
1303c1009
<     else
---
>     else if (client->state != SW_MYSQL_STATE_QUERY)
1305,1308c1011,1012
<         client->connector.error_code = SwooleG.error;
<         client->connector.error_msg = strerror(SwooleG.error);
<         client->connector.error_length = strlen(client->connector.error_msg);
<         swoole_mysql_onConnect(client TSRMLS_CC);
---
>         swoole_php_fatal_error(E_WARNING, "mysql client is waiting response, cannot send new sql query.");
>         RETURN_FALSE;
1311,1312c1015,1016
<     return SW_OK;
< }
---
>     client->callback = callback;
>     sw_copy_to_stack(client->callback, client->_callback);
1314,1318c1018,1019
< static int swoole_mysql_onHandShake(mysql_client *client TSRMLS_DC)
< {
<     swString *buffer = client->buffer;
<     swClient *cli = client->cli;
<     mysql_connector *connector = &client->connector;
---
>     sw_zval_add_ref(&client->callback);
>     swString_clear(mysql_request_buffer);
1320,1321c1021
<     int n = cli->recv(cli, buffer->str + buffer->length, buffer->size - buffer->length, 0);
<     if (n < 0)
---
>     if (mysql_request(&sql, mysql_request_buffer) < 0)
1323,1334c1023
<         switch (swConnection_error(errno))
<         {
<         case SW_ERROR:
<             swSysError("Read from socket[%d] failed.", cli->socket->fd);
<             return SW_ERR;
<         case SW_CLOSE:
<             goto system_call_error;
<         case SW_WAIT:
<             return SW_OK;
<         default:
<             return SW_ERR;
<         }
---
>         RETURN_FALSE;
1336c1025,1026
<     else if (n == 0)
---
>     //add to eventloop
>     if (SwooleG.main_reactor->add(SwooleG.main_reactor, sock, PHP_SWOOLE_FD_MYSQL | SW_EVENT_READ) < 0)
1338,1339c1028,1029
<         errno = ECONNRESET;
<         goto system_call_error;
---
>         swoole_php_fatal_error(E_WARNING, "swoole_event_add failed.");
>         RETURN_FALSE;
1341,1345c1031,1032
< 
<     buffer->length += n;
< 
<     int ret;
<     if (client->handshake == SW_MYSQL_HANDSHAKE_WAIT_REQUEST)
---
>     //send query
>     if (SwooleG.main_reactor->write(SwooleG.main_reactor, sock, mysql_request_buffer->str, mysql_request_buffer->length) < 0)
1347,1348c1034,1035
<         ret = mysql_handshake(connector, buffer->str, buffer->length);
<         if (ret < 0)
---
>         //connection is closed
>         if (swConnection_error(errno) == SW_CLOSE)
1350,1366c1037,1040
<             swoole_mysql_onConnect(client TSRMLS_CC);
<         }
<         else if (ret > 0)
<         {
<             if (cli->send(cli, connector->buf, connector->packet_length + 4, 0) < 0)
<             {
<                 system_call_error: connector->error_code = errno;
<                 connector->error_msg = strerror(errno);
<                 connector->error_length = strlen(connector->error_msg);
<                 swoole_mysql_onConnect(client TSRMLS_CC);
<                 return SW_OK;
<             }
<             else
<             {
<                 swString_clear(buffer);
<                 client->handshake = SW_MYSQL_HANDSHAKE_WAIT_RESULT;
<             }
---
>             zend_class_entry *class_entry = zend_get_class_entry(mysql_link TSRMLS_CC);
>             zend_update_property_bool(class_entry, mysql_link, ZEND_STRL("_connected"), 0 TSRMLS_CC);
>             zend_update_property_bool(class_entry, mysql_link, ZEND_STRL("_errno"), 2006 TSRMLS_CC);
>             swoole_set_object(mysql_link, NULL);
1367a1042
>         RETURN_FALSE;
1371,1382c1046,1047
<         ret = mysql_get_result(connector, buffer->str, buffer->length);
<         if (ret < 0)
<         {
<             swoole_mysql_onConnect(client TSRMLS_CC);
<         }
<         else if (ret > 0)
<         {
<             swString_clear(buffer);
<             client->handshake = SW_MYSQL_HANDSHAKE_COMPLETED;
<             client->state = SW_MYSQL_STATE_QUERY;
<             swoole_mysql_onConnect(client TSRMLS_CC);
<         }
---
>         client->state = SW_MYSQL_STATE_READ_START;
>         RETURN_TRUE;
1384d1048
<     return SW_OK;
1389,1395c1053,1055
<     SWOOLE_FETCH_TSRMLS;
< 
<     mysql_client *client = event->socket->object;
<     if (client->handshake != SW_MYSQL_HANDSHAKE_COMPLETED)
<     {
<         return swoole_mysql_onHandShake(client TSRMLS_CC);
<     }
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
1397,1402c1057
<     if (client->cli && client->cli->timer_id > 0)
<     {
<     	long timer_id = client->cli->timer_id;
<     	client->cli->timer_id = 0;
<     	swTimer_del(&SwooleG.timer,timer_id);
<     }
---
>     zval *mysql_link = event->socket->object;
1404d1058
<     int ret;
1406c1060
<     zval *zobject = client->object;
---
>     mysql_client *client = swoole_get_object(mysql_link);
1407a1062,1068
>     int ret;
> 
>     zval **args[2];
> 
>     zval *callback = NULL;
>     zval *retval = NULL;
>     zval *result = NULL;
1442c1103,1133
<             mysql_close(client);
---
>             swoole_set_object(mysql_link, NULL);
>             reactor->del(reactor, event->fd);
>             zend_class_entry *class_entry = zend_get_class_entry(mysql_link TSRMLS_CC);
>             zend_update_property_bool(class_entry, mysql_link, ZEND_STRL("_connected"), 0 TSRMLS_CC);
> 
>             if (client->callback)
>             {
>                 args[0] = &mysql_link;
>                 args[1] = &result;
> 
>                 SW_ALLOC_INIT_ZVAL(result);
>                 ZVAL_BOOL(result, 0);
> 
>                 callback = client->callback;
>                 if (sw_call_user_function_ex(EG(function_table), NULL, client->callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
>                 {
>                     swoole_php_fatal_error(E_WARNING, "swoole_async_mysql callback[2] handler error.");
>                 }
>                 if (retval)
>                 {
>                     sw_zval_ptr_dtor(&retval);
>                 }
>                 if (result)
>                 {
>                     sw_zval_ptr_dtor(&result);
>                 }
>                 sw_zval_ptr_dtor(&callback);
>                 client->callback = NULL;
>                 client->state = SW_MYSQL_STATE_QUERY;
>             }
> 
1454,1458c1145
<                     reactor->del(reactor, event->fd);
<                     swConnection *socket = swReactor_get(reactor, client->fd);
<                     socket->object = NULL;
<                     client->fd = -1;
<                     return SW_ERR;
---
>                     reactor->del(SwooleG.main_reactor, event->fd);
1469,1471c1156,1167
<             zend_update_property_long(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("affected_rows"), client->response.affected_rows TSRMLS_CC);
<             zend_update_property_long(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("insert_id"), client->response.insert_id TSRMLS_CC);
<             if (swoole_mysql_onQuery(client TSRMLS_CC) < 0)
---
>             //remove from eventloop
>             reactor->del(reactor, event->fd);
> 
>             zend_class_entry *class_entry = zend_get_class_entry(mysql_link TSRMLS_CC);
>             zend_update_property_long(class_entry, mysql_link, ZEND_STRL("_affected_rows"), client->response.affected_rows TSRMLS_CC);
>             zend_update_property_long(class_entry, mysql_link, ZEND_STRL("_insert_id"), client->response.insert_id TSRMLS_CC);
>             client->state = SW_MYSQL_STATE_QUERY;
> 
>             args[0] = &mysql_link;
> 
>             //OK
>             if (client->response.response_type == 0)
1473c1169,1170
<             	reactor->del(SwooleG.main_reactor, event->fd);
---
>                 SW_ALLOC_INIT_ZVAL(result);
>                 ZVAL_BOOL(result, 1);
1475,1477c1172,1176
<             return SW_OK;
<         }
<     }
---
>             //ERROR
>             else if (client->response.response_type == 255)
>             {
>                 SW_ALLOC_INIT_ZVAL(result);
>                 ZVAL_BOOL(result, 0);
1479,1480c1178,1185
<     return SW_OK;
< }
---
>                 zend_update_property_string(class_entry, mysql_link, ZEND_STRL("_error"), client->response.server_msg TSRMLS_CC);
>                 zend_update_property_long(class_entry, mysql_link, ZEND_STRL("_errno"), client->response.error_code TSRMLS_CC);
>             }
>             //ResultSet
>             else
>             {
>                 result = client->response.result_array;
>             }
1482,1538c1187,1193
< static int swoole_mysql_onQuery(mysql_client *client TSRMLS_DC)
< {
< 	zval **args[2];
< 	zval *callback = NULL;
< 	zval *retval = NULL;
< 	zval *result = NULL;
< 
< 	int iRet = SW_OK;
< 	client->state = SW_MYSQL_STATE_QUERY;
< 	zval *zobject = client->object;
< 	args[0] = &zobject;
< 
< 	//OK
< 	if (client->response.response_type == 0 || client->response.response_type == 0xfe)
< 	{
< 		SW_ALLOC_INIT_ZVAL(result);
< 		ZVAL_BOOL(result, 1);
< 	}
< 	//ERROR
< 	else if (client->response.response_type == 255)
< 	{
< 		SW_ALLOC_INIT_ZVAL(result);
< 		ZVAL_BOOL(result, 0);
< 
< 		zend_update_property_stringl(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("error"), client->response.server_msg, client->response.l_server_msg TSRMLS_CC);
< 		zend_update_property_long(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("errno"), client->response.error_code TSRMLS_CC);
< 	}
< 	//ResultSet
< 	else
< 	{
< 		result = client->response.result_array;
< 		client->response.result_array = NULL;
< 	}
< 
< 	args[1] = &result;
< 	callback = client->callback;
< 	client->callback = NULL;
< 	swString_clear(client->buffer);
< 	bzero(&client->response, sizeof(client->response));
< 	if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
< 	{
< 		swoole_php_fatal_error(E_WARNING, "swoole_async_mysql callback[2] handler error.");
< 		swReactor_del(SwooleG.main_reactor, client->fd);
< 		swConnection *socket = swReactor_get(SwooleG.main_reactor, client->fd);
< 		socket->object = NULL;
< 		client->fd = -1;
< 	}
< 
< 	/* free memory */
< 	if (retval)
< 	{
< 		sw_zval_ptr_dtor(&retval);
< 	}
< 	if (result)
< 	{
<         sw_zval_free(result);
< 	}
---
>             args[1] = &result;
>             callback = client->callback;
>             if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
>             {
>                 swoole_php_fatal_error(E_WARNING, "swoole_async_mysql callback[2] handler error.");
>                 reactor->del(SwooleG.main_reactor, event->fd);
>             }
1539a1195,1203
>             /* free memory */
>             if (retval)
>             {
>                 sw_zval_ptr_dtor(&retval);
>             }
>             if (result)
>             {
>                 sw_zval_ptr_dtor(&result);
>             }
1541,1567c1205,1213
<     if (callback)   sw_zval_free(callback);
< //            swConnection *_socket = swReactor_get(SwooleG.main_reactor, event->fd);
< //            if (_socket->object)
< //            {
< //                //clear buffer
< //                swString_clear(client->buffer);
< //                bzero(&client->response, sizeof(client->response));
< //            }
< 
< 	return iRet;
< }
< 
< static int query_handler(mysql_client *client,zval* zobject,swString* sql)
< {
<     swString_clear(mysql_request_buffer);
<     if (mysql_request(sql, mysql_request_buffer) < 0)
<     {
<         return SW_ERR;
<     }
<     //send query
<     if (SwooleG.main_reactor->write(SwooleG.main_reactor, client->fd, mysql_request_buffer->str, mysql_request_buffer->length) < 0)
<     {
<         //connection is closed
<         if (swConnection_error(errno) == SW_CLOSE)
<         {
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("connected"), 0 TSRMLS_CC);
<             zend_update_property_bool(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("errno"), 2006 TSRMLS_CC);
---
>             sw_zval_ptr_dtor(&callback);
>             //clear buffer
>             swString_clear(client->buffer);
>             if (client->response.columns)
>             {
>                 efree(client->response.columns);
>             }
>             bzero(&client->response, sizeof(client->response));
>             return SW_OK;
1569,1599d1214
< 
<         return SW_ERR;
<     }
<     else
<     {
< 		long timeout = 0;
< 		zval* queryTimeout = sw_zend_read_property(swoole_mysql_class_entry_ptr,zobject, ZEND_STRL("queryTimeout"), 1 TSRMLS_CC);
< 		if (queryTimeout)
< 		{
< 			convert_to_long(queryTimeout);
< 			timeout = Z_LVAL_P(queryTimeout);
< 		}
< 
< 		if (client->cli && timeout > 0)
< 		{
< 			client->cli->timer_id = 0;
< 			client->cli->timer_id = swTimer_add(&SwooleG.timer,timeout,0,client,MYSQL_USED);
< 			if (client->cli->timer_id <= 0)
< 			{
< 				zend_update_property_bool(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("connected"), 0 TSRMLS_CC);
< 				zend_update_property_bool(swoole_mysql_class_entry_ptr, zobject, ZEND_STRL("errno"), 2007 TSRMLS_CC);
< 				swWarn("set recv msg time out timer failed.");
< 				return SW_ERR;
< 			}
< 
< 			client->cli->timeout_type = SW_CLIENT_RECV_TIMEOUT;
< 			register_after_cb(&SwooleG.timer,MYSQL_USED,mysql_Client_timeout);
< 		}
< 
<         client->state = SW_MYSQL_STATE_READ_START;
<         return SW_OK;
1600a1216
>     return SW_OK;
1603,1648d1218
< #ifdef SW_USE_MYSQLND
< static PHP_METHOD(swoole_mysql, escape)
< {
<     swString str;
<     bzero(&str, sizeof(str));
<     long flags;
< 
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &str.str, &str.length, &flags))
<     {
<         return;
<     }
< 
<     if (str.length <= 0)
<     {
<         swoole_php_fatal_error(E_WARNING, "String is empty.");
<         RETURN_FALSE;
<     }
< 
<     mysql_client *client = swoole_get_object(getThis());
<     if (!client)
<     {
<         swoole_php_fatal_error(E_WARNING, "object is not instanceof swoole_mysql.");
<         RETURN_FALSE;
<     }
<     if (!client->cli)
<     {
<         swoole_php_fatal_error(E_WARNING, "mysql connection#%d is closed.", client->fd);
<         RETURN_FALSE;
<     }
< 
<     char *newstr = safe_emalloc(2, str.length + 1, 1);
<     if (newstr == NULL)
<     {
<         swoole_php_fatal_error(E_ERROR, "emalloc(%ld) failed.", str.length + 1);
<         RETURN_FALSE;
<     }
< 
<     const MYSQLND_CHARSET* cset = mysqlnd_find_charset_nr(client->connector.character_set);
<     int newstr_len = mysqlnd_cset_escape_slashes(cset, newstr, str.str, str.length TSRMLS_CC);
<     if (newstr_len < 0)
<     {
<         swoole_php_fatal_error(E_ERROR, "mysqlnd_cset_escape_slashes() failed.");
<         RETURN_FALSE;
<     }
<     SW_RETURN_STRINGL(newstr, newstr_len, 0);
< }
Only in ./zan-extension/: swoole_mysql.h
Only in ./zan-extension/: swoole_nova.c
diff -r ./zan-extension/swoole_process.c ../swoole-1.8.5-stable/swoole_process.c
18,19d17
< #include "swSignal.h"
< #include "swBaseOperator.h"
32a31
> #ifdef HAVE_CPU_AFFINITY
33a33
> #endif
45d44
< 
49,114d47
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_construct, 0, 0, 1)
<     ZEND_ARG_INFO(0, callback)
<     ZEND_ARG_INFO(0, redirect_stdin_and_stdout)
<     ZEND_ARG_INFO(0, pipe_type)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_wait, 0, 0, 0)
<     ZEND_ARG_INFO(0, blocking)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_signal, 0, 0, 2)
<     ZEND_ARG_INFO(0, signo)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_kill, 0, 0, 1)
<     ZEND_ARG_INFO(0, pid)
<     ZEND_ARG_INFO(0, sig)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_daemon, 0, 0, 0)
<     ZEND_ARG_INFO(0, nochdir)
<     ZEND_ARG_INFO(0, noclose)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_setaffinity, 0, 0, 1)
<     ZEND_ARG_ARRAY_INFO(0, cpu_set, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_useQueue, 0, 0, 1)
<     ZEND_ARG_INFO(0, msgkey)
<     ZEND_ARG_INFO(0, mode)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_write, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_read, 0, 0, 0)
<     ZEND_ARG_INFO(0, buf_size)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_push, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_pop, 0, 0, 0)
<     ZEND_ARG_INFO(0, maxsize)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_exit, 0, 0, 0)
<     ZEND_ARG_INFO(0, ret_code)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_exec, 0, 0, 2)
<     ZEND_ARG_INFO(0, execfile)
<     ZEND_ARG_INFO(0, args)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_process_name, 0, 0, 1)
<     ZEND_ARG_INFO(0, process_name)
< ZEND_END_ARG_INFO()
< 
117,134c50,69
<     PHP_ME(swoole_process, __construct, arginfo_swoole_process_construct, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_process, __destruct, arginfo_swoole_process_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_ME(swoole_process, wait, arginfo_swoole_process_wait, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     PHP_ME(swoole_process, signal, arginfo_swoole_process_signal, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     PHP_ME(swoole_process, kill, arginfo_swoole_process_kill, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     PHP_ME(swoole_process, daemon, arginfo_swoole_process_daemon, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     PHP_ME(swoole_process, setaffinity, arginfo_swoole_process_setaffinity, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     PHP_ME(swoole_process, useQueue, arginfo_swoole_process_useQueue, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, freeQueue, arginfo_swoole_process_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, start, arginfo_swoole_process_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, write, arginfo_swoole_process_write, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, close, arginfo_swoole_process_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, read, arginfo_swoole_process_read, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, push, arginfo_swoole_process_push, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, pop, arginfo_swoole_process_pop, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, exit, arginfo_swoole_process_exit, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_process, exec, arginfo_swoole_process_exec, ZEND_ACC_PUBLIC)
<     PHP_FALIAS(name, swoole_set_process_name, arginfo_swoole_process_name)
---
>     PHP_ME(swoole_process, __construct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
>     PHP_ME(swoole_process, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
>     PHP_ME(swoole_process, wait, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
>     PHP_ME(swoole_process, signal, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
>     PHP_ME(swoole_process, kill, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
>     PHP_ME(swoole_process, daemon, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
> #ifdef HAVE_CPU_AFFINITY
>     PHP_ME(swoole_process, setaffinity, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
> #endif
>     PHP_ME(swoole_process, useQueue, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, freeQueue, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, start, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, write, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, close, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, read, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, push, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, pop, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, exit, NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_process, exec, NULL, ZEND_ACC_PUBLIC)
>     PHP_FALIAS(name, swoole_set_process_name, NULL)
143,147d77
<     /// class property declare;
<     zend_declare_property_long(swoole_process_class_entry_ptr,ZEND_STRL("pid"),-1,ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_process_class_entry_ptr,ZEND_STRL("pipe"),-1,ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_null(swoole_process_class_entry_ptr,ZEND_STRL("callback"),ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_process_class_entry_ptr, ZEND_STRL("id"), 0,ZEND_ACC_PUBLIC TSRMLS_CC);
194,271c124
< int php_swoole_process_start(swWorker *process, zval *object TSRMLS_DC)
< {
<     process->pipe = process->pipe_worker;
<     process->pid = getpid();
< 
<     if (process->redirect_stdin && dup2(process->pipe, STDIN_FILENO) < 0)
<     {
<        swWarn("dup2() failed. Error: %s[%d]", strerror(errno), errno);
<     }
< 
<     if (process->redirect_stdout && dup2(process->pipe, STDOUT_FILENO) < 0)
<     {
<         swWarn("dup2() failed. Error: %s[%d]", strerror(errno), errno);
<     }
< 
<     if (process->redirect_stderr && dup2(process->pipe, STDERR_FILENO) < 0)
<     {
<         swWarn("dup2() failed. Error: %s[%d]", strerror(errno), errno);
<     }
< 
<     /// Close EventLoop
<     if (SwooleG.main_reactor)
<     {
<         SwooleG.main_reactor->free(SwooleG.main_reactor);
<         SwooleG.main_reactor = NULL;
<         swTraceLog(SW_TRACE_PHP, "destroy reactor");
<     }
< 
<     bzero(&SwooleWG, sizeof(SwooleWG));
<     SwooleG.pid = process->pid;
<     SwooleG.process_type = 0;
<     SwooleWG.id = process->id;
< 
<     if (SwooleG.timer.fd)
<     {
<         swTimer_free(&SwooleG.timer);
<         bzero(&SwooleG.timer, sizeof(SwooleG.timer));
<     }
< 
<     swSignal_clear();
< 
<     zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL("pid"), process->pid TSRMLS_CC);
<     zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL("pipe"), process->pipe_worker TSRMLS_CC);
< 
<     zval *zcallback = sw_zend_read_property(swoole_process_class_entry_ptr, object, ZEND_STRL("callback"), 0 TSRMLS_CC);
< 
<     if (swoole_check_callable(zcallback TSRMLS_CC) < 0)
<     {
<     	swoole_php_fatal_error(E_ERROR, "no callback.");
<     	return SW_ERR;
<     }
< 
<     zval **args[1];
<     zval *retval = NULL;
<     args[0] = &object;
< 
<     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
<     {
<     	swoole_php_fatal_error(E_ERROR, "callback function error");
<     	return SW_ERR;
<     }
< 
<     if (retval)
<     {
<         sw_zval_ptr_dtor(&retval);
<     }
< 
<     if (SwooleG.main_reactor)
<     {
<         php_swoole_event_wait();
<     }
< 
<     zend_bailout();
<     return SW_OK;
< }
< 
< /// safe signal
< static void php_swoole_onSignal(int signo)
---
> static PHP_METHOD(swoole_process, __construct)
273,296c126,128
<     SWOOLE_FETCH_TSRMLS;
< 
<     zval *callback = signal_callback[signo];
<     if (!callback || ZVAL_IS_NULL(callback))
<     {
<     	return;
<     }
< 
<     zval *zsigno = NULL;
<     SW_MAKE_STD_ZVAL(zsigno);
<     ZVAL_LONG(zsigno, signo);
< 
<     zval **args[1];
<     args[0] = &zsigno;
<     zval *retval;
<     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
<     {
<         swWarn("user_signal handler error");
<     }
< 
<     if (EG(exception))
< 	{
< 		zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 	}
---
>     zend_bool redirect_stdin_and_stdout = 0;
>     long pipe_type = 2;
>     zval *callback;
298c130,131
<     if (retval)
---
>     //only cli env
>     if (!SWOOLE_G(cli))
300c133,134
<         sw_zval_ptr_dtor(&retval);
---
>         swoole_php_fatal_error(E_ERROR, "swoole_process must run at php_cli environment.");
>         RETURN_FALSE;
303,325c137
<     sw_zval_ptr_dtor(&zsigno);
< }
< 
< static PHP_METHOD(swoole_process, __construct)
< {
< 	///only cli env
< 	if (!SWOOLE_G(cli))
< 	{
< 		swoole_php_fatal_error(E_ERROR, "swoole_process must run at php_cli environment.");
< 		RETURN_FALSE;
< 	}
< 
< 	swWorker *process = swoole_get_object(getThis());
< 	if (process)
< 	{
< 		swoole_php_fatal_error(E_ERROR, "swoole_process has been constructed.");
< 		RETURN_FALSE;
< 	}
< 
<     zend_bool redirect_stdin_and_stdout = 0;
<     long pipe_type = 2;
<     zval *callback = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|bl", &callback, &redirect_stdin_and_stdout, &pipe_type))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|bl", &callback, &redirect_stdin_and_stdout, &pipe_type) == FAILURE)
330c142,143
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))
332c145,147
<     	RETURN_FALSE;
---
>         swoole_php_fatal_error(E_ERROR, "function '%s' is not callable", func_name);
>         efree(func_name);
>         RETURN_FALSE;
333a149
>     efree(func_name);
335c151
<     process = emalloc(sizeof(swWorker));
---
>     swWorker *process = emalloc(sizeof(swWorker));
339c155,159
<     php_swoole_worker_round_id = (php_swoole_worker_round_id == 0)? 1:php_swoole_worker_round_id;
---
> 
>     if (php_swoole_worker_round_id == 0)
>     {
>         php_swoole_worker_round_id = 1;
>     }
355,356d174
<         	swoole_efree(_pipe);
<         	swoole_efree(process);
375,381d192
<     if (!process)
<     {
<     	return ;
<     }
< 
<     swoole_set_object(getThis(),NULL);
< 
386c197
<         swoole_efree(_pipe);
---
>         efree(_pipe);
391c202
<         swoole_efree(process->queue);
---
>         efree(process->queue);
393,394c204
< 
<     swoole_efree(process);
---
>     efree(process);
401c211,212
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &blocking))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &blocking) == FAILURE)
406,408c217,218
<     int options = (!blocking)? WNOHANG:0;
<     pid_t pid = swWaitpid(-1, &status, options);
<     if (pid <= 0)
---
>     int options = 0;
>     if (!blocking)
410c220
<     	RETURN_FALSE;
---
>         options |= WNOHANG;
413,416c223,234
< 	array_init(return_value);
< 	add_assoc_long(return_value, "pid", pid);
< 	add_assoc_long(return_value, "code", WEXITSTATUS(status));
< 	add_assoc_long(return_value, "signal", WTERMSIG(status));
---
>     pid_t pid = swWaitpid(-1, &status, options);
>     if (pid > 0)
>     {
>         array_init(return_value);
>         add_assoc_long(return_value, "pid", pid);
>         add_assoc_long(return_value, "code", WEXITSTATUS(status));
>         add_assoc_long(return_value, "signal", WTERMSIG(status));
>     }
>     else
>     {
>         RETURN_FALSE;
>     }
421,426d238
< 	swWorker *process = swoole_get_object(getThis());
< 	if (!process)
< 	{
< 		RETURN_FALSE;
< 	}
< 
429c241,242
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ll", &msgkey, &mode))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ll", &msgkey, &mode) == FAILURE)
433a247,248
>     swWorker *process = swoole_get_object(getThis());
> 
448,449c263
< 
<     queue->deleted = 0;
---
>     queue->delete = 0;
458c272
<     if (process && process->queue)
---
>     if (process->queue)
460c274
<         process->queue->deleted = 1;
---
>         process->queue->delete = 1;
462c276
<         swoole_efree(process->queue);
---
>         efree(process->queue);
476c290,291
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|l", &pid, &sig))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|l", &pid, &sig) == FAILURE)
481c296
<     int ret = swKill((int) pid, (int) sig);
---
>     int ret = kill((int) pid, (int) sig);
486c301
<             swWarn("kill(%d, %d) failed. Error: %s[%d]", (int) pid, (int) sig, strerror(errno), errno);
---
>             swoole_php_error(E_WARNING, "kill(%d, %d) failed. Error: %s[%d]", (int) pid, (int) sig, strerror(errno), errno);
497c312,313
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz", &signo, &callback))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz", &signo, &callback) == FAILURE)
508c324
<     if (SwooleGS->start && (signo == SIGTERM || signo == SIGALRM))
---
>     if (SwooleGS->start)
510,511c326,330
< 		swWarn("cannot use swoole_process::signal in swoole_server.");
< 		RETURN_FALSE;
---
>         if (signo == SIGTERM || signo == SIGALRM)
>         {
>             swoole_php_fatal_error(E_WARNING, "cannot use swoole_process::signal in swoole_server.");
>             RETURN_FALSE;
>         }
514c333
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     if (callback == NULL || ZVAL_IS_NULL(callback))
517c336
<         if (!callback)
---
>         if (callback)
519,521c338,340
<         	swWarn("no callback.");
<         	RETURN_FALSE;
< 
---
>             sw_zval_ptr_dtor(&callback);
>             swSignal_add(signo, NULL);
>             RETURN_TRUE;
522a342,347
>         else
>         {
>             swoole_php_error(E_WARNING, "no callback.");
>             RETURN_FALSE;
>         }
>     }
524,526c349,354
< //        sw_zval_ptr_dtor(&callback);
<         swSignal_add(signo, NULL);
<         RETURN_TRUE;
---
>     char *func_name;
>     if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))
>     {
>         swoole_php_error(E_WARNING, "function '%s' is not callable", func_name);
>         efree(func_name);
>         RETURN_FALSE;
527a356
>     efree(func_name);
538,539c367
<     	zval* _callback = signal_callback[signo];
<         sw_zval_ptr_dtor(&_callback);
---
>         sw_zval_ptr_dtor(&callback);
541d368
< 
552c379,381
<     ///  for swSignal fd_setup
---
>     /**
>      * for swSignalfd_setup
>      */
558a388,505
> /**
>  * safe signal
>  */
> static void php_swoole_onSignal(int signo)
> {
>     zval *retval;
>     zval **args[1];
>     zval *callback = signal_callback[signo];
> 
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     zval *zsigno;
>     SW_MAKE_STD_ZVAL(zsigno);
>     ZVAL_LONG(zsigno, signo);
> 
>     args[0] = &zsigno;
> 
>     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_WARNING, "user_signal handler error");
>     }
>     if (retval != NULL)
>     {
>         sw_zval_ptr_dtor(&retval);
>     }
>     sw_zval_ptr_dtor(&zsigno);
> }
> 
> int php_swoole_process_start(swWorker *process, zval *object TSRMLS_DC)
> {
>     process->pipe = process->pipe_worker;
>     process->pid = getpid();
> 
>     if (process->redirect_stdin)
>     {
>         if (dup2(process->pipe, STDIN_FILENO) < 0)
>         {
>             swoole_php_fatal_error(E_WARNING, "dup2() failed. Error: %s[%d]", strerror(errno), errno);
>         }
>     }
> 
>     if (process->redirect_stdout)
>     {
>         if (dup2(process->pipe, STDOUT_FILENO) < 0)
>         {
>             swoole_php_fatal_error(E_WARNING, "dup2() failed. Error: %s[%d]", strerror(errno), errno);
>         }
>     }
> 
>     if (process->redirect_stderr)
>     {
>         if (dup2(process->pipe, STDERR_FILENO) < 0)
>         {
>             swoole_php_fatal_error(E_WARNING, "dup2() failed. Error: %s[%d]", strerror(errno), errno);
>         }
>     }
> 
>     /**
>      * Close EventLoop
>      */
>     if (SwooleG.main_reactor)
>     {
>         SwooleG.main_reactor->free(SwooleG.main_reactor);
>         SwooleG.main_reactor = NULL;
>         swTraceLog(SW_TRACE_PHP, "destroy reactor");
>     }
> 
>     bzero(&SwooleWG, sizeof(SwooleWG));
>     SwooleG.pid = process->pid;
>     SwooleG.process_type = 0;
>     SwooleWG.id = process->id;
> 
>     if (SwooleG.timer.fd)
>     {
>         swTimer_free(&SwooleG.timer);
>         bzero(&SwooleG.timer, sizeof(SwooleG.timer));
>     }
> 
>     swSignal_clear();
> 
>     zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL("pid"), process->pid TSRMLS_CC);
>     zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL("pipe"), process->pipe_worker TSRMLS_CC);
> 
>     zval *zcallback = sw_zend_read_property(swoole_process_class_entry_ptr, object, ZEND_STRL("callback"), 0 TSRMLS_CC);
>     zval **args[1];
> 
>     if (zcallback == NULL || ZVAL_IS_NULL(zcallback))
>     {
>         swoole_php_fatal_error(E_ERROR, "no callback.");
>         return SW_ERR;
>     }
> 
>     zval *retval = NULL;
>     args[0] = &object;
>     sw_zval_add_ref(&object);
> 
>     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_ERROR, "callback function error");
>         return SW_ERR;
>     }
> 
>     if (retval)
>     {
>         sw_zval_ptr_dtor(&retval);
>     }
> 
>     if (SwooleG.main_reactor)
>     {
>         php_swoole_event_wait();
>     }
> 
>     zend_bailout();
>     return SW_OK;
> }
> 
562c509,510
<     if (!process || (process->pid > 0 && swKill(process->pid, 0) == 0))
---
> 
>     if (process->pid > 0 && kill(process->pid, 0) == 0)
564c512
<         swWarn("process is already started.");
---
>         swoole_php_fatal_error(E_WARNING, "process is already started.");
571c519
<         swWarn("fork() failed. Error: %s[%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "fork() failed. Error: %s[%d]", strerror(errno), errno);
586d533
< 
592,598d538
< 	swWorker *process = swoole_get_object(getThis());
< 	if (!process || process->pipe == 0)
< 	{
< 		swWarn("process not exist or not pipe, can not use read");
< 		RETURN_FALSE;
< 	}
< 
600c540,541
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &buf_size))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &buf_size) == FAILURE)
605c546,557
<     buf_size = (buf_size > 65536)? 65535:buf_size;
---
>     if (buf_size > 65536)
>     {
>         buf_size = 65536;
>     }
> 
>     swWorker *process = swoole_get_object(getThis());
> 
>     if (process->pipe == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "have not pipe, can not use read()");
>         RETURN_FALSE;
>     }
611c563
<         swoole_efree(buf); 
---
>         efree(buf); 
614c566
<             swWarn("failed. Error: %s[%d]", strerror(errno), errno);
---
>             swoole_php_error(E_WARNING, "failed. Error: %s[%d]", strerror(errno), errno);
616d567
< 
619d569
< 
622d571
< 
624c573
<     swoole_efree(buf);
---
>     efree(buf);
630,636d578
< 	swWorker *process = swoole_get_object(getThis());
< 	if (!process || process->pipe == 0)
< 	{
< 		swWarn("process not exist or not pipe, can not use write");
< 		RETURN_FALSE;
< 	}
< 
639c581,587
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &data, &data_len))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &data, &data_len) == FAILURE)
>     {
>         RETURN_FALSE;
>     }
> 
>     if (data_len < 1)
640a589
>         swoole_php_fatal_error(E_WARNING, "send data empty.");
644c593,594
<     if (data_len < 1 || !data)
---
>     swWorker *process = swoole_get_object(getThis());
>     if (process->pipe == 0)
646c596
<         swWarn("send data empty.");
---
>         swoole_php_fatal_error(E_WARNING, "have not pipe, can not use read()");
650,652c600,610
<     //async write or sync write.
<     int ret = SwooleG.main_reactor? SwooleG.main_reactor->write(SwooleG.main_reactor, process->pipe, data, (size_t) data_len):
<     				swSocket_write_blocking(process->pipe, data, data_len);
---
>     int ret;
> 
>     //async write
>     if (SwooleG.main_reactor)
>     {
>         ret = SwooleG.main_reactor->write(SwooleG.main_reactor, process->pipe, data, (size_t) data_len);
>     }
>     else
>     {
>         ret = swSocket_write_blocking(process->pipe, data, data_len);
>     }
656c614
<         swWarn("write() failed. Error: %s[%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "write() failed. Error: %s[%d]", strerror(errno), errno);
659d616
< 
665,670c622,623
< 	swWorker *process = swoole_get_object(getThis());
< 	if (!process || !process->queue)
< 	{
< 		swWarn("process not exist or have not msgqueue, can not use push.");
< 		RETURN_FALSE;
< 	}
---
>     char *data;
>     zend_size_t length;
678,680c631
<     char *data = NULL;
<     zend_size_t length = 0;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &data, &length))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &data, &length) == FAILURE)
685c636
<     if (length <= 0 || !data)
---
>     if (length <= 0)
687c638
<         swWarn("data empty.");
---
>         swoole_php_fatal_error(E_WARNING, "data empty.");
689a641,647
>     else if (length >= sizeof(message.data))
>     {
>         swoole_php_fatal_error(E_WARNING, "data too big.");
>         RETURN_FALSE;
>     }
> 
>     swWorker *process = swoole_get_object(getThis());
691c649
<     if (length >= sizeof(message.data))
---
>     if (!process->queue)
693c651
<         swWarn("data too big.");
---
>         swoole_php_fatal_error(E_WARNING, "have not msgqueue, can not use push()");
702c660
<         swWarn("msgsnd() failed. Error: %s[%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "msgsnd() failed. Error: %s[%d]", strerror(errno), errno);
705d662
< 
711,717d667
< 	swWorker *process = swoole_get_object(getThis());
< 	if (!process || !process->queue)
< 	{
< 		swWarn("process not exist or have not msgqueue, can not use push");
< 		RETURN_FALSE;
< 	}
< 
719c669,670
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &maxsize))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &maxsize) == FAILURE)
723,724c674,683
< 
<     maxsize = (maxsize > SW_MSGMAX)? SW_MSGMAX:(maxsize <= 0? 8192:maxsize);
---
>     if (maxsize <= 0 || maxsize > SW_MSGMAX)
>     {
>         maxsize = SW_MSGMAX;
>     }
>     swWorker *process = swoole_get_object(getThis());
>     if (!process->queue)
>     {
>         swoole_php_fatal_error(E_WARNING, "have not msgqueue, can not use push()");
>         RETURN_FALSE;
>     }
732c691,699
<     message.type = (process->ipc_mode == 2)? 0:process->id;
---
>     if (process->ipc_mode == 2)
>     {
>         message.type = 0;
>     }
>     else
>     {
>         message.type = process->id;
>     }
> 
736c703
<         swWarn("msgrcv() failed. Error: %s[%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "msgrcv() failed. Error: %s[%d]", strerror(errno), errno);
739d705
< 
747,748c713,715
<     zval *args = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sa", &execfile, &execfile_len, &args))
---
>     zval *args;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sa", &execfile, &execfile_len, &args) == FAILURE)
753c720
<     if (execfile_len < 1 || !execfile)
---
>     if (execfile_len < 1)
755c722
<         swWarn("execfile name empty.");
---
>         swoole_php_fatal_error(E_WARNING, "execfile name empty.");
761d727
<     exec_args[0] = strdup(execfile);
763d728
<     int index = 1;
764a730,732
>     exec_args[0] = strdup(execfile);
>     int i = 1;
> 
768,769c736,737
<         exec_args[index] = Z_STRVAL_P(value);
<         index++;
---
>         exec_args[i] = Z_STRVAL_P(value);
>         i++;
771c739
<     exec_args[index] = NULL;
---
>     exec_args[i] = NULL;
775c743
<         swWarn("execv(%s) failed. Error: %s[%d]", execfile, strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "execv(%s) failed. Error: %s[%d]", execfile, strerror(errno), errno);
778,779c746,749
< 
<     RETURN_TRUE;
---
>     else
>     {
>         RETURN_TRUE;
>     }
784,786c754,757
<     zend_bool nochdir = 1;
<     zend_bool noclose = 1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|bb", &nochdir, &noclose))
---
>     zend_bool nochdir = 0;
>     zend_bool noclose = 0;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|bb", &nochdir, &noclose) == FAILURE)
790,791c761
< 
<     RETURN_BOOL(swoole_daemon(nochdir, noclose) == 0);
---
>     RETURN_BOOL(daemon(nochdir, noclose) == 0);
793a764
> #ifdef HAVE_CPU_AFFINITY
796,798c767,768
< #ifdef HAVE_CPU_AFFINITY
<     zval *array = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "a", &array))
---
>     zval *array;
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "a", &array) == FAILURE)
802,803c772,776
< 
<     if (!array || Z_ARRVAL_P(array)->nNumOfElements == 0 || Z_ARRVAL_P(array)->nNumOfElements > SW_CPU_NUM)
---
>     if (Z_ARRVAL_P(array)->nNumOfElements == 0)
>     {
>         RETURN_FALSE;
>     }
>     if (Z_ARRVAL_P(array)->nNumOfElements > SW_CPU_NUM)
805,806c778,779
<     	swWarn("array number of CPU between 0 and %d.",SW_CPU_NUM);
<     	RETURN_FALSE;
---
>         swoole_php_fatal_error(E_WARNING, "More than the number of CPU");
>         RETURN_FALSE;
817c790
<             swWarn("invalid cpu id [%d]", (int) Z_LVAL_P(value));
---
>             swoole_php_fatal_error(E_WARNING, "invalid cpu id [%d]", (int) Z_LVAL_P(value));
828d800
< 
830,832d801
< #else
<     RETURN_FALSE;
< #endif
833a803
> #endif
837,843d806
< 	swWorker *process = swoole_get_object(getThis());
< 	if (!process || getpid() != process->pid)
< 	{
< 		swWarn("process not exits or not current process.");
< 		RETURN_FALSE;
< 	}
< 
845c808,816
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &ret_code))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &ret_code) == FAILURE)
>     {
>         RETURN_FALSE;
>     }
> 
>     swWorker *process = swoole_get_object(getThis());
> 
>     if (getpid() != process->pid)
846a818
>         swoole_php_fatal_error(E_WARNING, "not current process.");
852c824
<         swWarn("exit ret_code range is [>0 and <255] ");
---
>         swoole_php_fatal_error(E_WARNING, "exit ret_code range is [>0 and <255] ");
876c848,849
<     if (!process || process->pipe == 0)
---
> 
>     if (process->pipe == 0)
878c851
<         swWarn("process not exist or have not pipe, can not use close");
---
>         swoole_php_fatal_error(E_WARNING, "have not pipe, can not use close()");
885c858
<         swWarn("close() failed. Error: %s[%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "close() failed. Error: %s[%d]", strerror(errno), errno);
891c864
<         swoole_efree(process->pipe_object);
---
>         efree(process->pipe_object);
894d866
< 
diff -r ./zan-extension/swoole_redis.c ../swoole-1.8.5-stable/swoole_redis.c
20,21c20,22
< #include "hiredis/hiredis.h"
< #include "hiredis/async.h"
---
> #include <hiredis/hiredis.h>
> #include <hiredis/async.h>
> 
28d28
< 
31,34d30
<     uint8_t released;
<     uint8_t timeout_type;
<     int fd;
<     uint64_t timer_id;
36d31
<     zval *object;
37a33,34
>     zval *connect_callback;
>     zval *close_callback;
39,41d35
<     zval *onConnect;
<     zval *onClose;
<     zval *onTimeout;
43a38,40
>     zval _result_callback;
>     zval _connect_callback;
>     zval _close_callback;
45,47d41
<     zval _onClose;
<     zval _onTimeout;
<     zval _object;
48a43,45
> 
>     zval *object;
>     zval _object;
60,62d56
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
66c60
< 	ZEND_ARG_INFO(0, callback)
---
>     ZEND_ARG_INFO(0, callback)
74,77d67
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_redis_timeout, 0, 0, 1)
<     ZEND_ARG_INFO(0, timeout)
< ZEND_END_ARG_INFO()
< 
83d72
< 
87,88d75
< static PHP_METHOD(swoole_redis,setConnectTimeout);
< static PHP_METHOD(swoole_redis,setQueryTimeout);
90d76
< static PHP_METHOD(swoole_redis,isConnected);
94d79
< static void redis_Client_timeout(swTimer* timer,swTimer_node* node);
97d81
< static void swoole_redis_close(swRedisClient* redis);
100d83
< static int swoole_redis_onError(swReactor *reactor, swEvent *event);
103,108d85
< static int close_redis_client(swRedisClient* redis);
< 
< static void swoole_redis_onCall(swRedisClient *redis, redisReply* reply TSRMLS_DC);
< static void swoole_redis_conResult(swRedisClient *redis,int status TSRMLS_DC);
< 
< static void redis_client_free_cb(swRedisClient* redis);
122,123c99,100
<     PHP_ME(swoole_redis, __construct, arginfo_swoole_void, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_redis, __destruct, arginfo_swoole_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
---
>     PHP_ME(swoole_redis, __construct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
>     PHP_ME(swoole_redis, __destruct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
125,126d101
< 	PHP_ME(swoole_redis, setConnectTimeout, arginfo_swoole_redis_timeout, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_redis, setQueryTimeout, arginfo_swoole_redis_timeout, ZEND_ACC_PUBLIC)
128,129c103
<     PHP_ME(swoole_redis, close, arginfo_swoole_void, ZEND_ACC_PUBLIC)
< 	PHP_ME(swoole_redis, isConnected, arginfo_swoole_void, ZEND_ACC_PUBLIC)
---
>     PHP_ME(swoole_redis, close, NULL, ZEND_ACC_PUBLIC)
134,194d107
< static void redis_Client_timeout(swTimer* timer,swTimer_node* node)
< {
< 	swRedisClient *redis = node? node->data:NULL;
< 	uint8_t timeout_type = redis?redis->timeout_type:SW_CLIENT_INVAILED_TIMEOUT;
< 	if (timeout_type == SW_CLIENT_CONNECT_TIMEOUT || timeout_type == SW_CLIENT_RECV_TIMEOUT)
< 	{
< 		redis->timer_id = 0;
< 		if (redis->object && redis->onTimeout)
< 		{
< 			zval* callback = redis->onTimeout;
< 			zval* eventType = NULL;
< 			SW_MAKE_STD_ZVAL(eventType);
< 			ZVAL_LONG(eventType,timeout_type);
< 			zval **args[2];
< 			args[0] = &(redis->object);
< 			args[1] = &eventType;
< 			zval *retval = NULL;
< 			if (sw_call_user_function_ex(EG(function_table), NULL,callback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
< 			{
< 				swWarn("timeout event handler error.");
< 			}
< 
< 			if (EG(exception))
< 			{
< 				zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 			}
< 
< 			if (retval) sw_zval_ptr_dtor(&retval);
< 			if (eventType) sw_zval_ptr_dtor(&eventType);
< 		}
< 	}
< 
< 	swTimer_del(timer,node->id);
< }
< 
< static void redis_client_free_cb(swRedisClient* redis)
< {
< 	if (!redis)
< 	{
< 		return;
< 	}
< 
< 	if (redis->result_callback)
< 	{
< 		zval* callback = redis->result_callback;
< 		redis->result_callback = NULL;
< 		sw_zval_free(callback);
< 	}
< 
< 	if (redis->onConnect)
< 	{
< 		zval* callback = redis->onConnect;
< 		redis->onConnect = NULL;
< 		sw_zval_free(callback);
< 	}
< 
< 	if (redis->onClose) {sw_zval_ptr_dtor(&redis->onClose);redis->onClose = NULL;}
< 	if (redis->onTimeout) {sw_zval_ptr_dtor(&redis->onTimeout);redis->onTimeout = NULL;}
< 	if (redis->message_callback) {sw_zval_ptr_dtor(&redis->message_callback);redis->message_callback = NULL;}
< }
< 
223,232d135
< 
<     zend_declare_property_long(swoole_redis_class_entry_ptr, SW_STRL("errCode") - 1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_bool(swoole_redis_class_entry_ptr, SW_STRL("internal_user")-1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_redis_class_entry_ptr, SW_STRL("connectTimeout") - 1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_redis_class_entry_ptr, SW_STRL("queryTimeout") - 1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     zend_declare_property_long(swoole_redis_class_entry_ptr, SW_STRL("sock") - 1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_long(swoole_redis_class_entry_ptr, SW_STRL("port") - 1, 0, ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_string(swoole_redis_class_entry_ptr, SW_STRL("errMsg") - 1, "", ZEND_ACC_PUBLIC TSRMLS_CC);
<     zend_declare_property_string(swoole_redis_class_entry_ptr, SW_STRL("host") - 1, "", ZEND_ACC_PUBLIC TSRMLS_CC);    
240c143,150
<     redis->fd = -1;
---
> #if PHP_MAJOR_VERSION < 7
>     redis->object = getThis();
> #else
>     redis->object = &redis->_object;
>     memcpy(redis->object, getThis(), sizeof(zval));
> #endif
>     sw_zval_add_ref(&redis->object);
> 
246,247c156,160
<     swRedisClient *redis = swoole_get_object(getThis());
<     if(!redis)
---
>     char *name;
>     zend_size_t len;
>     zval *cb;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "sz", &name, &len, &cb) == FAILURE)
249,250c162
<         swWarn("Reis __construct may not be called");
<         RETURN_FALSE;
---
>         return;
253,259c165,166
<     zval *internal_user = sw_zend_read_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	int disable_set = internal_user && Z_BVAL_P(internal_user);
< 
< 	char *name = NULL;
< 	zend_size_t len = 0;
< 	zval *cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "sz", &name, &len, &cb))
---
>     swRedisClient *redis = swoole_get_object(getThis());
>     if (redis->context != NULL)
260a168
>         swoole_php_fatal_error(E_WARNING, "Must be called before connect.");
263,285c171,176
< //    if (redis->context != NULL)
< //    {
< //        swWarn("Must be called before connect.");
< //        RETURN_FALSE;
< //    }
< 
<     if (len == strlen("close") && strncasecmp("close", name, len) == 0)
<     {
< 		if (disable_set)
< 		{
< 			swWarn("object created by connection pool,disable set close event");
< 			RETURN_FALSE;
< 		}
< 
< 		if (redis->onClose) sw_zval_ptr_dtor(&redis->onClose);
< 		redis->onClose = cb;
< 		sw_copy_to_stack(redis->onClose, redis->_onClose);
<     }
<     else if (len == strlen("timeout") && strncasecmp("timeout", name, len) == 0)
<     {
<     		if (redis->onTimeout) sw_zval_ptr_dtor(&redis->onTimeout);
< 		redis->onTimeout = cb;
< 		sw_copy_to_stack(redis->onTimeout, redis->_onTimeout);
---
> 
>     if (strncasecmp("close", name, len) == 0)
>     {
>         zend_update_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("onClose"), cb TSRMLS_CC);
>         redis->close_callback = sw_zend_read_property(swoole_redis_class_entry_ptr,  getThis(), ZEND_STRL("onClose"), 0 TSRMLS_CC);
>         sw_copy_to_stack(redis->close_callback, redis->_close_callback);
287c178
<     else if (len == strlen("message") && strncasecmp("message", name, len) == 0)
---
>     else if (strncasecmp("message", name, len) == 0)
289,290c180,181
<     		if (redis->message_callback) sw_zval_ptr_dtor(&redis->message_callback);
<         redis->message_callback = cb;
---
>         zend_update_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("onMessage"), cb TSRMLS_CC);
>         redis->message_callback = sw_zend_read_property(swoole_redis_class_entry_ptr,  getThis(), ZEND_STRL("onMessage"), 0 TSRMLS_CC);
291a183
> 
296c188
<         swWarn("Unknown event type[%s]", name);
---
>         swoole_php_error(E_WARNING, "Unknown event type[%s]", name);
299,300d190
< 
<     sw_zval_add_ref(&cb);
304,328d193
< static PHP_METHOD(swoole_redis,setConnectTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l",&timeout))
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	zend_update_property_long(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("connectTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE
< }
< 
< static PHP_METHOD(swoole_redis,setQueryTimeout)
< {
< 	long timeout = 0;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &timeout))
< 	{
< 		swWarn("parse parameters error.");
< 		RETURN_FALSE;
< 	}
< 
< 	zend_update_property_long(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("queryTimeout"), timeout TSRMLS_CC);
< 	RETURN_TRUE;
< }
< 
331,335c196,199
<     swRedisClient *redis = swoole_get_object(getThis());
<     if(!redis || redis->context || redis->released)
<     {
<         RETURN_FALSE;
<     }
---
>     char *host;
>     zend_size_t host_len;
>     long port;
>     zval *callback;
337,349c201
<     zval *internal_user = sw_zend_read_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	if (internal_user && Z_BVAL_P(internal_user))
< 	{
< 		return;
< 	}
< 
< 	char *host = NULL;
< 	zend_size_t host_len = 0;
< 	long port = 0;
< 	redisAsyncContext* context = NULL;
<     zval* callback = NULL;
<     /// port <= 0 使用unix sock 方式连接
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "slz", &host, &host_len, &port,&callback))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "slz", &host, &host_len, &port, &callback) == FAILURE)
354c206
<     if (host_len <= 0 || !host)
---
>     if (host_len <= 0)
356c208
<         swWarn("host is empty.");
---
>         swoole_php_error(E_WARNING, "host is empty.");
360c212
<     if (port > 65535)
---
>     if (port <= 1 || port > 65535)
362c214
<         swWarn("port is invalid.");
---
>         swoole_php_error(E_WARNING, "port is invalid.");
365,369d216
<   
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
<     {
<     	RETURN_FALSE;
<     }
371,378c218,219
<     int host_unix = 0;
<     if (strncasecmp(host, ZEND_STRL("unix:/")) == 0)
< 	{
< 		host_unix = 1;
< 		host += 5;
< 	}
< 
< 	context = (port <= 0 || host_unix)? redisAsyncConnectUnix(host):redisAsyncConnect(host, (int) port);
---
>     swRedisClient *redis = swoole_get_object(getThis());
>     redisAsyncContext *context = redisAsyncConnect(host, (int) port);
381c222
<         swWarn("connect to redis-server[%s:%d] failed, Erorr: %s[%d]", host, (int) port, context->errstr, context->err);
---
>         swoole_php_error(E_WARNING, "connect to redis-server[%s:%d] failed, Erorr: %s[%d]", host, (int) port, context->errstr, context->err);
390d230
<         SwooleG.main_reactor->setHandle(SwooleG.main_reactor, PHP_SWOOLE_FD_REDIS | SW_EVENT_ERROR, swoole_redis_onError);
396d235
<     zend_update_property_long(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("sock"), context->c.fd TSRMLS_CC);
398,399c237,239
< 	sw_zval_add_ref(&callback);
< 	redis->onConnect = sw_zval_dup(callback);
---
>     zend_update_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("onConnect"), callback TSRMLS_CC);
>     redis->connect_callback = sw_zend_read_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("onConnect"), 0 TSRMLS_CC);
>     sw_copy_to_stack(redis->connect_callback, redis->_connect_callback);
408d247
<     redis->fd = context->c.fd;
413,417d251
<     swConnection *conn = swReactor_get(SwooleG.main_reactor, redis->context->c.fd);
<     bzero(conn,sizeof(swConnection));
< 	conn->fd = context->c.fd;
< 	conn->object = redis;
< 
419,448c253,256
< 	{
< 		swWarn("swoole_event_add failed. Erorr: %s[%d].", redis->context->errstr, redis->context->err);
< 		RETURN_FALSE;
< 	}
< 
<     redis->object = getThis();
< 	sw_zval_add_ref(&redis->object);
< 	sw_copy_to_stack(redis->object, redis->_object);
< 
<     long timeout = 0;
< 	zval* connectTimeout = sw_zend_read_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("connectTimeout"), 1 TSRMLS_CC);
< 	if (connectTimeout)
< 	{
< 		convert_to_long(connectTimeout);
< 		timeout = Z_LVAL_P(connectTimeout);
< 	}
< 
< 	if (timeout > 0)
< 	{
<     	redis->timer_id = 0;
<     	redis->timer_id = swTimer_add(&SwooleG.timer,timeout,0,redis,REDIS_USED);
< 		if (redis->timer_id <= 0)
< 		{
< 			swWarn("set connect timeout timer failed.");
< 			RETURN_FALSE;
< 		}
< 
< 		redis->timeout_type = SW_CLIENT_CONNECT_TIMEOUT;
< 		register_after_cb(&SwooleG.timer,REDIS_USED,redis_Client_timeout);
< 	}
---
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_event_add failed. Erorr: %s[%d].", redis->context->errstr, redis->context->err);
>         RETURN_FALSE;
>     }
450c258,259
<     RETURN_TRUE;
---
>     swConnection *conn = swReactor_get(SwooleG.main_reactor, redis->context->c.fd);
>     conn->object = redis;
455,460d263
< 	zval *internal_user = sw_zend_read_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("internal_user"), 1 TSRMLS_CC);
< 	if (internal_user && Z_BVAL_P(internal_user))
< 	{
< 		return;
< 	}
< 
462,474c265
<     if (!redis || redis->released)
<     {
<     	RETURN_FALSE;
<     }
< 
<     int ret = close_redis_client(redis);
<     swoole_redis_close(redis);
<     if (ret < 0)
<     {
<     	RETURN_FALSE;
<     }
< 
<     RETURN_TRUE;
---
>     redisAsyncDisconnect(redis->context);
480,498c271,283
<     close_redis_client(redis);
< 
<     redis_client_free_cb(redis);
< 
<     releaseConnobj(getThis());
< 
<     swoole_set_object(getThis(), NULL);
<     swoole_efree(redis);
< }
< 
< static PHP_METHOD(swoole_redis,isConnected)
< {
< 	swRedisClient *redis = swoole_get_object(getThis());
< 	if (!redis || redis->released)
< 	{
< 		RETURN_FALSE;
< 	}
< 
< 	RETURN_BOOL(redis->state != SWOOLE_REDIS_STATE_CONNECT && redis->state != SWOOLE_REDIS_STATE_CLOSED);
---
>     if (!redis)
>     {
>         return;
>     }
>     if (redis->state != SWOOLE_REDIS_STATE_CLOSED)
>     {
>         redisAsyncDisconnect(redis->context);
>     }
>     if (redis->message_callback)
>     {
>         sw_zval_ptr_dtor(&redis->message_callback);
>     }
>     efree(redis);
503,510c288
<     
<     swRedisClient *redis = swoole_get_object(getThis());
<     if(!redis || redis->released || !redis->context)
<     {
<         RETURN_FALSE;
<     }
< 
< 	zval *params;
---
>     zval *params;
513c291,292
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &command, &command_len, &params))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz", &command, &command_len, &params) == FAILURE)
515c294
<         RETURN_FALSE;
---
>         return;
517c296,297
<     
---
> 
>     swRedisClient *redis = swoole_get_object(getThis());
521c301
<         swWarn("redis client is not connected.");
---
>         swoole_php_error(E_WARNING, "redis client is not connected.");
525c305
<         swWarn("redis client is waiting for response.");
---
>         swoole_php_error(E_WARNING, "redis client is waiting for response.");
531c311
<             swWarn("redis client is waiting for subscribe message.");
---
>             swoole_php_error(E_WARNING, "redis client is waiting for subscribe message.");
536c316
<         swWarn("redis client connection is closed.");
---
>         swoole_php_error(E_WARNING, "redis client connection is closed.");
575d354
<     int iRet = 0;
596,598c375,376
<             swWarn("redisAsyncCommandArgv() failed.");
<             iRet = -1;
<             goto result;
---
>             swoole_php_error(E_WARNING, "redisAsyncCommandArgv() failed.");
>             RETURN_FALSE;
608d385
<         zval *callback = NULL;
609a387
>         zval *callback;
613,616c391,392
<             swWarn("index out of array.");
<             iRet = -1;
<             redis->state = SWOOLE_REDIS_STATE_READY;
<             goto result;
---
>             swoole_php_error(E_WARNING, "index out of array.");
>             RETURN_FALSE;
618a395
>         redis->result_callback = callback;
620c397
<         callback = zend_hash_index_find(Z_ARRVAL_P(params), zend_hash_num_elements(Z_ARRVAL_P(params)) - 1);
---
>         zval *callback = zend_hash_index_find(Z_ARRVAL_P(params), zend_hash_num_elements(Z_ARRVAL_P(params)) - 1);
623,626c400,401
<             swWarn("index out of array.");
<             iRet = -1;
<             redis->state = SWOOLE_REDIS_STATE_READY;
<             goto result;
---
>             swoole_php_error(E_WARNING, "index out of array.");
>             RETURN_FALSE;
627a403,404
>         redis->result_callback = &redis->_result_callback;
>         memcpy(redis->result_callback, callback, sizeof(zval));
629,630c406,407
<         sw_zval_add_ref(&callback);
<         redis->result_callback = sw_zval_dup(callback);
---
> 
>         sw_zval_add_ref(&redis->result_callback);
645,647c422,423
<             swWarn("redisAsyncCommandArgv() failed.");
<             iRet = -1;
<             goto result;
---
>             swoole_php_error(E_WARNING, "redisAsyncCommandArgv() failed.");
>             RETURN_FALSE;
649,671d424
< 
<         long timeout = 0;
< 		zval* querytimeout = sw_zend_read_property(swoole_redis_class_entry_ptr, getThis(), ZEND_STRL("queryTimeout"), 1 TSRMLS_CC);
< 		if (querytimeout)
< 		{
< 			convert_to_long(querytimeout);
< 			timeout = Z_LVAL_P(querytimeout);
< 		}
< 
<         if (timeout > 0)
< 		{
< 			redis->timer_id = 0;
< 			redis->timer_id = swTimer_add(&SwooleG.timer,timeout,0,redis,REDIS_USED);
< 			if (redis->timer_id <= 0)
< 			{
< 				swWarn("set recv msg time out timer failed.");
< 				iRet = -1;
< 				goto result;
< 			}
< 
< 			redis->timeout_type = SW_CLIENT_RECV_TIMEOUT;
< 			register_after_cb(&SwooleG.timer,REDIS_USED,redis_Client_timeout);
< 		}
674d426
< result:
682,689c434,435
<         swoole_efree(argvlen);
<         swoole_efree(argv);
<         free_mm = 0;
<     }
< 
<     if (iRet < 0)
<     {
<     	RETURN_FALSE;
---
>         efree(argvlen);
>         efree(argv);
700c446,450
<     SW_MAKE_STD_ZVAL(val);
---
> #if PHP_MAJOR_VERSION >= 7
>     zval _val;
>     val = &_val;
>     bzero(val, sizeof(zval));
> #endif
709,716c459,461
< 		{
< 			ZVAL_FALSE(return_value);
< 			zend_update_property_long(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errCode"), REDIS_ERR TSRMLS_CC);
< 			char *str = zend_str_tolower_dup(reply->str, reply->len);
< 			zend_update_property_string(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errMsg"), str TSRMLS_CC);
< 			swoole_efree(str);
< 		}
< 
---
>         ZVAL_FALSE(return_value);
>         zend_update_property_long(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errCode"), redis->context->err TSRMLS_CC);
>         zend_update_property_string(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errMsg"), redis->context->errstr TSRMLS_CC);
738a484,486
> #if PHP_MAJOR_VERSION < 7
>             SW_ALLOC_INIT_ZVAL(val);
> #endif
753c501,503
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
760a511
>     char *callback_type;
762,770c513,514
< 
<     swoole_redis_onCall(redis,reply TSRMLS_CC);
< }
< 
< static void swoole_redis_onCall(swRedisClient *redis, redisReply* reply TSRMLS_DC)
< {
< 	char *callback_type;
< 	zval *result = NULL, *retval = NULL, *callback = NULL;
< 	SW_MAKE_STD_ZVAL(result);
---
>     zval *result, *retval, *callback;
>     SW_MAKE_STD_ZVAL(result);
774,781d517
< 	if (redis && redis->timer_id > 0)
< 	{
< 		long timer_id = redis->timer_id;
< 		redis->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
< 	int free_cb = 0;
790d525
<         redis->result_callback = NULL;
793d527
<         free_cb = 1;
795c529
<     
---
> 
800c534
<     if (callback && sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
802c536
<         swWarn("swoole_redis %s callback handler error.", callback_type);
---
>         swoole_php_fatal_error(E_WARNING, "swoole_redis callback[%s] handler error.", callback_type);
804d537
< 
813d545
< 
815,816d546
<     if (free_cb && callback) sw_zval_free(callback);
< }
818,822c548,549
< static void swoole_redis_onConnect(const redisAsyncContext *c, int status)
< {
<     SWOOLE_FETCH_TSRMLS;
<     swRedisClient *redis = c->ev.data;
<     if (!redis)
---
> #if PHP_MAJOR_VERSION < 7
>     if (redis->state == SWOOLE_REDIS_STATE_READY)
824c551
<     	return ;
---
>         sw_zval_ptr_dtor(&callback);
826,827c553
< 
<     swoole_redis_conResult(redis,status TSRMLS_CC);
---
> #endif
830c556
< static void swoole_redis_conResult(swRedisClient *redis,int status TSRMLS_DC)
---
> void swoole_redis_onConnect(const redisAsyncContext *c, int status)
832,875c558,561
< 	if (redis && redis->timer_id > 0)
< 	{
< 		long timer_id = redis->timer_id;
< 		redis->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
<     zval *zcallback = redis->onConnect;
<     redis->onConnect = NULL;
<     if (zcallback)
<     {
<     	zval *result = NULL;
< 		zval *retval = NULL;
< 		SW_MAKE_STD_ZVAL(result);
< 
< 		if (status != REDIS_OK)
< 		{
< 			ZVAL_BOOL(result, 0);
< 			zend_update_property_long(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errCode"),redis->context->err TSRMLS_CC);
< 			zend_update_property_string(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errMsg"),redis->context->errstr TSRMLS_CC);
< 			redis->state = SWOOLE_REDIS_STATE_CLOSED;
< 		}
< 		else
< 		{
< 			ZVAL_BOOL(result, 1);
< 			redis->state = SWOOLE_REDIS_STATE_READY;
< 		}
< 
< 		zval **args[2];
< 		zval* object = redis->object;
< 		sw_zval_add_ref(&object);
< 		args[0] = &object;
< 		args[1] = &result;
< //		redis->released = 1;
< 		if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
< 		{
< 			swWarn("swoole_async_redis connect_callback handler error.");
< 		}
< 
< 		if (retval != NULL)  sw_zval_ptr_dtor(&retval);
< 
< 		sw_zval_ptr_dtor(&result);
< 
< 		if (zcallback) sw_zval_free(zcallback);
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
>     swRedisClient *redis = c->ev.data;
877,878c563,570
< //		redis->released = 0;
< 		sw_zval_ptr_dtor(&object);
---
>     zval *result, *retval;
>     SW_MAKE_STD_ZVAL(result);
>     if (status != REDIS_OK)
>     {
>         ZVAL_BOOL(result, 0);
>         zend_update_property_long(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errCode"), c->err TSRMLS_CC);
>         zend_update_property_string(swoole_redis_class_entry_ptr, redis->object, ZEND_STRL("errMsg"), c->errstr TSRMLS_CC);
>         redis->state = SWOOLE_REDIS_STATE_CLOSED;
880,893c572
< }
< 
< static void swoole_redis_onClose(const redisAsyncContext *c,int status)
< {
< 	SWOOLE_FETCH_TSRMLS;
< 	swRedisClient *redis = c->ev.data;
< 	if (!redis)
< 	{
< 		return ;
< 	}
< 
<     redis->state = SWOOLE_REDIS_STATE_CLOSED;
< 
<     if (!redis->released)
---
>     else
895c574,575
<     	swoole_redis_close(redis);
---
>         ZVAL_BOOL(result, 1);
>         redis->state = SWOOLE_REDIS_STATE_READY;
897d576
< }
899,901c578,581
< static void swoole_redis_close(swRedisClient* redis)
< {
< 	SWOOLE_FETCH_TSRMLS;
---
>     zval **args[2];
>     zval *callback = redis->connect_callback;
>     args[0] = &redis->object;
>     args[1] = &result;
903,912c583
< 	if (redis && redis->timer_id > 0)
< 	{
< 		long timer_id = redis->timer_id;
< 		redis->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
<     redis->context = NULL;
< 	redis->state = SWOOLE_REDIS_STATE_CLOSED;
<     if (redis->object && redis->onClose)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 2, args, 0, NULL TSRMLS_CC) != SUCCESS)
914,929c585
<         zval *retval;
<         zval **args[1];
<         args[0] = &redis->object;
<         zval* callback = redis->onClose;
<         redis->released = 1;
<         if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 1, args, 0, NULL TSRMLS_CC) != SUCCESS)
<         {
<             swWarn("swoole_async_redis close_callback handler error.");
<         }
< 
<         if (retval != NULL)
<         {
<             sw_zval_ptr_dtor(&retval);
<         }
< 
<         redis->released = 0;
---
>         swoole_php_fatal_error(E_WARNING, "swoole_async_mysql callback handler error.");
931,933c587
< 
< 	redis_client_free_cb(redis);
<     if (redis->object)
---
>     if (retval != NULL)
935,937c589
<     	zval* object = redis->object;
<     	redis->object = NULL;
<     	sw_zval_ptr_dtor(&object);
---
>         sw_zval_ptr_dtor(&retval);
938a591,592
>     sw_zval_ptr_dtor(&result);
>     sw_zval_ptr_dtor(&callback);
941,953c595
< static int swoole_redis_onError(swReactor *reactor, swEvent *event)
< {
<     SWOOLE_FETCH_TSRMLS;
<     swRedisClient *redis = event->socket->object;
< //    int status = REDIS_ERR;
< 
< //    swoole_redis_conResult(redis,status TSRMLS_CC);
<     close_redis_client(redis);
<     swoole_redis_close(redis);
<     return SW_OK;
< }
< 
< static int close_redis_client(swRedisClient* redis)
---
> void swoole_redis_onClose(const redisAsyncContext *c, int status)
955,984c597,598
< 	if (redis && redis->timer_id > 0)
< 	{
< 		long timer_id = redis->timer_id;
< 		redis->timer_id = 0;
< 		swTimer_del(&SwooleG.timer,timer_id);
< 	}
< 
< 	if (redis)
< 	{
< 		if (redis->released)
< 		{
< 			return SW_ERR;
< 		}
< 		else if (redis->context && redis->state != SWOOLE_REDIS_STATE_CLOSED)
< 		{
< 			redis->released = 1;
< 			redisAsyncDisconnect(redis->context);
< 			redis->released = 0;
< 		}
< 
< 		if (redis->fd > 0)
< 		{
< 			SwooleG.main_reactor->del(SwooleG.main_reactor,redis->fd);
< 			redis->fd = -1;
< 		}
< 
< 		return SW_OK;
< 	}
< 
< 	return SW_ERR;
---
>     swRedisClient *redis = c->ev.data;
>     redis->state = SWOOLE_REDIS_STATE_CLOSED;
990,993c604
<     if (redis->context && SwooleG.main_reactor)
<     {
<         swReactor_add_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_READ);
<     }
---
>     swReactor_add_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_READ);
999,1002c610
<     if (redis->context && SwooleG.main_reactor)
<     {
<         swReactor_del_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_READ);
<     }
---
>     swReactor_del_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_READ);
1008,1011c616
<     if (redis->context && SwooleG.main_reactor)
<     {
<         swReactor_add_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_WRITE);
<     }
---
>     swReactor_add_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_WRITE);
1017,1020c622
<     if (redis->context && SwooleG.main_reactor)
<     {
<         swReactor_del_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_WRITE);
<     }
---
>     swReactor_del_event(SwooleG.main_reactor, redis->context->c.fd, SW_EVENT_WRITE);
1026,1027c628,630
<     redis->state = SWOOLE_REDIS_STATE_CLOSED;
<     if (redis->context && SwooleG.main_reactor)
---
>     SwooleG.main_reactor->del(SwooleG.main_reactor, redis->context->c.fd);
> 
>     if (redis->close_callback)
1029,1030c632,646
<         SwooleG.main_reactor->del(SwooleG.main_reactor, redis->context->c.fd);
<         redis->fd = -1;
---
> #if PHP_MAJOR_VERSION < 7
>         TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
>         zval *retval;
>         zval **args[1];
>         args[0] = &redis->object;
> 
>         if (sw_call_user_function_ex(EG(function_table), NULL, redis->connect_callback, &retval, 1, args, 0, NULL TSRMLS_CC) != SUCCESS)
>         {
>             swoole_php_fatal_error(E_WARNING, "swoole_async_mysql callback handler error.");
>         }
>         if (retval != NULL)
>         {
>             sw_zval_ptr_dtor(&retval);
>         }
1037,1041c653
<     if (redis->context && SwooleG.main_reactor)
<     {
<         redisAsyncHandleRead(redis->context);
<     }
< 
---
>     redisAsyncHandleRead(redis->context);
1048,1051c660
<     if (redis->context && SwooleG.main_reactor)
<     {
<         redisAsyncHandleWrite(redis->context);
<     }
---
>     redisAsyncHandleWrite(redis->context);
diff -r ./zan-extension/swoole_server.c ../swoole-1.8.5-stable/swoole_server.c
18,21d17
< #include "swWork.h"
< #include "swConnection.h"
< #include "swBaseOperator.h"
< #include "swGlobalVars.h"
23,27c19
< #include "ext/standard/php_var.h"
< 
< #ifdef HAVE_PCRE
< #include <ext/spl/spl_iterators.h>
< #endif
---
> #include "Connection.h"
28a21
> #include "ext/standard/php_var.h"
35,42d27
< zend_class_entry swoole_server_ce;
< zend_class_entry *swoole_server_class_entry_ptr;
< 
< #ifdef HAVE_PCRE
< static zend_class_entry swoole_connection_iterator_ce;
< zend_class_entry *swoole_connection_iterator_class_entry_ptr;
< #endif
< 
47,224d31
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server__construct, 0, 0, 2)
<     ZEND_ARG_INFO(0, serv_host)
<     ZEND_ARG_INFO(0, serv_port)
<     ZEND_ARG_INFO(0, serv_mode)
<     ZEND_ARG_INFO(0, sock_type)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_set_oo, 0, 0, 1)
<     ZEND_ARG_INFO(0, zset)
< ZEND_END_ARG_INFO()
< 
< //for object style
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_denyRequest_oo, 0, 0, 1)
<     ZEND_ARG_INFO(0, worker_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_send_oo, 0, 0, 2)
<     ZEND_ARG_INFO(0, conn_fd)
<     ZEND_ARG_INFO(0, send_data)
<     ZEND_ARG_INFO(0, from_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendwait, 0, 0, 2)
<     ZEND_ARG_INFO(0, conn_fd)
<     ZEND_ARG_INFO(0, send_data)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_exist, 0, 0, 1)
<     ZEND_ARG_INFO(0, conn_fd)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_protect, 0, 0, 1)
<     ZEND_ARG_INFO(0, fd)
<     ZEND_ARG_INFO(0, is_protected)
< ZEND_END_ARG_INFO()
< 
< //for object style
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendto_oo, 0, 0, 2)
<     ZEND_ARG_INFO(0, ip)
<     ZEND_ARG_INFO(0, port)
<     ZEND_ARG_INFO(0, send_data)
<     ZEND_ARG_INFO(0, server_socket)
< ZEND_END_ARG_INFO()
< 
< //for object style
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendfile_oo, 0, 0, 2)
<     ZEND_ARG_INFO(0, fd)
<     ZEND_ARG_INFO(0, filename)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_close_oo, 0, 0, 1)
<     ZEND_ARG_INFO(0, fd)
<     ZEND_ARG_INFO(0, reset)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_on, 0, 0, 2)
<     ZEND_ARG_INFO(0, event_name)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_listen, 0, 0, 3)
<     ZEND_ARG_INFO(0, host)
<     ZEND_ARG_INFO(0, port)
<     ZEND_ARG_INFO(0, sock_type)
< ZEND_END_ARG_INFO()
< 
< //object style
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_task_oo, 0, 0, 2)
<     ZEND_ARG_INFO(0, data)
<     ZEND_ARG_INFO(0, worker_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_taskwait_oo, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
<     ZEND_ARG_INFO(0, timeout)
<     ZEND_ARG_INFO(0, worker_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_finish_oo, 0, 0, 1)
<     ZEND_ARG_INFO(0, data)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_reload_oo, 0, 0, 0)
<     ZEND_ARG_INFO(0, only_reload_taskworkrer)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_stop, 0, 0, 0)
<     ZEND_ARG_INFO(0, worker_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_heartbeat_oo, 0, 0, 0)
<     ZEND_ARG_INFO(0, if_close_connection)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_bind, 0, 0, 2)
<     ZEND_ARG_INFO(0, fd)
<     ZEND_ARG_INFO(0, uid)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_sendMessage, 0, 0, 2)
<     ZEND_ARG_INFO(0, msg)
<     ZEND_ARG_INFO(0, work_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_getSocket, 0, 0, 1)
<     ZEND_ARG_INFO(0, port)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_getClientInfo_oo, 0, 0, 1)
<     ZEND_ARG_INFO(0, fd)
<     ZEND_ARG_INFO(0, from_id)
<     ZEND_ARG_INFO(0, ignore_close)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_getClientList_oo, 0, 0, 2)
<     ZEND_ARG_INFO(0, start_fd)
<     ZEND_ARG_INFO(0, find_count)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_addProcess_oo, 0, 0, 1)
<     ZEND_ARG_OBJ_INFO(0, process, swoole_process, 0)
< ZEND_END_ARG_INFO()
< 
< static zend_function_entry swoole_server_methods[] = {
<     PHP_ME(swoole_server, __construct, arginfo_swoole_server__construct, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
<     PHP_ME(swoole_server, listen, arginfo_swoole_server_listen, ZEND_ACC_PUBLIC)
<     PHP_MALIAS(swoole_server, addlistener, listen, arginfo_swoole_server_listen, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, on, arginfo_swoole_server_on, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, set, arginfo_swoole_server_set_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, start, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, send, arginfo_swoole_server_send_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, sendto, arginfo_swoole_server_sendto_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, sendwait, arginfo_swoole_server_sendwait, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, exist, arginfo_swoole_server_exist, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, protect, arginfo_swoole_server_protect, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, sendfile, arginfo_swoole_server_sendfile_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, close, arginfo_swoole_server_close_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, task, arginfo_swoole_server_task_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, taskwait, arginfo_swoole_server_taskwait_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, finish, arginfo_swoole_server_finish_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, reload, arginfo_swoole_server_reload_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, shutdown, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, stop, arginfo_swoole_server_stop, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, getLastError, arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, heartbeat, arginfo_swoole_server_heartbeat_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, getClientInfo, arginfo_swoole_server_getClientInfo_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, getClientList, arginfo_swoole_server_getClientList_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, denyRequest, arginfo_swoole_server_denyRequest_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, exit, arginfo_swoole_void, ZEND_ACC_PUBLIC)
< 
< 
<     //process
<     PHP_ME(swoole_server, sendMessage, arginfo_swoole_server_sendMessage, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, addProcess, arginfo_swoole_server_addProcess_oo, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, stats, NULL, ZEND_ACC_PUBLIC)
< 
<     PHP_ME(swoole_server, getSocket, arginfo_swoole_server_getSocket, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server, bind, arginfo_swoole_server_bind, ZEND_ACC_PUBLIC)
<     {NULL, NULL, NULL}
< };
< 
< #ifdef HAVE_PCRE
< static const zend_function_entry swoole_connection_iterator_methods[] =
< {
<     PHP_ME(swoole_connection_iterator, rewind,      arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_connection_iterator, next,        arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_connection_iterator, current,     arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_connection_iterator, key,         arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_connection_iterator, valid,       arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_connection_iterator, count,       arginfo_swoole_void, ZEND_ACC_PUBLIC)
<     PHP_FE_END
< };
< #endif
< 
232,252d38
< static char *swoole_server_callback[PHP_SERVER_CALLBACK_NUM] = {
< 	"Connect",
< 	"Receive",
< 	"Close",
< 	"Packet",
< 	"Start",
< 	"Shutdown",
< 	"WorkerStart",
< 	"WorkerStop",
< 	"Task",
< 	"Finish",
< 	"WorkerError",
< 	"ManagerStart",
< 	"ManagerStop",
< 	"PipeMessage",
< 	NULL,
< 	NULL,
< 	NULL,
< 	NULL
< };
< 
258a45
> static int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC);
267d53
< static void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo);
269d54
< 
272c57
< 
---
> static void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo);
278,329d62
< static int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC);
< static int php_swoole_task_setBuf(zval *data,swEventData *buf TSRMLS_CC);
< 
< void swoole_server_init(int module_number TSRMLS_DC)
< {
< 	SWOOLE_INIT_CLASS_ENTRY(swoole_server_ce, "swoole_server", "Swoole\\Server", swoole_server_methods);
< 	swoole_server_class_entry_ptr = zend_register_internal_class(&swoole_server_ce TSRMLS_CC);
< 
< #ifdef HAVE_PCRE
<     SWOOLE_INIT_CLASS_ENTRY(swoole_connection_iterator_ce, "swoole_connection_iterator", "Swoole\\ConnectionIterator",  swoole_connection_iterator_methods);
<     swoole_connection_iterator_class_entry_ptr = zend_register_internal_class(&swoole_connection_iterator_ce TSRMLS_CC);
<     zend_class_implements(swoole_connection_iterator_class_entry_ptr TSRMLS_CC, 2, spl_ce_Iterator, spl_ce_Countable);
< #endif
< 
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("master_pid"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("manager_pid"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("worker_pid"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_bool(swoole_server_class_entry_ptr,ZEND_STRL("taskworker"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_bool(swoole_server_class_entry_ptr,ZEND_STRL("pid"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("id"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 
< 	zend_declare_property_stringl(swoole_server_class_entry_ptr,ZEND_STRL("host"),"",0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("port"),-1,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("type"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_long(swoole_server_class_entry_ptr,ZEND_STRL("mode"),0,ZEND_ACC_PUBLIC TSRMLS_CC);
< 
< 	zend_declare_property_null(swoole_server_class_entry_ptr,ZEND_STRL("setting"),ZEND_ACC_PUBLIC TSRMLS_CC);
< 	zend_declare_property_null(swoole_server_class_entry_ptr,ZEND_STRL("ports"),ZEND_ACC_PUBLIC TSRMLS_CC);
< 
< 	char property_name[128] = {0};
< 	memcpy(property_name, "on", 2);
< 	int index;
< 	for (index = 0; index < PHP_SERVER_CALLBACK_NUM; index++)
< 	{
< 		if (NULL == swoole_server_callback[index])
< 		{
< 			continue;
< 		}
< 
< 		int l_property_name = 2;
< 		int callbackLen = strlen(swoole_server_callback[index]);
< 		memcpy(property_name + l_property_name, swoole_server_callback[index],callbackLen);
< 		l_property_name += callbackLen;
< 		property_name[l_property_name] = '\0';
< 		zend_declare_property_null(swoole_server_class_entry_ptr,property_name,l_property_name,ZEND_ACC_PUBLIC TSRMLS_CC);
< 	}
< 
< #ifdef HAVE_PCRE
< 	zend_declare_property_null(swoole_server_class_entry_ptr,ZEND_STRL("connections"),ZEND_ACC_PUBLIC TSRMLS_CC);
< #endif
< }
331c64
< void php_swoole_get_recv_data(zval *zdata, swEventData *req, char *header, uint32_t header_length TSRMLS_DC)
---
> zval *php_swoole_get_recv_data(zval *zdata, swEventData *req TSRMLS_DC)
334c67
<     int data_len = 0;
---
>     int data_len;
340a74
> 
359,371c93,100
<     if (header_length >= data_len)
< 	{
< 		SW_ZVAL_STRING(zdata, "", 1);
< 	}
< 	else
< 	{
< 		SW_ZVAL_STRINGL(zdata, data_ptr + header_length, data_len - header_length, 1);
< 	}
< 
< 	if (header_length > 0 && header)
< 	{
< 		memcpy(header, data_ptr, header_length);
< 	}
---
>     if (SwooleG.serv->packet_mode == 1)
>     {
>         SW_ZVAL_STRINGL(zdata, data_ptr + 4, data_len - 4, 1);
>     }
>     else
>     {
>         SW_ZVAL_STRINGL(zdata, data_ptr, data_len, 1);
>     }
380c109
< 
---
>     return zdata;
385,388c114
< 	if (!zdata)
< 	{
< 		return 0;
< 	}
---
>     int length;
390d115
<     int length = -1;
397d121
< 
401c125
<             swWarn("swoole_buffer object is empty.");
---
>             swoole_php_fatal_error(E_WARNING, "swoole_buffer object is empty.");
404d127
< 
410c133
< convert:
---
>         convert:
418,420c141,142
<         swWarn("send data max_size is %d.", SwooleG.serv->buffer_output_size);
<         *str = NULL;
<         length = -1;
---
>         swoole_php_fatal_error(E_WARNING, "send data max_size is %d.", SwooleG.serv->buffer_output_size);
>         return SW_ERR;
425a148,275
> static sw_inline int php_swoole_check_task_param(int dst_worker_id TSRMLS_DC)
> {
>     if (SwooleG.task_worker_num < 1)
>     {
>         swoole_php_fatal_error(E_WARNING, "Task method cannot use, Please set task_worker_num.");
>         return SW_ERR;
>     }
> 
>     if (dst_worker_id >= SwooleG.task_worker_num)
>     {
>         swoole_php_fatal_error(E_WARNING, "worker_id must be less than serv->task_worker_num.");
>         return SW_ERR;
>     }
> 
>     if (!swIsWorker())
>     {
>         swoole_php_fatal_error(E_WARNING, "The method can only be used in the worker process.");
>         return SW_ERR;
>     }
> 
>     return SW_OK;
> }
> 
> static sw_inline zval* php_swoole_server_get_callback(swServer *serv, int server_fd, int event_type)
> {
>     swListenPort *port = serv->connection_list[server_fd].object;
>     swoole_server_port_property *property = port->ptr;
>     if (!property)
>     {
>         return php_sw_server_callbacks[event_type];
>     }
>     zval *callback = property->callbacks[event_type];
>     if (!callback)
>     {
>         return php_sw_server_callbacks[event_type];
>     }
>     else
>     {
>         return callback;
>     }
> }
> 
> static zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC)
> {
>     zval *result_data, *result_unserialized_data;
>     char *result_data_str;
>     int result_data_len = 0;
>     php_unserialize_data_t var_hash;
> 
>     int data_len;
>     char *data_str = NULL;
> 
>     /**
>      * Large result package
>      */
>     if (swTask_type(task_result) & SW_TASK_TMPFILE)
>     {
>         swTaskWorker_large_unpack(task_result, emalloc, data_str, data_len);
>         /**
>          * unpack failed
>          */
>         if (data_len == -1)
>         {
>             if (data_str)
>             {
>                 efree(data_str);
>             }
>             return NULL;
>         }
>         result_data_str = data_str;
>         result_data_len = data_len;
>     }
>     else
>     {
>         result_data_str = task_result->data;
>         result_data_len = task_result->info.len;
>     }
> 
>     if (swTask_type(task_result) & SW_TASK_SERIALIZE)
>     {
>         PHP_VAR_UNSERIALIZE_INIT(var_hash);
>         SW_ALLOC_INIT_ZVAL(result_unserialized_data);
> 
>         if (sw_php_var_unserialize(&result_unserialized_data, (const unsigned char **) &result_data_str,
>                 (const unsigned char *) (result_data_str + result_data_len), &var_hash TSRMLS_CC))
>         {
>             result_data = result_unserialized_data;
>         }
>         else
>         {
>             SW_MAKE_STD_ZVAL(result_data);
>             SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);
>         }
>         PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
>     }
>     else
>     {
>         SW_ALLOC_INIT_ZVAL(result_data);
>         SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);
>     }
>     if (data_str)
>     {
>         efree(data_str);
>     }
>     return result_data;
> }
> 
> static zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC)
> {
>     zval *port_object;
>     SW_ALLOC_INIT_ZVAL(port_object);
>     object_init_ex(port_object, swoole_server_port_class_entry_ptr);
>     server_port_list.zobjects[server_port_list.num++] = port_object;
> 
>     swoole_server_port_property *property = emalloc(sizeof(swoole_server_port_property));
>     bzero(property, sizeof(swoole_server_port_property));
>     swoole_set_property(port_object, 0, property);
>     swoole_set_object(port_object, port);
> 
>     zend_update_property_string(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("host"), port->host TSRMLS_CC);
>     zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("port"), port->port TSRMLS_CC);
>     zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("type"), port->type TSRMLS_CC);
> 
>     add_next_index_zval(server_port_list.zports, port_object);
> 
>     return port_object;
> }
> 
428c278,280
<     /// create swoole server
---
>     /**
>      * create swoole server
>      */
435,436c287
<     swTrace("Create swoole_server host=%s, port=%d, mode=%d, type=%d", serv->listen_list->host,
<     				(int) serv->listen_list->port, serv->factory_mode, (int) serv->listen_list->type);
---
>     swTrace("Create swoole_server host=%s, port=%d, mode=%d, type=%d", serv->listen_list->host, (int) serv->listen_list->port, serv->factory_mode, (int) serv->listen_list->type);
438c289,291
<     /// Master Process ID
---
>     /**
>      * Master Process ID
>      */
444,449c297,299
<       	zval* tmp = NULL;
<         SW_MAKE_STD_ZVAL(tmp);
<         array_init(tmp);
<         zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL("setting"), tmp TSRMLS_CC);
<         zsetting = sw_zend_read_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL("setting"), 1 TSRMLS_CC);
<         sw_zval_ptr_dtor(&tmp);
---
>         SW_MAKE_STD_ZVAL(zsetting);
>         array_init(zsetting);
>         zend_update_property(swoole_server_class_entry_ptr, zobject, ZEND_STRL("setting"), zsetting TSRMLS_CC);
473,474c323,328
<     int index = 0;
<     for (index = 1; index < server_port_list.num; index++)
---
>     int i;
>     zval *retval = NULL;
>     zval *port_object;
>     zval *port_setting;
> 
>     for (i = 1; i < server_port_list.num; i++)
476,478c330,331
<     	zval *port_object = server_port_list.zobjects[index];
<     	zval *port_setting = sw_zend_read_property(swoole_server_port_class_entry_ptr,
<     												port_object, ZEND_STRL("setting"), 1 TSRMLS_CC);
---
>         port_object = server_port_list.zobjects[i];
>         port_setting = sw_zend_read_property(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("setting"), 1 TSRMLS_CC);
480,481c333
<         if ((port_object && !ZVAL_IS_NULL(port_object)) &&
<         				(!port_setting || ZVAL_IS_NULL(port_setting)))
---
>         if (port_setting == NULL || ZVAL_IS_NULL(port_setting))
485d336
<             zval *retval = NULL;
487c338
<             if (retval)
---
>             if (retval != NULL)
495c346
< zval* php_swoole_server_get_callback(swServer *serv, int server_fd, int event_type)
---
> void php_swoole_register_callback(swServer *serv)
497,499c348,351
<     swListenPort *port = serv->connection_list[server_fd].object;
<     swoole_server_port_property *property = (port)? port->ptr:NULL;
<     if (event_type >= PHP_SERVER_PORT_CALLBACK_NUM || !property)
---
>     /*
>      * optional callback
>      */
>     if (php_sw_server_callbacks[SW_SERVER_CB_onStart] != NULL)
501c353
<         return php_sw_server_callbacks[event_type];
---
>         serv->onStart = php_swoole_onStart;
502a355,359
>     serv->onShutdown = php_swoole_onShutdown;
>     /**
>      * require callback, set the master/manager/worker PID
>      */
>     serv->onWorkerStart = php_swoole_onWorkerStart;
504,505c361
<     zval *callback = property->callbacks[event_type];
<     if (!callback)
---
>     if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop] != NULL)
507c363
<         return php_sw_server_callbacks[event_type];
---
>         serv->onWorkerStop = php_swoole_onWorkerStop;
509c365,368
<     else
---
>     /**
>      * UDP Packet
>      */
>     if (php_sw_server_callbacks[SW_SERVER_CB_onPacket] != NULL)
511c370,397
<         return callback;
---
>         serv->onPacket = php_swoole_onPacket;
>     }
>     /**
>      * Task Worker
>      */
>     if (php_sw_server_callbacks[SW_SERVER_CB_onTask] != NULL)
>     {
>         serv->onTask = php_swoole_onTask;
>     }
>     if (php_sw_server_callbacks[SW_SERVER_CB_onFinish] != NULL)
>     {
>         serv->onFinish = php_swoole_onFinish;
>     }
>     if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerError] != NULL)
>     {
>         serv->onWorkerError = php_swoole_onWorkerError;
>     }
>     if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStart] != NULL)
>     {
>         serv->onManagerStart = php_swoole_onManagerStart;
>     }
>     if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStop] != NULL)
>     {
>         serv->onManagerStop = php_swoole_onManagerStop;
>     }
>     if (php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage] != NULL)
>     {
>         serv->onPipeMessage = php_swoole_onPipeMessage;
515c401
< static sw_inline int php_swoole_check_task_param(int dst_worker_id TSRMLS_DC)
---
> static int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC)
517,521c403,408
<     if (SwooleG.task_worker_num < 1)
<     {
<         swWarn("Task method cannot use, Please set task_worker_num.");
<         return SW_ERR;
<     }
---
>     int flags = 0;
>     smart_str serialized_data = {0};
>     php_serialize_data_t var_hash;
>     char *data_str;
>     int data_len = 0;
>     int ret;
523c410,411
<     if (dst_worker_id >= SwooleG.task_worker_num)
---
>     //need serialize
>     if (SW_Z_TYPE_P(data) != IS_STRING)
525,526c413,424
<         swWarn("worker_id must be less than serv->task_worker_num.");
<         return SW_ERR;
---
>         //serialize
>         flags |= SW_TASK_SERIALIZE;
>         PHP_VAR_SERIALIZE_INIT(var_hash);
>         sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);
>         PHP_VAR_SERIALIZE_DESTROY(var_hash);
> #if PHP_MAJOR_VERSION<7
>         data_str = serialized_data.c;
>         data_len = serialized_data.len;
> #else
>         data_str = serialized_data.s->val;
>         data_len = serialized_data.s->len;
> #endif
528,530c426
< 
<     /// should be TaskWorker
<     if (!swIsWorker())
---
>     else
532,533c428,429
<         swWarn("The method can only be used in the worker process.");
<         return SW_ERR;
---
>         data_str = Z_STRVAL_P(data);
>         data_len = Z_STRLEN_P(data);
536c432,435
<     return SW_OK;
---
>     ret = swTaskWorker_finish(serv, data_str, data_len, flags);
> 
>     smart_str_free(&serialized_data);
>     return ret;
541c440,442
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
543,552c444,447
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
< 
< 	zval *zserv = (zval *) serv->ptr2;
< 	zval *zworker_id = NULL;
< 	SW_MAKE_STD_ZVAL(zworker_id);
< 	ZVAL_LONG(zworker_id, (long) req->info.from_id);
---
>     zval *zserv = (zval *) serv->ptr2;
>     zval *zworker_id;
>     zval *zdata;
>     zval *retval = NULL;
554c449,450
<     zval *zdata = php_swoole_get_task_result(req TSRMLS_CC);
---
>     SW_MAKE_STD_ZVAL(zworker_id);
>     SW_MAKE_STD_ZVAL(zdata);
557,563c453,486
< 	args[0] = &zserv;
< 	args[1] = &zworker_id;
< 	args[2] = &zdata;
< 
< 	zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL, callback,
<     									&retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)
---
> 
>     ZVAL_LONG(zworker_id, (long) req->info.from_id);
> 
>     if (swTask_type(req) & SW_TASK_TMPFILE)
>     {
>         int data_len;
>         char *buf = NULL;
>         swTaskWorker_large_unpack(req, emalloc, buf, data_len);
> 
>         /**
>          * unpack failed
>          */
>         if (data_len == -1)
>         {
>             if (buf)
>             {
>                 efree(buf);
>             }
>             return;
>         }
>         SW_ZVAL_STRINGL(zdata, buf, data_len, 0);
>     }
>     else
>     {
>         SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);
>     }
> 
>     args[0] = &zserv;
>     args[1] = &zworker_id;
>     args[2] = &zdata;
> 
>     swTrace("PipeMessage: fd=%d|len=%d|from_id=%d|data=%s\n", req->info.fd, req->info.len, req->info.from_id, req->data);
> 
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage], &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)
565c488
<         swWarn("swoole_server: onPipeMessage handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onPipeMessage handler error");
574c497
<     sw_zval_free(zdata);
---
>     sw_zval_ptr_dtor(&zdata);
576c499
<     if (retval)
---
>     if (retval != NULL)
582c505
< static void php_swoole_onStart(swServer *serv)
---
> int php_swoole_onReceive(swServer *serv, swEventData *req)
584c507,509
< 	SWOOLE_FETCH_TSRMLS;
---
>     swFactory *factory = &serv->factory;
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[4];
586,590c511,514
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onStart];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
---
>     zval *zfd;
>     zval *zfrom_id;
>     zval *zdata;
>     zval *retval = NULL;
592c516
<     pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;
---
>     zval *callback;
594,596c518,520
<     zval *zserv = (zval *) serv->ptr2;
<     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("master_pid"), SwooleGS->master_pid TSRMLS_CC);
<     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("manager_pid"), manager_pid TSRMLS_CC);
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
598,599c522,524
<     zval **args[1];
<     args[0] = &zserv;
---
>     //UDP使用from_id作为port,fd做为ip
>     php_swoole_udp_t udp_info;
>     swDgramPacket *packet;
601,605c526,590
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback,
<     									&retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
<     {
<         swWarn("swoole_server: onStart handler error");
---
>     SW_MAKE_STD_ZVAL(zfd);
>     SW_MAKE_STD_ZVAL(zfrom_id);
>     SW_MAKE_STD_ZVAL(zdata);
> 
>     //dgram
>     if (swEventData_is_dgram(req->info.type))
>     {
>         swString *buffer = swWorker_get_buffer(serv, req->info.from_id);
>         packet = (swDgramPacket*) buffer->str;
> 
>         //udp ipv4
>         if (req->info.type == SW_EVENT_UDP)
>         {
>             udp_info.from_fd = req->info.from_fd;
>             udp_info.port = packet->port;
>             memcpy(&udp_server_socket, &udp_info, sizeof(udp_server_socket));
>             factory->last_from_id = udp_server_socket;
>             swTrace("SendTo: from_id=%d|from_fd=%d", (uint16_t) req->info.from_id, req->info.from_fd);
>             SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);
>             ZVAL_LONG(zfrom_id, (long ) udp_server_socket);
>             ZVAL_LONG(zfd, (long ) packet->addr.v4.s_addr);
>         }
>         //udp ipv6
>         else if (req->info.type == SW_EVENT_UDP6)
>         {
>             udp_info.from_fd = req->info.from_fd;
>             udp_info.port = packet->port;
>             memcpy(&dgram_server_socket, &udp_info, sizeof(udp_server_socket));
>             factory->last_from_id = dgram_server_socket;
> 
>             swTrace("SendTo: from_id=%d|from_fd=%d", (uint16_t) req->info.from_id, req->info.from_fd);
> 
>             ZVAL_LONG(zfrom_id, (long ) dgram_server_socket);
>             char tmp[INET6_ADDRSTRLEN];
>             inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));
>             SW_ZVAL_STRING(zfd, tmp, 1);
>             SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);
>         }
>         //unix dgram
>         else
>         {
>             SW_ZVAL_STRINGL(zfd, packet->data, packet->addr.un.path_length, 1);
>             SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);
>             ZVAL_LONG(zfrom_id, (long ) req->info.from_fd);
>             dgram_server_socket = req->info.from_fd;
>         }
>     }
>     //stream
>     else
>     {
>         ZVAL_LONG(zfrom_id, (long ) req->info.from_id);
>         ZVAL_LONG(zfd, (long ) req->info.fd);
>         zdata = php_swoole_get_recv_data(zdata, req TSRMLS_CC);
>     }
> 
>     callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onReceive);
> 
>     args[0] = &zserv;
>     args[1] = &zfd;
>     args[2] = &zfrom_id;
>     args[3] = &zdata;
> 
>     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onReceive handler error");
611,612c596,599
< 
<     if (retval)
---
>     sw_zval_ptr_dtor(&zfd);
>     sw_zval_ptr_dtor(&zfrom_id);
>     sw_zval_ptr_dtor(&zdata);
>     if (retval != NULL)
616,647c603
< }
< 
< static void php_swoole_onShutdown(swServer *serv)
< {
< 
< 	SWOOLE_FETCH_TSRMLS;
< 
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onShutdown];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
< 
<     zval *zserv = (zval *) serv->ptr2;
< 	zval **args[1];
< 	args[0] = &zserv;
< 
< 	zval *retval = NULL;
< 	if (sw_call_user_function_ex(EG(function_table), NULL,callback,
< 										&retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
< 	{
< 		swWarn("swoole_server: onShutdown handler error");
< 	}
< 	if (EG(exception))
< 	{
< 		zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 	}
< 
< 	if (retval)
< 	{
< 		sw_zval_ptr_dtor(&retval);
< 	}
---
>     return SW_OK;
652c608,609
< 	SWOOLE_FETCH_TSRMLS;
---
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[3];
654,659c611,614
<     zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onPacket);
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		swoole_php_fatal_error(E_WARNING, "onPacket callback is null.");
< 		return SW_OK;
< 	}
---
>     zval *zdata;
>     zval *zaddr;
>     zval *retval = NULL;
>     swDgramPacket *packet;
661,662c616,618
< 	zval *zdata = NULL;
< 	zval *zaddr = NULL;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
666d621
< 
667a623,626
> 
>     swString *buffer = swWorker_get_buffer(serv, req->info.from_id);
>     packet = (swDgramPacket*) buffer->str;
> 
669a629,630
>     zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onPacket);
> 
671,672d631
<     swString *buffer = swWorker_get_buffer(serv, req->info.from_id);
<     swDgramPacket *packet = (swDgramPacket*) buffer->str;
675,677c634,637
<         char tmp[SW_IP_MAX_LENGTH] = {0};
<         inet_ntop(AF_INET, &packet->addr.v4, tmp, sizeof(tmp));
<         sw_add_assoc_string(zaddr, "address", tmp, 1);
---
>         struct in_addr sin_addr;
>         sin_addr.s_addr = packet->addr.v4.s_addr;
>         char *address = inet_ntoa(sin_addr);
>         sw_add_assoc_string(zaddr, "address", address, 1);
684c644
<         char tmp[SW_IP_MAX_LENGTH] = {0};
---
>         char tmp[INET6_ADDRSTRLEN];
698,699d657
<     zval **args[3];
<     zval *zserv = (zval *) serv->ptr2;
703c661
<     zval *retval = NULL;
---
> 
706c664
<         swWarn("swoole_server: onPacket handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onPacket handler error");
712d669
< 
715,716c672
< 
<     if (retval)
---
>     if (retval != NULL)
720d675
< 
724c679
< static void php_swoole_onWorkerStart(swServer *serv, int worker_id)
---
> static int php_swoole_onTask(swServer *serv, swEventData *req)
725a681,682
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[4];
727c684,686
<     SWOOLE_FETCH_TSRMLS;
---
>     zval *zfd;
>     zval *zfrom_id;
>     zval *zdata;
729,732c688
<     //让请求可以开始接受
< 	if (swServer_tcp_deny_exit(serv, worker_id) < 0) {
< 		swWarn("swServer_tcp_deny_exit failed, %d.", worker_id);
< 	}
---
>     sw_atomic_fetch_sub(&SwooleStats->tasking_num, 1);
734,736c690,693
<     zval *zworker_id = NULL;
<     SW_MAKE_STD_ZVAL(zworker_id);
<     ZVAL_LONG(zworker_id, worker_id);
---
>     char *zdata_str;
>     int zdata_len;
>     zval *unserialized_zdata = NULL;
>     zval *retval = NULL;
738,741c695,697
<     zval *zserv = (zval *) serv->ptr2;
<     zval **args[2];
<     args[0] = &zserv;
<     args[1] = &zworker_id;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
743,744c699,700
<     /// update Manager Process ID property
<     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("manager_pid"), SwooleGS->manager_pid TSRMLS_CC);
---
>     SW_MAKE_STD_ZVAL(zfd);
>     ZVAL_LONG(zfd, (long) req->info.fd);
746,747c702,703
<     /// update Worker ID property
<     zend_update_property(swoole_server_class_entry_ptr, zserv, ZEND_STRL("worker_id"), zworker_id TSRMLS_CC);
---
>     SW_MAKE_STD_ZVAL(zfrom_id);
>     ZVAL_LONG(zfrom_id, (long) req->info.from_id);
749,751c705
<     /// update Is a task worker property
<     int isTaskWork = (worker_id >= serv->worker_num)? 1:0;
<     zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL("taskworker"), isTaskWork TSRMLS_CC);
---
>     SW_MAKE_STD_ZVAL(zdata);
753,754c707,710
<     /// Worker Process ID
<     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("worker_pid"), getpid() TSRMLS_CC);
---
>     if (swTask_type(req) & SW_TASK_TMPFILE)
>     {
>         int data_len;
>         char *buf = NULL;
756,762c712
<     ///Have not set the event callback
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
<     	sw_zval_ptr_dtor(&zworker_id);
< 		return;
< 	}
---
>         swTaskWorker_large_unpack(req, emalloc, buf, data_len);
764,772c714,725
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback,
<     									&retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
<     {
<         swWarn("swoole_server: onWorkerStart handler error");
<     }
<     if (EG(exception))
<     {
<         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
---
>         /**
>          * unpack failed
>          */
>         if (data_len == -1)
>         {
>             if (buf)
>             {
>                 efree(buf);
>             }
>             return SW_OK;
>         }
>         SW_ZVAL_STRINGL(zdata, buf, data_len, 0);
774,775c727
< 
<     if (retval)
---
>     else
777c729
<         sw_zval_ptr_dtor(&retval);
---
>         SW_ZVAL_STRINGL(zdata, req->data, req->info.len, 1);
780,793c732,735
<     sw_zval_ptr_dtor(&zworker_id);
< }
< 
< static void php_swoole_onWorkerStop(swServer *serv, int worker_id)
< {
< 
<     SWOOLE_FETCH_TSRMLS;
< 
<     if (SwooleWG.shutdown)
< 	{
< 		return;
< 	}
< 
< 	SwooleWG.shutdown = 1;
---
>     args[0] = &zserv;
>     args[1] = &zfd;
>     args[2] = &zfrom_id;
>     args[3] = &zdata;
795,799c737,739
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
---
> #if PHP_MAJOR_VERSION >= 7
>     zval stack_unserialized_zdata;
> #endif
801,803c741,743
< 	zval *zworker_id = NULL;
< 	SW_MAKE_STD_ZVAL(zworker_id);
< 	ZVAL_LONG(zworker_id, worker_id);
---
>     if (swTask_type(req) & SW_TASK_SERIALIZE)
>     {
>         php_unserialize_data_t var_hash;
805c745,747
< 	zval *zobject = (zval *) serv->ptr2;
---
>         PHP_VAR_UNSERIALIZE_INIT(var_hash);
>         zdata_str = Z_STRVAL_P(zdata);
>         zdata_len = Z_STRLEN_P(zdata);
807,809c749,754
< 	zval **args[2];
<     args[0] = &zobject;
<     args[1] = &zworker_id;
---
> #if PHP_MAJOR_VERSION < 7
>         MAKE_STD_ZVAL(unserialized_zdata);
> #else
>         unserialized_zdata = &stack_unserialized_zdata;
>         bzero(unserialized_zdata, sizeof(zval));
> #endif
811,818c756,765
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback, &retval, 2, args, 0,NULL TSRMLS_CC) == FAILURE)
<     {
<         swWarn("swoole_server: onWorkerStop handler error");
<     }
<     if (EG(exception))
<     {
<         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
---
>         if (sw_php_var_unserialize(&unserialized_zdata, (const uchar ** ) &zdata_str,
>                 (const uchar * ) (zdata_str + zdata_len), &var_hash TSRMLS_CC))
>         {
>             args[3] = &unserialized_zdata;
>         }
>         else
>         {
>             args[3] = &zdata;
>         }
>         PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
820,821c767
< 
<     if (retval)
---
>     else
823c769
<         sw_zval_ptr_dtor(&retval);
---
>         args[3] = &zdata;
826,873c772
<     sw_zval_ptr_dtor(&zworker_id);
< 
<     shutdown_memory_manager(0, 1 TSRMLS_CC);
< }
< 
< static void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker)
< {
<     SWOOLE_FETCH_TSRMLS;
< 
<     zval *object = worker->ptr;
<     zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL("id"), SwooleWG.id TSRMLS_CC);
< 
<     php_swoole_process_start(worker, object TSRMLS_CC);
< }
< 
< static int php_swoole_onTask(swServer *serv, swEventData *req)
< {
< 
<     SWOOLE_FETCH_TSRMLS;
< 
<     sw_atomic_fetch_sub(&SwooleStats->tasking_num, 1);
< 
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onTask];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return SW_OK;
< 	}
< 
<     zval *zfd = NULL;
<     SW_MAKE_STD_ZVAL(zfd);
<     ZVAL_LONG(zfd, (long) req->info.fd);
< 
<     zval *zfrom_id = NULL;
<     SW_MAKE_STD_ZVAL(zfrom_id);
<     ZVAL_LONG(zfrom_id, (long) req->info.from_id);
< 
<     zval* zdata = php_swoole_get_task_result(req TSRMLS_CC);
< 
<     zval **args[4];
<     zval *zserv = (zval *) serv->ptr2;
<     args[0] = &zserv;
<     args[1] = &zfd;
<     args[2] = &zfrom_id;
<     args[3] = &zdata;
< 
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback,
<     								&retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onTask], &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)
875c774
<         swWarn("swoole_server: onTask handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onTask handler error");
885c784,789
<     sw_zval_free(zdata);
---
>     sw_zval_ptr_dtor(&zdata);
> 
>     if (unserialized_zdata)
>     {
>         sw_zval_ptr_dtor(&unserialized_zdata);
>     }
889c793,796
<         if (SW_Z_TYPE_P(retval) != IS_NULL)  php_swoole_task_finish(serv, retval TSRMLS_CC);
---
>         if (SW_Z_TYPE_P(retval) != IS_NULL)
>         {
>             php_swoole_task_finish(serv, retval TSRMLS_CC);
>         }
896,897c803
< 
< static void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo)
---
> static int php_swoole_onFinish(swServer *serv, swEventData *req)
898a805,806
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[3];
900,910c808,810
<     SWOOLE_FETCH_TSRMLS;
< 
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onWorkerError];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
< 
< 	zval *zworker_id = NULL;
< 	SW_MAKE_STD_ZVAL(zworker_id);
< 	ZVAL_LONG(zworker_id, worker_id);
---
>     zval *ztask_id;
>     zval *zdata;
>     zval *retval = NULL;
912,914c812,814
< 	zval *zworker_pid = NULL;
< 	SW_MAKE_STD_ZVAL(zworker_pid);
< 	ZVAL_LONG(zworker_pid, worker_pid);
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
916,918c816,817
< 	zval *zexit_code = NULL;
< 	SW_MAKE_STD_ZVAL(zexit_code);
< 	ZVAL_LONG(zexit_code, exit_code);
---
>     SW_MAKE_STD_ZVAL(ztask_id);
>     ZVAL_LONG(ztask_id, (long) req->info.fd);
920,922c819
< 	zval *zsigno = NULL;
< 	SW_MAKE_STD_ZVAL(zsigno);
< 	ZVAL_LONG(zsigno, signo);
---
>     zdata = php_swoole_get_task_result(req TSRMLS_CC);
924c821,823
< 	zval *zobject = (zval *) serv->ptr2;
---
>     args[0] = &zserv;
>     args[1] = &ztask_id;
>     args[2] = &zdata;
926,931c825
< 	zval **args[5];
<     args[0] = &zobject;
<     args[1] = &zworker_id;
<     args[2] = &zworker_pid;
<     args[3] = &zexit_code;
<     args[4] = &zsigno;
---
>     //swTraceLog(60, "req: fd=%d|len=%d|from_id=%d|data=%s\n", req->info.fd, req->info.len, req->info.from_id, req->data);
933,935c827
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback,
<     										&retval, 5, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onFinish], &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)
937c829
<         swWarn("swoole_server: onWorkerError handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onFinish handler error");
939d830
< 
944,950c835,837
< 
<     sw_zval_ptr_dtor(&zworker_id);
<     sw_zval_ptr_dtor(&zworker_pid);
<     sw_zval_ptr_dtor(&zexit_code);
<     sw_zval_ptr_dtor(&zsigno);
< 
<     if (retval)
---
>     sw_zval_ptr_dtor(&ztask_id);
>     sw_zval_ptr_dtor(&zdata);
>     if (retval != NULL)
953a841
>     return SW_OK;
956c844
< static int php_swoole_onFinish(swServer *serv, swEventData *req)
---
> static void php_swoole_onStart(swServer *serv)
957a846,848
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
959c850,852
<     SWOOLE_FETCH_TSRMLS;
---
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[1];
>     zval *retval = NULL;
961,965c854
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onFinish];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return SW_OK;
< 	}
---
>     pid_t manager_pid = serv->factory_mode == SW_MODE_PROCESS ? SwooleGS->manager_pid : 0;
967,969c856,857
<     zval *ztask_id = NULL;
<     SW_MAKE_STD_ZVAL(ztask_id);
<     ZVAL_LONG(ztask_id, (long) req->info.fd);
---
>     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("master_pid"), SwooleGS->master_pid TSRMLS_CC);
>     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("manager_pid"), manager_pid TSRMLS_CC);
971,973d858
<     zval * zdata = php_swoole_get_task_result(req TSRMLS_CC);
<     zval **args[3];
<     zval *zserv = (zval *) serv->ptr2;
975,976c860
<     args[1] = &ztask_id;
<     args[2] = &zdata;
---
>     sw_zval_add_ref(&zserv);
978,980c862
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback,
<     									&retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
982c864
<         swWarn("swoole_server: onFinish handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onStart handler error");
988,992c870
< 
<     sw_zval_ptr_dtor(&ztask_id);
<     sw_zval_free(zdata);
< 
<     if (retval)
---
>     if (retval != NULL)
996,997d873
< 
<     return SW_OK;
1002c878,884
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[1];
>     zval *retval = NULL;
1006d887
<     zval *zserv = (zval *) serv->ptr2;
1010,1016d890
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onManagerStart];
< 	if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
< 
<     zval **args[1];
1017a892
>     sw_zval_add_ref(&zserv);
1019,1020c894
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStart], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
1022c896
<         swWarn("swoole_server: onManagerStart handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onManagerStart handler error");
1024d897
< 
1029,1030c902
< 
<     if (retval)
---
>     if (retval != NULL)
1038,1044c910,912
<     SWOOLE_FETCH_TSRMLS;
<     zval* callback = php_sw_server_callbacks[SW_SERVER_CB_onManagerStop];
<     if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
< 
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
1046a915,916
>     zval *retval = NULL;
> 
1047a918
>     sw_zval_add_ref(&zserv);
1049,1050c920
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL,callback , &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onManagerStop], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
1052c922
<         swWarn("swoole_server: onManagerStop handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onManagerStop handler error");
1058,1059c928
< 
<     if (retval)
---
>     if (retval != NULL)
1065c934
< static zval* php_swoole_server_add_port(swListenPort *port TSRMLS_DC)
---
> static void php_swoole_onShutdown(swServer *serv)
1067,1084c936,938
<     zval *port_object = NULL;
<     SW_ALLOC_INIT_ZVAL(port_object);
<     object_init_ex(port_object, swoole_server_port_class_entry_ptr);
<     server_port_list.zobjects[server_port_list.num++] = port_object;
< 
<     swoole_server_port_property *property = emalloc(sizeof(swoole_server_port_property));
<     bzero(property, sizeof(swoole_server_port_property));
<     swoole_set_property(port_object, swoole_property_common, property);
<     swoole_set_object(port_object, port);
< 
<     zend_update_property_string(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("host"), port->host TSRMLS_CC);
<     zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("port"), port->port TSRMLS_CC);
<     zend_update_property_long(swoole_server_port_class_entry_ptr, port_object, ZEND_STRL("type"), port->type TSRMLS_CC);
< 
<     add_next_index_zval(server_port_list.zports, port_object);
< 
<     return port_object;
< }
---
>     zval *zserv = (zval *) serv->ptr2;
>     zval **args[1];
>     zval *retval = NULL;
1086,1090c940,941
< static zval* php_swoole_get_task_result(swEventData *task_result TSRMLS_DC)
< {
<     zval *result_data = NULL;
<     char *result_data_str = NULL;
<     int result_data_len = 0;
---
>     args[0] = &zserv;
>     sw_zval_add_ref(&zserv);
1092,1093c943,945
<     int data_len = -1;
<     char *data_str = NULL;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
1095,1096c947
<     /// Large result package
<     if (swTask_type(task_result) & SW_TASK_TMPFILE)
---
>     if (php_sw_server_callbacks[SW_SERVER_CB_onShutdown] != NULL)
1098,1101c949
<         swTaskWorker_large_unpack(task_result, emalloc, data_str, data_len);
< 
<         /// unpack failed
<         if (data_len <= 0 || !data_str)
---
>         if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onShutdown], &retval, 1, args, 0, NULL TSRMLS_CC) == FAILURE)
1103c951
<         	goto result;
---
>             swoole_php_fatal_error(E_WARNING, "swoole_server: onShutdown handler error");
1105,1123c953
< 
<         result_data_str = data_str;
<         result_data_len = data_len;
<     }
<     else
<     {
<         result_data_str = task_result->data;
<         result_data_len = task_result->info.len;
<     }
< 
<     if (swTask_type(task_result) & SW_TASK_SERIALIZE)
<     {
<     	php_unserialize_data_t var_hash;
<         PHP_VAR_UNSERIALIZE_INIT(var_hash);
<         zval *result_unserialized_data = NULL;
<         SW_ALLOC_INIT_ZVAL(result_unserialized_data);
< 
<         if (sw_php_var_unserialize(&result_unserialized_data, (const unsigned char **) &result_data_str,
<                 (const unsigned char *) (result_data_str + result_data_len), &var_hash TSRMLS_CC))
---
>         if (EG(exception))
1125c955
<             result_data = result_unserialized_data;
---
>             zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
1127c957
<         else
---
>         if (retval != NULL)
1129,1131c959
<         	sw_zval_free(result_unserialized_data);
<         	SW_ALLOC_INIT_ZVAL(result_data);
<             SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);
---
>             sw_zval_ptr_dtor(&retval);
1133,1145d960
< 
<         PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
<     }
<     else
<     {
<     	SW_ALLOC_INIT_ZVAL(result_data);
<         SW_ZVAL_STRINGL(result_data, result_data_str, result_data_len, 1);
<     }
< 
< result:
<     if (data_str)
<     {
<         swoole_efree(data_str);
1147,1148d961
< 
<     return result_data;
1151c964
< static int php_swoole_task_finish(swServer *serv, zval *data TSRMLS_DC)
---
> static void php_swoole_onWorkerStart(swServer *serv, int worker_id)
1153,1167c966,969
<     char *data_str = NULL;
<     int data_len = 0;
< 
<     //need serialize
<     int flags = 0;
<     smart_str serialized_data = {0};
<     if (SW_Z_TYPE_P(data) != IS_STRING)
<     {
<         flags |= SW_TASK_SERIALIZE;
< 
<         //serialize
<         php_serialize_data_t var_hash;
<         PHP_VAR_SERIALIZE_INIT(var_hash);
<         sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);
<         PHP_VAR_SERIALIZE_DESTROY(var_hash);
---
>     zval *zserv = (zval *) serv->ptr2;
>     zval *zworker_id;
>     zval **args[2];
>     zval *retval = NULL;
1169,1174c971,972
< #if PHP_MAJOR_VERSION<7
<         data_str = serialized_data.c;
<         data_len = serialized_data.len;
< #else
<         data_str = serialized_data.s->val;
<         data_len = serialized_data.s->len;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
1176,1181d973
<     }
<     else
<     {
<         data_str = Z_STRVAL_P(data);
<         data_len = Z_STRLEN_P(data);
<     }
1183,1186c975,976
<     int ret = swTaskWorker_finish(serv, data_str, data_len, flags);
<     smart_str_free(&serialized_data);
<     return ret;
< }
---
>     SW_MAKE_STD_ZVAL(zworker_id);
>     ZVAL_LONG(zworker_id, worker_id);
1188,1210c978,980
< static int php_swoole_task_setBuf(zval *data,swEventData *buf TSRMLS_CC)
< {
< 	buf->info.type = SW_EVENT_TASK;
< 	//task_id
< 	buf->info.fd = php_swoole_task_id++;
< 	//source worker_id
< 	buf->info.from_id = SwooleWG.id;
< 	swTask_type(buf) |= SW_TASK_NONBLOCK;
< 
< 	char *task_data_str = NULL;
< 	int task_data_len = 0;
< 	smart_str serialized_data = {0};
< 
< 	//need serialize
< 	if (SW_Z_TYPE_P(data) != IS_STRING)
< 	{
< 		//serialize
< 		swTask_type(buf) |= SW_TASK_SERIALIZE;
< 		//TODO php serialize
< 		php_serialize_data_t var_hash;
< 		PHP_VAR_SERIALIZE_INIT(var_hash);
< 		sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);
< 		PHP_VAR_SERIALIZE_DESTROY(var_hash);
---
>     args[0] = &zserv;
>     sw_zval_add_ref(&zserv);
>     args[1] = &zworker_id;
1212,1238c982,985
< #if PHP_MAJOR_VERSION<7
< 		task_data_str = serialized_data.c;
< 		task_data_len = serialized_data.len;
< #else
< 		task_data_str = serialized_data.s->val;
< 		task_data_len = serialized_data.s->len;
< #endif
< 	}
< 	else
< 	{
< 		task_data_str = Z_STRVAL_P(data);
< 		task_data_len = Z_STRLEN_P(data);
< 	}
< 
< 	//write to file
< 	if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(buf->info) &&
< 			swTaskWorker_large_pack(buf, task_data_str, task_data_len) < 0)
< 	{
< 		smart_str_free(&serialized_data);
< 		swWarn("large task pack failed()");
< 		return SW_ERR;
< 	}
< 	else
< 	{
< 		memcpy(buf->data, task_data_str, task_data_len);
< 		buf->info.len = task_data_len;
< 	}
---
>     /**
>      * Manager Process ID
>      */
>     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("manager_pid"), SwooleGS->manager_pid TSRMLS_CC);
1240,1242c987,990
< 	smart_str_free(&serialized_data);
< 	return SW_OK;
< }
---
>     /**
>      * Worker ID
>      */
>     zend_update_property(swoole_server_class_entry_ptr, zserv, ZEND_STRL("worker_id"), zworker_id TSRMLS_CC);
1244,1247c992,995
< void php_swoole_register_callback(swServer *serv)
< {
<     /// optional callback
<     if (php_sw_server_callbacks[SW_SERVER_CB_onStart])
---
>     /**
>      * Is a task worker?
>      */
>     if (worker_id >= serv->worker_num)
1249c997,1001
<         serv->onStart = php_swoole_onStart;
---
>         zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL("taskworker"), 1 TSRMLS_CC);
>     }
>     else
>     {
>         zend_update_property_bool(swoole_server_class_entry_ptr, zserv, ZEND_STRL("taskworker"), 0 TSRMLS_CC);
1252c1004,1007
<     serv->onShutdown = php_swoole_onShutdown;
---
>     /**
>      * Worker Process ID
>      */
>     zend_update_property_long(swoole_server_class_entry_ptr, zserv, ZEND_STRL("worker_pid"), getpid() TSRMLS_CC);
1254,1255c1009
<     /// require callback, set the master/manager/worker PID
<     serv->onWorkerStart = php_swoole_onWorkerStart;
---
>     sw_zval_ptr_dtor(&zworker_id);
1257c1011,1014
<     if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop])
---
>     /**
>      * Have not set the event callback
>      */
>     if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart] == NULL)
1259c1016
<         serv->onWorkerStop = php_swoole_onWorkerStop;
---
>         return;
1262,1263c1019
<     /// UDP Packet
<     if (php_sw_server_callbacks[SW_SERVER_CB_onPacket])
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStart], &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
1265c1021
<         serv->onPacket = php_swoole_onPacket;
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onWorkerStart handler error");
1267,1269c1023
< 
<     /// Task Worker
<     if (php_sw_server_callbacks[SW_SERVER_CB_onTask])
---
>     if (EG(exception))
1271c1025
<         serv->onTask = php_swoole_onTask;
---
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
1273c1027
<     if (php_sw_server_callbacks[SW_SERVER_CB_onFinish])
---
>     if (retval)
1275c1029
<         serv->onFinish = php_swoole_onFinish;
---
>         sw_zval_ptr_dtor(&retval);
1277c1031,1035
<     if (php_sw_server_callbacks[SW_SERVER_CB_onWorkerError])
---
> }
> 
> static void php_swoole_onWorkerStop(swServer *serv, int worker_id)
> {
>     if (SwooleWG.shutdown)
1279c1037
<         serv->onWorkerError = php_swoole_onWorkerError;
---
>         return;
1281c1039,1058
<     if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStart])
---
>     SwooleWG.shutdown = 1;
> 
>     zval *zobject = (zval *) serv->ptr2;
>     zval *zworker_id;
>     zval **args[2]; //这里必须与下面的数字对应
>     zval *retval = NULL;
> 
>     SW_MAKE_STD_ZVAL(zworker_id);
>     ZVAL_LONG(zworker_id, worker_id);
> 
>     sw_zval_add_ref(&zobject);
> 
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     args[0] = &zobject;
>     args[1] = &zworker_id;
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerStop], &retval, 2, args, 0,
>             NULL TSRMLS_CC) == FAILURE)
1283c1060
<         serv->onManagerStart = php_swoole_onManagerStart;
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onWorkerStop handler error");
1285c1062
<     if (php_sw_server_callbacks[SW_SERVER_CB_onManagerStop])
---
>     if (EG(exception))
1287c1064
<         serv->onManagerStop = php_swoole_onManagerStop;
---
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
1289c1066,1067
<     if (php_sw_server_callbacks[SW_SERVER_CB_onPipeMessage])
---
>     sw_zval_ptr_dtor(&zworker_id);
>     if (retval != NULL)
1291c1069
<         serv->onPipeMessage = php_swoole_onPipeMessage;
---
>         sw_zval_ptr_dtor(&retval);
1295c1073
< int php_swoole_onReceive(swServer *serv, swEventData *req)
---
> static void php_swoole_onUserWorkerStart(swServer *serv, swWorker *worker)
1297,1306c1075,1076
< 
<     SWOOLE_FETCH_TSRMLS;
< 
<     zval *callback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onReceive);
< 
< #ifdef PHP_SWOOLE_CHECK_CALLBACK
< 	if (swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
< 		return SW_OK;
< 	}
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
1309,1346c1079,1080
<     swFactory *factory = &serv->factory;
< 
< 	zval *zfd = NULL;
< 	zval *zfrom_id = NULL;
< 	zval *zdata = NULL;
<     SW_MAKE_STD_ZVAL(zfd);
<     SW_MAKE_STD_ZVAL(zfrom_id);
<     SW_MAKE_STD_ZVAL(zdata);
< 
<     //dgram
<     if (swEventData_is_dgram(req->info.type))
<     {
<         swString *buffer = swWorker_get_buffer(serv, req->info.from_id);
<         swDgramPacket *packet = (swDgramPacket*) buffer->str;
< 
<         //UDP使用from_id作为port,fd做为ip
< 		php_swoole_udp_t udp_info;
<         if (req->info.type == SW_EVENT_UDP)
<         {
<         	//udp ipv4
<             udp_info.from_fd = req->info.from_fd;
<             udp_info.port = packet->port;
<             memcpy(&udp_server_socket, &udp_info, sizeof(udp_server_socket));
<             factory->last_from_id = udp_server_socket;
<             swTrace("SendTo: from_id=%d|from_fd=%d", (uint16_t) req->info.from_id, req->info.from_fd);
<             SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);
<             ZVAL_LONG(zfrom_id, (long ) udp_server_socket);
<             ZVAL_LONG(zfd, (long ) packet->addr.v4.s_addr);
<         }
<         //udp ipv6
<         else if (req->info.type == SW_EVENT_UDP6)
<         {
<             udp_info.from_fd = req->info.from_fd;
<             udp_info.port = packet->port;
<             memcpy(&dgram_server_socket, &udp_info, sizeof(udp_server_socket));
<             factory->last_from_id = dgram_server_socket;
< 
<             swTrace("SendTo: from_id=%d|from_fd=%d", (uint16_t) req->info.from_id, req->info.from_fd);
---
>     zval *object = worker->ptr;
>     zend_update_property_long(swoole_process_class_entry_ptr, object, ZEND_STRL("id"), SwooleWG.id TSRMLS_CC);
1348,1370c1082,1083
<             ZVAL_LONG(zfrom_id, (long ) dgram_server_socket);
<             char tmp[SW_IP_MAX_LENGTH] = {0};
<             inet_ntop(AF_INET6, &packet->addr.v6, tmp, sizeof(tmp));
<             SW_ZVAL_STRING(zfd, tmp, 1);
<             SW_ZVAL_STRINGL(zdata, packet->data, packet->length, 1);
<         }
<         //unix dgram
<         else
<         {
<             SW_ZVAL_STRINGL(zfd, packet->data, packet->addr.un.path_length, 1);
<             SW_ZVAL_STRINGL(zdata, packet->data + packet->addr.un.path_length, packet->length - packet->addr.un.path_length, 1);
<             ZVAL_LONG(zfrom_id, (long ) req->info.from_fd);
<             dgram_server_socket = req->info.from_fd;
<         }
<     }
<     //stream
<     else
<     {
<         ZVAL_LONG(zfrom_id, (long ) req->info.from_id);
<         ZVAL_LONG(zfd, (long ) req->info.fd);
<         int headlen = (SwooleG.serv->packet_mode == 1)? 4:0;
<         php_swoole_get_recv_data(zdata, req, NULL,headlen TSRMLS_CC);
<     }
---
>     php_swoole_process_start(worker, object TSRMLS_CC);
> }
1372,1377c1085,1090
<     zval **args[4];
<     zval* zserv = (zval *) serv->ptr2;
< 	args[0] = &zserv;
< 	args[1] = &zfd;
< 	args[2] = &zfrom_id;
< 	args[3] = &zdata;
---
> static void php_swoole_onWorkerError(swServer *serv, int worker_id, pid_t worker_pid, int exit_code, int signo)
> {
>     zval *zobject = (zval *) serv->ptr2;
>     zval *zworker_id, *zworker_pid, *zexit_code, *zsigno;
>     zval **args[5];
>     zval *retval = NULL;
1379,1380c1092,1116
< 	zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 4, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     SW_MAKE_STD_ZVAL(zworker_id);
>     ZVAL_LONG(zworker_id, worker_id);
> 
>     SW_MAKE_STD_ZVAL(zworker_pid);
>     ZVAL_LONG(zworker_pid, worker_pid);
> 
>     SW_MAKE_STD_ZVAL(zexit_code);
>     ZVAL_LONG(zexit_code, exit_code);
> 
>     SW_MAKE_STD_ZVAL(zsigno);
>     ZVAL_LONG(zsigno, signo);
> 
>     sw_zval_add_ref(&zobject);
> 
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     args[0] = &zobject;
>     args[1] = &zworker_id;
>     args[2] = &zworker_pid;
>     args[3] = &zexit_code;
>     args[4] = &zsigno;
> 
>     if (sw_call_user_function_ex(EG(function_table), NULL, php_sw_server_callbacks[SW_SERVER_CB_onWorkerError], &retval, 5, args, 0, NULL TSRMLS_CC) == FAILURE)
1382c1118
<         swWarn("swoole_server: onReceive handler error");
---
>         swoole_php_fatal_error(E_WARNING, "swoole_server: onWorkerError handler error");
1383a1120
> 
1389,1392c1126,1131
<     sw_zval_ptr_dtor(&zfd);
<     sw_zval_ptr_dtor(&zfrom_id);
<     sw_zval_ptr_dtor(&zdata);
<     if (retval)
---
>     sw_zval_ptr_dtor(&zworker_id);
>     sw_zval_ptr_dtor(&zworker_pid);
>     sw_zval_ptr_dtor(&zexit_code);
>     sw_zval_ptr_dtor(&zsigno);
> 
>     if (retval != NULL)
1396,1397d1134
< 
<     return SW_OK;
1400d1136
< 
1402a1139,1154
>     zval *zserv = (zval *) serv->ptr2;
>     zval *zfd;
>     zval *zfrom_id;
>     zval **args[3];
>     zval *retval = NULL;
> 
>     SW_MAKE_STD_ZVAL(zfd);
>     ZVAL_LONG(zfd, info->fd);
> 
>     SW_MAKE_STD_ZVAL(zfrom_id);
>     ZVAL_LONG(zfrom_id, info->from_id);
> 
>     args[0] = &zserv;
>     sw_zval_add_ref(&zserv);
>     args[1] = &zfd;
>     args[2] = &zfrom_id;
1404c1156,1158
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
1407c1161
<     if (!callback || ZVAL_IS_NULL(callback))
---
>     if (!callback)
1412,1427d1165
< 	zval *zfd = NULL;
< 	SW_MAKE_STD_ZVAL(zfd);
< 	ZVAL_LONG(zfd, info->fd);
< 
< 	zval *zfrom_id = NULL;
< 	SW_MAKE_STD_ZVAL(zfrom_id);
< 	ZVAL_LONG(zfrom_id, info->from_id);
< 
< 	zval *zserv = (zval *) serv->ptr2;
< 
< 	zval **args[3];
< 	args[0] = &zserv;
< 	args[1] = &zfd;
< 	args[2] = &zfrom_id;
< 
<     zval *retval = NULL;
1430c1168
<         swWarn("swoole_server: onConnect handler error");
---
>         swoole_php_error(E_WARNING, "swoole_server: onConnect handler error");
1432d1169
< 
1440,1441c1177
< 
<     if (retval)
---
>     if (retval != NULL)
1449c1185,1189
<     SWOOLE_FETCH_TSRMLS;
---
>     zval *zserv = (zval *) serv->ptr2;
>     zval *zfd;
>     zval *zfrom_id;
>     zval **args[3];
>     zval *retval = NULL;
1451,1455c1191,1193
<     zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onClose);
< 	if (!callback || ZVAL_IS_NULL(callback))
< 	{
< 		return;
< 	}
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
1457d1194
<     zval *zfd = NULL;
1461d1197
<     zval *zfrom_id = NULL;
1465,1467d1200
<     zval *zserv = (zval *) serv->ptr2;
< 
<     zval **args[3];
1468a1202
>     sw_zval_add_ref(&zserv);
1472,1474c1206,1207
<     zval *retval = NULL;
<     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3,
<     											args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     zval *callback = php_swoole_server_get_callback(serv, info->from_fd, SW_SERVER_CB_onClose);
>     if (!callback)
1476c1209
<         swWarn("onClose handler error");
---
>         return;
1478a1212,1215
>     if (sw_call_user_function_ex(EG(function_table), NULL, callback, &retval, 3, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_WARNING, "onClose handler error");
>     }
1486,1487c1223
< 
<     if (retval)
---
>     if (retval != NULL)
1494a1231,1238
>     zend_size_t host_len = 0;
>     char *serv_host;
>     long sock_type = SW_SOCK_TCP;
>     long serv_port;
>     long serv_mode = SW_MODE_PROCESS;
>     long serv_mode_tmp = serv_mode;
>     long packet_mode = 0;
> 
1510c1254
<         swWarn("server is already running. Unable to create swoole_server.");
---
>         swoole_php_fatal_error(E_WARNING, "server is already running. Unable to create swoole_server.");
1517,1524c1261
<     zend_size_t host_len = 0;
< 	char *serv_host = NULL;
< 	long sock_type = SW_SOCK_TCP;
< 	long serv_port = -1;
< 	long serv_mode_tmp = SW_MODE_PROCESS;
< 
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sl|ll", &serv_host, &host_len, &serv_port,
<     																&serv_mode_tmp, &sock_type))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sl|ll", &serv_host, &host_len, &serv_port, &serv_mode_tmp, &sock_type) == FAILURE)
1527d1263
<         sw_free(serv);
1531,1532c1267,1268
<     long serv_mode = serv_mode_tmp & 0x0f;
<     long packet_mode = (serv_mode_tmp & 0xf0) >> 4;
---
>     serv_mode = serv_mode_tmp & 0x0f;
>     packet_mode = (serv_mode_tmp & 0xf0) >> 4;
1538,1539c1274,1278
<     /// php can not running at multi-thread,reset mode mode-thread to mode-signle.
<     serv_mode = (serv_mode == SW_MODE_THREAD || serv_mode == SW_MODE_BASE)? SW_MODE_SINGLE:serv_mode;
---
>     if (serv_mode == SW_MODE_THREAD || serv_mode == SW_MODE_BASE)
>     {
>         serv_mode = SW_MODE_SINGLE;
>         swoole_php_fatal_error(E_WARNING, "PHP can not running at multi-threading. Reset mode to SWOOLE_MODE_BASE");
>     }
1543,1544c1282,1288
<     serv->worker_num = (serv->factory_mode == SW_MODE_SINGLE)? 1:serv->worker_num;
<     serv->max_request = (serv->factory_mode == SW_MODE_SINGLE)? 0:serv->max_request;
---
>     if (serv->factory_mode == SW_MODE_SINGLE)
>     {
>         serv->worker_num = 1;
>         serv->max_request = 0;
>     }
> 
>     bzero(php_sw_server_callbacks, sizeof (zval*) * PHP_SERVER_CALLBACK_NUM);
1547,1551c1291,1297
< 	if (!port)
< 	{
< 		swoole_php_fatal_error(E_ERROR, "listen server port failed.");
< 		return;
< 	}
---
>     if (!port)
>     {
>         swoole_php_fatal_error(E_ERROR, "listen server port failed.");
>         return;
>     }
> 
>     zval *server_object = getThis();
1553,1554d1298
<     bzero(php_sw_server_callbacks, sizeof (zval*) * PHP_SERVER_CALLBACK_NUM);
<     zval* server_object = getThis();
1556c1300
<     zval *connection_iterator_object = NULL;
---
>     zval *connection_iterator_object;
1559,1561c1303
<     zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL("connections"),
<     															connection_iterator_object TSRMLS_CC);
<     sw_zval_ptr_dtor(&connection_iterator_object);
---
>     zend_update_property(swoole_server_class_entry_ptr, server_object, ZEND_STRL("connections"), connection_iterator_object TSRMLS_CC);
1564,1572c1306,1309
<     zend_update_property_stringl(swoole_server_class_entry_ptr, server_object,
<     													ZEND_STRL("host"), serv_host, host_len TSRMLS_CC);
<     zend_update_property_long(swoole_server_class_entry_ptr, server_object,
<     													ZEND_STRL("port"), serv_port TSRMLS_CC);
<     zend_update_property_long(swoole_server_class_entry_ptr, server_object,
<     													ZEND_STRL("mode"), serv->factory_mode TSRMLS_CC);
<     zend_update_property_long(swoole_server_class_entry_ptr, server_object,
<     													ZEND_STRL("type"), sock_type TSRMLS_CC);
< 
---
>     zend_update_property_stringl(swoole_server_class_entry_ptr, server_object, ZEND_STRL("host"), serv_host, host_len TSRMLS_CC);
>     zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL("port"), serv_port TSRMLS_CC);
>     zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL("mode"), serv->factory_mode TSRMLS_CC);
>     zend_update_property_long(swoole_server_class_entry_ptr, server_object, ZEND_STRL("type"), sock_type TSRMLS_CC);
1575c1312
<     zval *ports = NULL;
---
>     zval *ports;
1586,1591d1322
< 	if (SwooleGS->start > 0)
< 	{
< 		swWarn("Server is running. Unable to execute swoole_server_set now.");
< 		RETURN_FALSE;
< 	}
< 
1593c1324,1329
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset))
---
>     zval *zobject = getThis();
>     HashTable *vht;
> 
>     zval *v;
> 
>     if (SwooleGS->start > 0)
1595c1331,1332
<         return;
---
>         swoole_php_fatal_error(E_WARNING, "Server is running. Unable to execute swoole_server_set now.");
>         RETURN_FALSE;
1598,1600c1335
<     zval *zobject = getThis();
<     swServer *serv = swoole_get_object(zobject);
<     if (!serv)
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset) == FAILURE)
1602,1603c1337
<     	swWarn("not create servers.");
<     	RETURN_FALSE;
---
>         return;
1606c1340,1342
<     HashTable *vht = Z_ARRVAL_P(zset);
---
>     swServer *serv = swoole_get_object(zobject);
> 
>     vht = Z_ARRVAL_P(zset);
1608,1609c1344
<     zval *value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("chroot"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("chroot"), (void **) &v) == SUCCESS)
1611,1612c1346,1347
<         convert_to_string(value);
<         SwooleG.chroot = strndup(Z_STRVAL_P(value), Z_STRLEN_P(value));
---
>         convert_to_string(v);
>         SwooleG.chroot = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
1614d1348
< 
1616,1617c1350
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("user"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("user"), (void **) &v) == SUCCESS)
1619,1620c1352,1353
<         convert_to_string(value);
<         SwooleG.user = strndup(Z_STRVAL_P(value), Z_STRLEN_P(value));
---
>         convert_to_string(v);
>         SwooleG.user = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
1622d1354
< 
1624,1625c1356
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("group"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("group"), (void **) &v) == SUCCESS)
1627,1628c1358,1359
<         convert_to_string(value);
<         SwooleG.group = strndup(Z_STRVAL_P(value), Z_STRLEN_P(value));
---
>         convert_to_string(v);
>         SwooleG.group = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
1630d1360
< 
1632,1633c1362
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("daemonize"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("daemonize"), (void **) &v) == SUCCESS)
1635,1636c1364,1365
<         convert_to_boolean(value);
<         serv->daemonize = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         serv->daemonize = Z_BVAL_P(v);
1638d1366
< 
1640,1641c1368
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("reactor_num"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("reactor_num"), (void **) &v) == SUCCESS)
1643,1645c1370,1375
<         convert_to_long(value);
<         serv->reactor_num = (int) Z_LVAL_P(value);
<         serv->reactor_num = (serv->reactor_num <= 0)? SwooleG.cpu_num:serv->reactor_num;
---
>         convert_to_long(v);
>         serv->reactor_num = (int) Z_LVAL_P(v);
>         if (serv->reactor_num <= 0)
>         {
>             serv->reactor_num = SwooleG.cpu_num;
>         }
1647d1376
< 
1649,1650c1378
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("worker_num"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("worker_num"), (void **) &v) == SUCCESS)
1652,1654c1380,1385
<         convert_to_long(value);
<         serv->worker_num = (int) Z_LVAL_P(value);
<         serv->worker_num = (serv->worker_num <= 0)? SwooleG.cpu_num:serv->worker_num;
---
>         convert_to_long(v);
>         serv->worker_num = (int) Z_LVAL_P(v);
>         if (serv->worker_num <= 0)
>         {
>             serv->worker_num = SwooleG.cpu_num;
>         }
1656d1386
< 
1658,1659c1388
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("dispatch_mode"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("dispatch_mode"), (void **) &v) == SUCCESS)
1661,1662c1390,1391
<         convert_to_long(value);
<         serv->dispatch_mode = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->dispatch_mode = (int) Z_LVAL_P(v);
1664d1392
< 
1666,1667c1394
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("log_file"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("log_file"), (void **) &v) == SUCCESS)
1669,1670c1396,1397
<         convert_to_string(value);
<         SwooleG.log_file = strndup(Z_STRVAL_P(value), Z_STRLEN_P(value));
---
>         convert_to_string(v);
>         SwooleG.log_file = strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
1672d1398
< 
1674,1675c1400
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("log_level"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("log_level"), (void **) &v) == SUCCESS)
1677,1678c1402,1403
<         convert_to_long(value);
<         SwooleG.log_level = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         SwooleG.log_level = (int) Z_LVAL_P(v);
1680,1683c1405,1408
< 
<     /// for dispatch_mode = 1/3
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("discard_timeout_request"), (void **) &value) == SUCCESS)
---
>     /**
>      * for dispatch_mode = 1/3
>      */
>     if (sw_zend_hash_find(vht, ZEND_STRS("discard_timeout_request"), (void **) &v) == SUCCESS)
1685,1686c1410,1411
<         convert_to_boolean(value);
<         serv->discard_timeout_request = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         serv->discard_timeout_request = Z_BVAL_P(v);
1689,1690c1414
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("enable_unsafe_event"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("enable_unsafe_event"), (void **) &v) == SUCCESS)
1692,1693c1416,1417
<         convert_to_boolean(value);
<         serv->enable_unsafe_event = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         serv->enable_unsafe_event = Z_BVAL_P(v);
1696,1697c1420
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("enable_port_reuse"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("enable_port_reuse"), (void **) &v) == SUCCESS)
1699,1700c1422,1423
<         convert_to_boolean(value);
<         SwooleG.reuse_port = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         SwooleG.reuse_port = Z_BVAL_P(v);
1703,1704c1426
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("task_worker_num"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("task_worker_num"), (void **) &v) == SUCCESS)
1706,1707c1428,1429
<         convert_to_long(value);
<         SwooleG.task_worker_num = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         SwooleG.task_worker_num = (int) Z_LVAL_P(v);
1710,1711c1432
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("task_ipc_mode"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("task_ipc_mode"), (void **) &v) == SUCCESS)
1713,1714c1434,1435
<         convert_to_long(value);
<         SwooleG.task_ipc_mode = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         SwooleG.task_ipc_mode = (int) Z_LVAL_P(v);
1716,1721c1437,1440
< 
<     /// Temporary file directory for task_worker
<     SwooleG.task_tmpdir = strndup(SW_TASK_TMP_FILE, sizeof (SW_TASK_TMP_FILE));
<     SwooleG.task_tmpdir_len = sizeof (SW_TASK_TMP_FILE);
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("task_tmpdir"), (void **) &value) == SUCCESS)
---
>     /**
>      * Temporary file directory for task_worker
>      */
>     if (sw_zend_hash_find(vht, ZEND_STRS("task_tmpdir"), (void **) &v) == SUCCESS)
1723c1442
<         convert_to_string(value);
---
>         convert_to_string(v);
1725,1726c1444
<         SwooleG.task_tmpdir_len = snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE,
<         										"%s/task.XXXXXX", Z_STRVAL_P(value)) + 1;
---
>         SwooleG.task_tmpdir_len = snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, "%s/task.XXXXXX", Z_STRVAL_P(v)) + 1;
1734c1452,1456
< 
---
>     else
>     {
>         SwooleG.task_tmpdir = strndup(SW_TASK_TMP_FILE, sizeof (SW_TASK_TMP_FILE));
>         SwooleG.task_tmpdir_len = sizeof (SW_TASK_TMP_FILE);
>     }
1736,1737c1458
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("task_max_request"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("task_max_request"), (void **) &v) == SUCCESS)
1739,1740c1460,1461
<         convert_to_long(value);
<         SwooleG.task_max_request = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         SwooleG.task_max_request = (int) Z_LVAL_P(v);
1743,1745c1464,1465
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("max_connection"), (void **) &value) == SUCCESS ||
<             sw_zend_hash_find(vht, ZEND_STRS("max_conn"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("max_connection"), (void **) &v) == SUCCESS ||
>             sw_zend_hash_find(vht, ZEND_STRS("max_conn"), (void **) &v) == SUCCESS)
1747,1748c1467,1468
<         convert_to_long(value);
<         serv->max_connection = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->max_connection = (int) Z_LVAL_P(v);
1751,1752c1471
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("heartbeat_check_interval"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("heartbeat_check_interval"), (void **) &v) == SUCCESS)
1754,1755c1473,1474
<         convert_to_long(value);
<         serv->heartbeat_check_interval = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->heartbeat_check_interval = (int) Z_LVAL_P(v);
1758,1759c1477
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("heartbeat_idle_time"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("heartbeat_idle_time"), (void **) &v) == SUCCESS)
1761,1762c1479,1480
<         convert_to_long(value);
<         serv->heartbeat_idle_time = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->heartbeat_idle_time = (int) Z_LVAL_P(v);
1766c1484
<             swWarn("heartbeat_idle_time must be greater than heartbeat_check_interval.");
---
>             swoole_php_fatal_error(E_WARNING, "heartbeat_idle_time must be greater than heartbeat_check_interval.");
1775,1776c1493
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("max_request"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("max_request"), (void **) &v) == SUCCESS)
1778,1779c1495,1496
<         convert_to_long(value);
<         serv->max_request = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->max_request = (int) Z_LVAL_P(v);
1782,1783c1499
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_cpu_affinity"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_cpu_affinity"), (void **) &v) == SUCCESS)
1785,1786c1501,1502
<         convert_to_boolean(value);
<         serv->open_cpu_affinity = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         serv->open_cpu_affinity = Z_BVAL_P(v);
1789,1790c1505
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("cpu_affinity_ignore"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("cpu_affinity_ignore"), (void **) &v) == SUCCESS)
1792,1793c1507,1508
<         int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(value));
<         if (ignore_num >= SW_CPU_NUM)
---
>         int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));
>         if (ignore_num >= SW_CPU_NUM) 
1798d1512
< 
1801,1808c1515,1523
<         int index = 0;
<         int available_i = 0;
<         for (index = 0; index < SW_CPU_NUM; index++)
<         {
<         	int flag = 1;
<             zval *zval_core = NULL;
<             SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(value), zval_core)
<                 if (index == (int) Z_LVAL_P(zval_core))
---
>         int flag, i, available_i = 0;
> 
>         zval *zval_core = NULL;
>         for (i = 0; i < SW_CPU_NUM; i++)
>         {
>             flag = 1;
>             SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)
>                 int core = (int) Z_LVAL_P(zval_core);
>                 if (i == core)
1816c1531
<                 available_cpu[available_i] = index;
---
>                 available_cpu[available_i] = i;
1820d1534
< 
1824d1537
< 
1826,1827c1539
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("http_parse_post"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("http_parse_post"), (void **) &v) == SUCCESS)
1829,1830c1541,1542
<         convert_to_boolean(value);
<         serv->http_parse_post = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         serv->http_parse_post = Z_BVAL_P(v);
1832,1843c1544,1563
< 
<     /// buffer input size
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("buffer_input_size"), (void **) &value) == SUCCESS)
<     {
<         convert_to_long(value);
<         serv->buffer_input_size = (int) Z_LVAL_P(value);
<     }
< 
<     /// buffer output size
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("buffer_output_size"), (void **) &value) == SUCCESS)
---
>     /**
>      * buffer input size
>      */
>     if (sw_zend_hash_find(vht, ZEND_STRS("buffer_input_size"), (void **) &v) == SUCCESS)
>     {
>         convert_to_long(v);
>         serv->buffer_input_size = (int) Z_LVAL_P(v);
>     }
>     /**
>      * buffer output size
>      */
>     if (sw_zend_hash_find(vht, ZEND_STRS("buffer_output_size"), (void **) &v) == SUCCESS)
>     {
>         convert_to_long(v);
>         serv->buffer_output_size = (int) Z_LVAL_P(v);
>     }
>     /**
>      * set pipe memory buffer size
>      */
>     if (sw_zend_hash_find(vht, ZEND_STRS("pipe_buffer_size"), (void **) &v) == SUCCESS)
1845,1846c1565,1566
<         convert_to_long(value);
<         serv->buffer_output_size = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->pipe_buffer_size = (int) Z_LVAL_P(v);
1848,1856d1567
< 
<     /// set pipe memory buffer size
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("pipe_buffer_size"), (void **) &value) == SUCCESS)
<     {
<         convert_to_long(value);
<         serv->pipe_buffer_size = (int) Z_LVAL_P(value);
<     }
< 
1858,1859c1569
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("message_queue_key"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("message_queue_key"), (void **) &v) == SUCCESS)
1861,1862c1571,1572
<         convert_to_long(value);
<         serv->message_queue_key = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         serv->message_queue_key = (int) Z_LVAL_P(v);
1879a1590,1592
>     zval *name;
>     zval *cb;
> 
1882c1595
<         swWarn("Server is running. Unable to set event callback now.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is running. Unable to set event callback now.");
1886,1896c1599
<     zval *zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     zval *name = NULL;
<     zval *cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &name, &cb))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "zz", &name, &cb) == FAILURE)
1901c1604,1606
<     if (swoole_check_callable(cb TSRMLS_CC) < 0)
---
> #ifdef PHP_SWOOLE_CHECK_CALLBACK
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(cb, 0, &func_name TSRMLS_CC))
1903c1608,1610
<     	return ;
---
>         swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
>         return;
1904a1612,1613
>     efree(func_name);
> #endif
1907c1616,1636
<     char property_name[128] = {0};
---
> 
>     char *callback[PHP_SERVER_CALLBACK_NUM] = {
>         "Connect",
>         "Receive",
>         "Close",
>         "Packet",
>         "Start",
>         "Shutdown",
>         "WorkerStart",
>         "WorkerStop",
>         "Task",
>         "Finish",
>         "WorkerError",
>         "ManagerStart",
>         "ManagerStop",
>         "PipeMessage",
>     };
> 
>     int i;
>     char property_name[128];
>     int l_property_name = 0;
1909,1916d1637
<     int l_property_name = 2;
<     int index;
<     for (index = 0; index < PHP_SERVER_CALLBACK_NUM; index++)
<     {
<     	if (NULL == swoole_server_callback[index])
<     	{
<     		continue;
<     	}
1918,1919c1639,1641
<         if (Z_STRLEN_P(name) == strlen(swoole_server_callback[index]) &&
<         		strncasecmp(swoole_server_callback[index], Z_STRVAL_P(name), Z_STRLEN_P(name)) == 0)
---
>     for (i = 0; i < PHP_SERVER_CALLBACK_NUM; i++)
>     {
>         if (strncasecmp(callback[i], Z_STRVAL_P(name), Z_STRLEN_P(name)) == 0)
1921,1922c1643,1644
<             memcpy(property_name + l_property_name, swoole_server_callback[index], Z_STRLEN_P(name));
<             l_property_name += Z_STRLEN_P(name);
---
>             memcpy(property_name + 2, callback[i], Z_STRLEN_P(name));
>             l_property_name = Z_STRLEN_P(name) + 2;
1925,1927c1647,1648
<             php_sw_server_callbacks[index] = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), property_name,
<             																					l_property_name, 0 TSRMLS_CC);
<             sw_copy_to_stack(php_sw_server_callbacks[index], _php_sw_server_callbacks[index]);
---
>             php_sw_server_callbacks[i] = sw_zend_read_property(swoole_server_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);
>             sw_copy_to_stack(php_sw_server_callbacks[i], _php_sw_server_callbacks[i]);
1932c1653
<     if (index == PHP_SERVER_CALLBACK_NUM)
---
>     if (l_property_name == 0)
1934c1655
<         swWarn("Unknown event types[%s]", Z_STRVAL_P(name));
---
>         swoole_php_error(E_WARNING, "Unknown event types[%s]", Z_STRVAL_P(name));
1938c1659
<     if (index < SW_SERVER_CB_onStart)
---
>     if (i < SW_SERVER_CB_onStart)
1945,1946c1666,1669
< 
<     RETURN_TRUE;
---
>     else
>     {
>         RETURN_TRUE;
>     }
1950a1674,1678
>     char *host;
>     zend_size_t host_len;
>     long sock_type;
>     long port;
> 
1953c1681
<         swWarn("Server is running. cannot add listener.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is running. cannot add listener.");
1957,1961c1685
<     char *host = NULL;
< 	zend_size_t host_len = 0;
< 	long sock_type = 0;
< 	long port = -1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sll", &host, &host_len, &port, &sock_type))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sll", &host, &host_len, &port, &sock_type) == FAILURE)
1967,1974c1691,1692
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     swListenPort *lsPort = swServer_add_port(serv, (int) sock_type, host, (int) port);
<     if (!lsPort)
---
>     swListenPort *ls = swServer_add_port(serv, (int) sock_type, host, (int) port);
>     if (!ls)
1979c1697
<     zval *port_object = php_swoole_server_add_port(lsPort TSRMLS_CC);
---
>     zval *port_object = php_swoole_server_add_port(ls TSRMLS_CC);
1987c1705
<         swWarn("Server is running. cannot add process.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is running. cannot add process.");
1992c1710
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &process))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &process) == FAILURE)
1997c1715
<     if (!process || ZVAL_IS_NULL(process))
---
>     if (ZVAL_IS_NULL(process))
1999c1717
<         swWarn("parameter 1 cannot be empty.");
---
>         swoole_php_fatal_error(E_WARNING, "parameter 1 cannot be empty.");
2002a1721
>     swServer *serv = swoole_get_object(getThis());
2009,2017c1728,1731
<     swServer *serv = swoole_get_object(getThis());
<     if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     serv->onUserWorkerStart = (!serv->onUserWorkerStart)? php_swoole_onUserWorkerStart:
<     															serv->onUserWorkerStart;
---
>     if (serv->onUserWorkerStart == NULL)
>     {
>         serv->onUserWorkerStart = php_swoole_onUserWorkerStart;
>     }
2028,2032d1741
<     if (!worker){
<     	swWarn("get object form process failed.");
<     	RETURN_FALSE;
<     }
< 
2038c1747
<         swWarn("swServer add worker failed.");
---
>         swoole_php_fatal_error(E_WARNING, "swServer_add_worker failed.");
2041,2042c1750
< 
<     zend_update_property_long(swoole_process_class_entry_ptr, process, ZEND_STRL("id"), id TSRMLS_CC);
---
>     zend_update_property_long(swoole_process_class_entry_ptr, getThis(), ZEND_STRL("id"), id TSRMLS_CC);
2047a1756,1758
>     zval *zobject = getThis();
>     int ret;
> 
2050c1761
<         swWarn("Server is running. Unable to execute swoole_server::start.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is running. Unable to execute swoole_server::start.");
2054d1764
<     zval* zobject = getThis();
2056,2061d1765
<     if (!serv)
<     {
<     	swWarn("Server object not found.");
<     	RETURN_FALSE;
<     }
< 
2064c1768
<     if (!php_sw_server_callbacks[SW_SERVER_CB_onReceive] && !php_sw_server_callbacks[SW_SERVER_CB_onPacket])
---
>     if (php_sw_server_callbacks[SW_SERVER_CB_onReceive] == NULL && php_sw_server_callbacks[SW_SERVER_CB_onPacket] == NULL)
2069,2070c1773
< 
<     ///-------------------------------------------------------------
---
>     //-------------------------------------------------------------
2073d1775
<     sw_zval_add_ref(&zobject);
2077c1779,1780
<     if (swServer_start(serv) < 0)
---
>     ret = swServer_start(serv);
>     if (ret < 0)
2080c1783
<         RETURN_LONG(-1);
---
>         RETURN_LONG(ret);
2082d1784
< 
2088,2094c1790,1796
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
> 
>     int ret;
> 
>     zval *zfd;
>     zval *zdata;
>     long server_socket = -1;
2096c1798
< 	if (!SwooleGS->start)
---
>     if (SwooleGS->start == 0)
2098c1800
<         swWarn("Server is not running.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
2102,2105c1804
< 	zval *zfd = NULL;
< 	zval *zdata = NULL;
< 	long server_socket = -1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|l", &zfd, &zdata, &server_socket))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|l", &zfd, &zdata, &server_socket) == FAILURE)
2110c1809
<     char *data = NULL;
---
>     char *data;
2112c1811,1816
<     if (length <= 0 || !data)
---
> 
>     if (length < 0)
>     {
>         RETURN_FALSE;
>     }
>     else if (length == 0)
2114c1818
<     	swWarn("data is invailed or empty.");
---
>         swoole_php_fatal_error(E_WARNING, "data is empty.");
2118c1822,1823
<     int ret = -1;
---
>    swServer *serv = swoole_get_object(zobject);
> 
2121c1826,1829
<     	server_socket = (server_socket < 0)? dgram_server_socket:server_socket;
---
>         if (server_socket == -1)
>         {
>             server_socket = dgram_server_socket;
>         }
2142d1849
< 
2146,2147c1853
< convert:
< 	convert_to_long(zfd);
---
>     convert: convert_to_long(zfd);
2149c1855
< 
---
>     //UDP
2152,2153c1858,1861
<     	//UDP
<     	server_socket = (server_socket < 0)? udp_server_socket:server_socket;
---
>         if (server_socket == -1)
>         {
>             server_socket = udp_server_socket;
>         }
2162,2163c1870,1871
<         SW_CHECK_RETURN(swSocket_sendto_blocking(udp_info.from_fd, data, length, 0,
<         									(struct sockaddr *) &addr_in, sizeof(addr_in)));
---
>         ret = swSocket_sendto_blocking(udp_info.from_fd, data, length, 0, (struct sockaddr *) &addr_in, sizeof(addr_in));
>         SW_CHECK_RETURN(ret);
2170c1878
<             swWarn("cannot send to client in task worker with SWOOLE_BASE mode.");
---
>             swoole_php_error(E_WARNING, "cannot send to client in task worker with SWOOLE_BASE mode.");
2178d1885
< 
2185,2202c1892,1898
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     char *ip = NULL;
<     char *data = NULL;
<     zend_size_t len = 0, ip_len = 0;
<     long port = -1;
---
>     zval *zobject = getThis();
> 
>     char *ip;
>     char *data;
>     zend_size_t len, ip_len;
> 
>     long port;
2204c1900,1908
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sls|l", &ip, &ip_len, &port, &data, &len, &server_socket))
---
>     zend_bool ipv6 = 0;
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sls|l", &ip, &ip_len, &port, &data, &len, &server_socket) == FAILURE)
2209c1913
<     if (!data || len <= 0)
---
>     if (len <= 0)
2211c1915
<         swWarn("data is empty.");
---
>         swoole_php_fatal_error(E_WARNING, "data is empty.");
2215c1919
<     zend_bool ipv6 = (strchr(ip, ':'))? 1:0;
---
>     swServer *serv = swoole_get_object(zobject);
2217c1921
<     if ((!ipv6 && serv->udp_socket_ipv4 <= 0) || (ipv6 && serv->udp_socket_ipv6 <= 0))
---
>     if (strchr(ip, ':'))
2219,2220c1923
<         swWarn("You must use Rigth socket type to server before using sendto.");
<         RETURN_FALSE;
---
>         ipv6 = 1;
2223c1926,1935
<     server_socket = ipv6 ?  serv->udp_socket_ipv6 : serv->udp_socket_ipv4;
---
>     if (ipv6 == 0 && serv->udp_socket_ipv4 <= 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "You must add an UDP listener to server before using sendto.");
>         RETURN_FALSE;
>     }
>     else if (ipv6 == 1 && serv->udp_socket_ipv6 <= 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "You must add an UDP6 listener to server before using sendto.");
>         RETURN_FALSE;
>     }
2225,2226c1937,1940
<     int ret = (ipv6)?swSocket_udp_sendto6(server_socket, ip, port, data, len):
<     				 swSocket_udp_sendto(server_socket, ip, port, data, len);
---
>     if (server_socket < 0)
>     {
>         server_socket = ipv6 ?  serv->udp_socket_ipv6 : serv->udp_socket_ipv4;
>     }
2227a1942,1950
>     int ret;
>     if (ipv6)
>     {
>         ret = swSocket_udp_sendto6(server_socket, ip, port, data, len);
>     }
>     else
>     {
>         ret = swSocket_udp_sendto(server_socket, ip, port, data, len);
>     }
2233,2245c1956,1966
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
>     zend_size_t len;
> 
>     char *filename;
>     long fd;
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
2248c1969
<     swWarn("cannot use swoole_server->sendfile() in cygwin.");
---
>     swoole_php_fatal_error(E_WARNING, "cannot use swoole_server->sendfile() in cygwin.");
2252,2255c1973
<     zend_size_t len = 0;
<     char *filename = NULL;
<     long fd = -1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ls", &fd, &filename, &len))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ls", &fd, &filename, &len) == FAILURE)
2266a1985
>     swServer *serv = swoole_get_object(zobject);
2272,2292c1991,1992
< 	if (swIsMaster())
< 	{
< 		swWarn("Cannot close connection in master process.");
< 		RETURN_FALSE;
< 	}
< 
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     zval *zfd = NULL;
---
>     zval *zobject = getThis();
>     zval *zfd;
2294c1994,2007
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|b", &zfd, &reset))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (swIsMaster())
>     {
>         swoole_php_fatal_error(E_WARNING, "Cannot close connection in master process.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|b", &zfd, &reset) == FAILURE)
2298a2012
>     swServer *serv = swoole_get_object(zobject);
2309d2022
< 
2318c2031
<     if (!SwooleGS->start)
---
>     if (SwooleGS->start == 0)
2320c2033
<         swWarn("Server is not running.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
2324,2331d2036
<     zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
2355,2368d2059
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
2370c2061,2068
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &only_reload_taskworker))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &only_reload_taskworker) == FAILURE)
2375c2073,2074
<     if (swKill(SwooleGS->manager_pid, only_reload_taskworker ? SIGUSR2 : SIGUSR1) < 0)
---
>     int sig = only_reload_taskworker ? SIGUSR2 : SIGUSR1;
>     if (kill(SwooleGS->manager_pid, sig) < 0)
2377c2076
<         swWarn("kill() failed. Error: %s[%d]", strerror(errno), errno);
---
>         swoole_php_fatal_error(E_WARNING, "kill() failed. Error: %s[%d]", strerror(errno), errno);
2380d2078
< 
2386,2398c2084
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
2401c2087,2094
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &close_connection))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|b", &close_connection) == FAILURE)
2405a2099,2100
>     swServer *serv = swoole_get_object(zobject);
> 
2413,2414c2108
<     int fd = 0;
<     int checktime = (int) SwooleGS->now - serv->heartbeat_idle_time;
---
> 
2415a2110,2114
> 
>     int fd;
>     int checktime = (int) SwooleGS->now - serv->heartbeat_idle_time;
>     swConnection *conn;
> 
2419c2118
<         swConnection *conn = &serv->connection_list[fd];
---
>         conn = &serv->connection_list[fd];
2421c2120
<         if (conn->active && conn->last_time < checktime)
---
>         if (1 == conn->active && conn->last_time < checktime)
2442,2454c2141,2145
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     swEventData buf;
> 
>     zval *data;
>     smart_str serialized_data = { 0 };
>     php_serialize_data_t var_hash;
2456d2146
<     zval *data = NULL;
2460c2150,2156
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|dl", &data, &timeout, &dst_worker_id))
---
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|dl", &data, &timeout, &dst_worker_id) == FAILURE)
2470,2472c2166,2197
<     swEventData buf;
<     memset(&buf,0x00,sizeof(swEventData));
<     if (php_swoole_task_setBuf(data,&buf TSRMLS_CC) < 0)
---
>     buf.info.type = SW_EVENT_TASK;
>     //field fd save task_id
>     buf.info.fd = php_swoole_task_id++;
>     //field from_id save the worker_id
>     buf.info.from_id = SwooleWG.id;
>     swTask_type(&buf) = 0;
> 
>     //clear result buffer
>     swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);
>     bzero(task_result, sizeof(SwooleG.task_result[SwooleWG.id]));
> 
>     uint64_t notify;
> 
>     char *task_data_str;
>     int task_data_len = 0;
>     //need serialize
>     if (SW_Z_TYPE_P(data) != IS_STRING)
>     {
>         //serialize
>         swTask_type(&buf) |= SW_TASK_SERIALIZE;
>         PHP_VAR_SERIALIZE_INIT(var_hash);
>         sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);
>         PHP_VAR_SERIALIZE_DESTROY(var_hash);
> #if PHP_MAJOR_VERSION<7
>         task_data_str = serialized_data.c;
>         task_data_len = serialized_data.len;
> #else
>         task_data_str = serialized_data.s->val;
>         task_data_len = serialized_data.s->len;
> #endif
>     }
>     else
2474c2199,2200
<     	RETURN_FALSE;
---
>         task_data_str = Z_STRVAL_P(data);
>         task_data_len = Z_STRLEN_P(data);
2477,2480c2203,2217
< 	swEventData *task_result = &(SwooleG.task_result[SwooleWG.id]);
< 	bzero(task_result, sizeof(swEventData));
< 	swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];
< 	int efd = task_notify_pipe->getFd(task_notify_pipe, 0);
---
>     if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(buf.info))
>     {
>         if (swTaskWorker_large_pack(&buf, task_data_str, task_data_len) < 0)
>         {
>             smart_str_free(&serialized_data);
>             swoole_php_fatal_error(E_WARNING, "large task pack failed()");
>             RETURN_FALSE;
>         }
>     }
>     else
>     {
>         memcpy(buf.data, task_data_str, task_data_len);
>         buf.info.len = task_data_len;
>     }
>     smart_str_free(&serialized_data);
2482,2483c2219,2221
< 	//clear history task
<     uint64_t notify;
---
>     swPipe *task_notify_pipe = &SwooleG.task_notify[SwooleWG.id];
>     int efd = task_notify_pipe->getFd(task_notify_pipe, 0);
>     //clear history task
2498c2236
<             swWarn("taskwait failed. Error: %s[%d]", strerror(errno), errno);
---
>             swoole_php_fatal_error(E_WARNING, "taskwait failed. Error: %s[%d]", strerror(errno), errno);
2501d2238
< 
2507,2519c2244,2248
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     swEventData buf;
> 
>     zval *data;
>     smart_str serialized_data = {0};
>     php_serialize_data_t var_hash;
2521d2249
<     zval *data = NULL;
2523c2251,2258
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|l", &data, &dst_worker_id))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|l", &data, &dst_worker_id) == FAILURE)
2533,2535c2268,2298
<     swEventData buf;
<     memset(&buf,0x00,sizeof(swEventData));
<     if (php_swoole_task_setBuf(data,&buf TSRMLS_CC) < 0)
---
>     buf.info.type = SW_EVENT_TASK;
>     //task_id
>     buf.info.fd = php_swoole_task_id++;
>     //source worker_id
>     buf.info.from_id = SwooleWG.id;
>     swTask_type(&buf) = 0;
> 
>     swTask_type(&buf) |= SW_TASK_NONBLOCK;
> 
>     char *task_data_str = NULL;
>     int task_data_len = 0;
> 
>     //need serialize
>     if (SW_Z_TYPE_P(data) != IS_STRING)
>     {
>         //serialize
>         swTask_type(&buf) |= SW_TASK_SERIALIZE;
>         //TODO php serialize
>         PHP_VAR_SERIALIZE_INIT(var_hash);
>         sw_php_var_serialize(&serialized_data, data, &var_hash TSRMLS_CC);
>         PHP_VAR_SERIALIZE_DESTROY(var_hash);
> 
> #if PHP_MAJOR_VERSION<7
>         task_data_str = serialized_data.c;
>         task_data_len = serialized_data.len;
> #else
>         task_data_str = serialized_data.s->val;
>         task_data_len = serialized_data.s->len;
> #endif
>     }
>     else
2537c2300,2301
<     	RETURN_FALSE;
---
>         task_data_str = Z_STRVAL_P(data);
>         task_data_len = Z_STRLEN_P(data);
2540c2304,2314
<     if (swProcessPool_dispatch(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) < 0)
---
>     //write to file
>     if (task_data_len >= SW_IPC_MAX_SIZE - sizeof(buf.info))
>     {
>         if (swTaskWorker_large_pack(&buf, task_data_str, task_data_len) < 0)
>         {
>             smart_str_free(&serialized_data);
>             swoole_php_fatal_error(E_WARNING, "large task pack failed()");
>             RETURN_FALSE;
>         }
>     }
>     else
2542c2316,2317
<     	RETURN_FALSE;
---
>         memcpy(buf.data, task_data_str, task_data_len);
>         buf.info.len = task_data_len;
2545,2546c2320,2330
<     sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);
<     RETURN_LONG(buf.info.fd);
---
>     smart_str_free(&serialized_data);
> 
>     if (swProcessPool_dispatch(&SwooleGS->task_workers, &buf, (int*) &dst_worker_id) >= 0)
>     {
>         sw_atomic_fetch_add(&SwooleStats->tasking_num, 1);
>         RETURN_LONG(buf.info.fd);
>     }
>     else
>     {
>         RETURN_FALSE;
>     }
2551,2563c2335,2336
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
>     swEventData buf;
2565,2566c2338,2339
<     char *msg = NULL;
<     zend_size_t msglen = 0;
---
>     char *msg;
>     zend_size_t msglen;
2568c2341,2348
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sl", &msg, &msglen, &worker_id))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sl", &msg, &msglen, &worker_id) == FAILURE)
2575c2355
<         swWarn("cannot send message to self.");
---
>         swoole_php_fatal_error(E_WARNING, "cannot send message to self.");
2578a2359
>     swServer *serv = swoole_get_object(zobject);
2581c2362
<         swWarn("worker_id[%d] is invalid.", (int) worker_id);
---
>         swoole_php_fatal_error(E_WARNING, "worker_id[%d] is invalid.", (int) worker_id);
2587c2368
<         swWarn("onPipeMessage is null, cannot use sendMessage.");
---
>         swoole_php_fatal_error(E_WARNING, "onPipeMessage is null, cannot use sendMessage.");
2591d2371
<     swEventData buf;
2600c2380
<             swWarn("large task pack failed()");
---
>             swoole_php_fatal_error(E_WARNING, "large task pack failed()");
2612,2614c2392
<     SW_CHECK_RETURN(swWorker_send2worker(to_worker, &buf, sizeof(buf.info) +
<     								buf.info.len,SW_PIPE_MASTER | SW_PIPE_NONBLOCK));
< 
---
>     SW_CHECK_RETURN(swWorker_send2worker(to_worker, &buf, sizeof(buf.info) + buf.info.len, SW_PIPE_MASTER | SW_PIPE_NONBLOCK));
2619,2631c2397,2404
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
>     zval *data;
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
2633,2634c2406
<     zval *data = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE)
2638a2411
>     swServer *serv = swoole_get_object(zobject);
2644,2656c2417
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
2660c2421,2428
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &fd, &uid))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ll", &fd, &uid) == FAILURE)
2664a2433,2434
>     swServer *serv = swoole_get_object(zobject);
> 
2666c2436,2438
<     if (!conn || !conn->active || conn->uid)
---
> 
>     //udp client
>     if (conn == NULL)
2671a2444,2456
>     //connection is closed
>     if (conn->active == 0)
>     {
>         swTrace("fd:%ld a:%d, uid: %ld", fd, conn->active, conn->uid);
>         RETURN_FALSE;
>     }
> 
>     if (conn->uid != 0)
>     {
>         RETURN_FALSE;
>     }
> 
>     int ret = 0;
2673,2674c2458,2462
<     conn->uid = (!conn->uid)? uid:conn->uid;
<     int ret = (!conn->uid)? 1:0;
---
>     if (conn->uid == 0)
>     {
>         conn->uid = uid;
>         ret = 1;
>     }
2678a2467
> #ifdef SWOOLE_SOCKETS_SUPPORT
2682c2471
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &port))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &port) == FAILURE)
2687,2693c2476,2477
<     zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
>     swServer *serv = swoole_get_object(zobject);
2695d2478
<     /// todo find socket.
2697a2481
> 
2702d2485
< 
2704,2705d2486
<     zval *zsocket = sw_zval_dup(return_value);
<     sw_zval_add_ref(&zsocket);
2706a2488
> #endif
2708c2490
< PHP_METHOD(swoole_server, getClientInfo)
---
> PHP_METHOD(swoole_server, connection_info)
2710,2722c2492
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
2725c2495
<     zval *zfd = NULL;
---
>     zval *zfd;
2727c2497,2504
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|lb", &zfd, &from_id, &noCheckConnection))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|lb", &zfd, &from_id, &noCheckConnection) == FAILURE)
2731a2509,2510
>     swServer *serv = swoole_get_object(zobject);
> 
2735c2514
<     //judge ipv6 udp
---
>     //ipv6 udp
2738,2743c2517
<     	/// php 接口
<         #if PHP_MAJOR_VERSION < 7
<         if (!is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), &fd, NULL, 0))
<         #else
<         if (!is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), (zend_long*)(&fd), NULL, 0))
<         #endif
---
>         if (is_numeric_string(Z_STRVAL_P(zfd), Z_STRLEN_P(zfd), &fd, NULL, 0))
2745,2746c2519,2524
< 			fd = 0;
< 			ipv6_udp = 1;
---
>             ipv6_udp = 0;
>         }
>         else
>         {
>             fd = 0;
>             ipv6_udp = 1;
2760d2537
<         /// ipv6
2769,2771c2546
<             char tmpip[SW_IP_MAX_LENGTH] = {0};
<             inet_ntop(AF_INET,&sin_addr,tmpip,SW_IP_MAX_LENGTH);
<             sw_add_assoc_string(return_value, "remote_ip", tmpip, 1);
---
>             sw_add_assoc_string(return_value, "remote_ip", inet_ntoa(sin_addr), 1);
2774c2549
<         if (!from_id)
---
>         if (from_id == 0)
2781d2555
<         add_assoc_long(return_value, "remote_port", udp_info.port);
2782a2557
> 
2789c2564
< 
---
>         add_assoc_long(return_value, "remote_port", udp_info.port);
2794,2795c2569,2574
<     //connection is invaild
<     if (!conn || (!conn->active && !noCheckConnection))
---
>     if (!conn)
>     {
>         RETURN_FALSE;
>     }
>     //connection is closed
>     if (conn->active == 0 && !noCheckConnection)
2798a2578,2580
>     else
>     {
>         array_init(return_value);
2800,2804c2582,2585
< 	array_init(return_value);
< 	if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)
< 	{
< 		add_assoc_long(return_value, "uid", conn->uid);
< 	}
---
>         if (serv->dispatch_mode == SW_DISPATCH_UIDMOD)
>         {
>             add_assoc_long(return_value, "uid", conn->uid);
>         }
2806,2810c2587,2591
< 	swListenPort *port = swServer_get_port(serv, conn->fd);
< 	if (port->open_websocket_protocol)
< 	{
< 		add_assoc_long(return_value, "websocket_status", conn->websocket_status);
< 	}
---
>         swListenPort *port = swServer_get_port(serv, conn->fd);
>         if (port->open_websocket_protocol)
>         {
>             add_assoc_long(return_value, "websocket_status", conn->websocket_status);
>         }
2813,2816c2594,2597
< 	if (conn->ssl_client_cert.length > 0)
< 	{
< 		sw_add_assoc_stringl(return_value, "ssl_client_cert", conn->ssl_client_cert.str, conn->ssl_client_cert.length - 1, 1);
< 	}
---
>         if (conn->ssl_client_cert.length > 0)
>         {
>             sw_add_assoc_stringl(return_value, "ssl_client_cert", conn->ssl_client_cert.str, conn->ssl_client_cert.length - 1, 1);
>         }
2819,2833c2600,2609
< 
< 	add_assoc_long(return_value, "server_fd", conn->from_fd);
< 	add_assoc_long(return_value, "socket_type", conn->socket_type);
< 
< 	swConnection *from_sock = swServer_connection_get(serv, conn->from_fd);
< 	add_assoc_long(return_value, "server_port", swConnection_get_port(from_sock));
< 	add_assoc_long(return_value, "remote_port", swConnection_get_port(conn));
< 
< 	char addr[SW_IP_MAX_LENGTH] = {0};
< 	swConnection_get_ip(conn,addr,SW_IP_MAX_LENGTH);
< 	sw_add_assoc_string(return_value, "remote_ip", addr, 1);
< 
< 	add_assoc_long(return_value, "from_id", conn->from_id);
< 	add_assoc_long(return_value, "connect_time", conn->connect_time);
< 	add_assoc_long(return_value, "last_time", conn->last_time);
---
>         swConnection *from_sock = swServer_connection_get(serv, conn->from_fd);
>         add_assoc_long(return_value, "server_fd", conn->from_fd);
>         add_assoc_long(return_value, "socket_type", conn->socket_type);
>         add_assoc_long(return_value, "server_port", swConnection_get_port(from_sock));
>         add_assoc_long(return_value, "remote_port", swConnection_get_port(conn));
>         sw_add_assoc_string(return_value, "remote_ip", swConnection_get_ip(conn), 1);
>         add_assoc_long(return_value, "from_id", conn->from_id);
>         add_assoc_long(return_value, "connect_time", conn->connect_time);
>         add_assoc_long(return_value, "last_time", conn->last_time);
>     }
2836c2612
< PHP_METHOD(swoole_server, getClientList)
---
> PHP_METHOD(swoole_server, connection_list)
2838,2850c2614
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
2854c2618,2625
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ll", &start_fd, &find_count))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|ll", &start_fd, &find_count) == FAILURE)
2858a2630,2631
>     swServer *serv = swoole_get_object(zobject);
> 
2860,2864c2633,2640
< 	if (find_count > SW_MAX_FIND_COUNT)
< 	{
< 		swWarn("swoole_connection_list max_find_count=%d", SW_MAX_FIND_COUNT);
< 		find_count = SW_MAX_FIND_COUNT;
< 	}
---
>     if (find_count > SW_MAX_FIND_COUNT)
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_connection_list max_find_count=%d", SW_MAX_FIND_COUNT);
>         RETURN_FALSE;
>     }
> 
>     //复制出来避免被其他进程改写
>     int serv_max_fd = swServer_get_maxfd(serv);
2878d2653
< 
2883,2884d2657
<     //复制出来避免被其他进程改写
<     int serv_max_fd = swServer_get_maxfd(serv);
2893c2666,2668
<     for (; fd <= serv_max_fd && find_count > 0; fd++)
---
>     swConnection *conn;
> 
>     for (; fd <= serv_max_fd; fd++)
2896c2671,2672
<         swConnection *conn = &serv->connection_list[fd];
---
>         conn = &serv->connection_list[fd];
> 
2905a2682,2686
>         //finish fetch
>         if (find_count <= 0)
>         {
>             break;
>         }
2911,2927c2692,2697
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     long fd = -1;
<     zval *zdata = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz", &fd, &zdata))
---
>     zval *zobject = getThis();
> 
>     long fd;
>     zval *zdata;
> 
>     if (SwooleGS->start == 0)
2929c2699,2700
<         return;
---
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
2932,2936c2703,2706
<     if (swServer_is_udp(fd))
< 	{
< 		swWarn("udp cannot sendwait.");
< 		RETURN_FALSE;
< 	}
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz", &fd, &zdata) == FAILURE)
>     {
>         return;
>     }
2938c2708
<     char *data = NULL;
---
>     char *data;
2940c2710,2715
<     if (length <= 0 || !data)
---
> 
>     if (length < 0)
>     {
>         RETURN_FALSE;
>     }
>     else if (length == 0)
2942,2943c2717,2718
<     	swWarn("data is empty.");
<     	RETURN_FALSE;
---
>         swoole_php_fatal_error(E_WARNING, "data is empty.");
>         RETURN_FALSE;
2945a2721,2722
>     swServer *serv = swoole_get_object(zobject);
> 
2948c2725
<         swWarn("cannot sendwait.");
---
>         swoole_php_fatal_error(E_WARNING, "cannot sendwait.");
2952c2729,2739
<     SW_CHECK_RETURN(swServer_tcp_sendwait(serv, fd, data, length));
---
>     //UDP
>     if (swServer_is_udp(fd))
>     {
>         swoole_php_fatal_error(E_WARNING, "cannot sendwait.");
>         RETURN_FALSE;
>     }
>     //TCP
>     else
>     {
>         SW_CHECK_RETURN(swServer_tcp_sendwait(serv, fd, data, length));
>     }
2957,2969c2744,2752
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
---
>     zval *zobject = getThis();
> 
>     long fd;
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
2971,2972c2754
<     long fd = -1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &fd))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &fd) == FAILURE)
2976a2759,2760
>     swServer *serv = swoole_get_object(zobject);
> 
2978c2762
<     if (!conn || conn->active == 0 || conn->closed)
---
>     if (!conn)
2982,2983c2766,2774
< 
<     RETURN_TRUE;
---
>     //connection is closed
>     if (conn->active == 0 || conn->closed)
>     {
>         RETURN_FALSE;
>     }
>     else
>     {
>         RETURN_TRUE;
>     }
2988,3001d2778
< 	if (!SwooleGS->start)
< 	{
< 		swWarn("Server is not running.");
< 		RETURN_FALSE;
< 	}
< 
< 	zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
3004c2781,2788
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|b", &fd, &value))
---
> 
>     if (SwooleGS->start == 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
>         RETURN_FALSE;
>     }
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|b", &fd, &value) == FAILURE)
3009,3014c2793
<     swConnection *conn = swWorker_get_connection(serv, fd);
<     if (!conn || conn->active == 0 || conn->closed)
< 	{
< 		swWarn("connection is invailed.");
< 		RETURN_FALSE;
< 	}
---
>     swServer *serv = swoole_get_object(getThis());
3016,3017c2795,2809
< 	conn->protect = value;
< 	RETURN_TRUE;
---
>     swConnection *conn = swWorker_get_connection(serv, fd);
>     if (!conn)
>     {
>         RETURN_FALSE;
>     }
>     //connection is closed
>     if (conn->active == 0 || conn->closed)
>     {
>         RETURN_FALSE;
>     }
>     else
>     {
>         conn->protect = value;
>         RETURN_TRUE;
>     }
3022c2814
<     if (!SwooleGS->start)
---
>     if (SwooleGS->start == 0)
3024c2816
<         swWarn("Server is not running.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
3028,3036c2820
<     zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     if (swKill(SwooleGS->master_pid, SIGTERM) < 0)
---
>     if (kill(SwooleGS->master_pid, SIGTERM) < 0)
3041,3042c2825,2828
< 
<     RETURN_TRUE;
---
>     else
>     {
>         RETURN_TRUE;
>     }
3047c2833
<     if (!SwooleGS->start)
---
>     if (SwooleGS->start == 0)
3049c2835
<         swWarn("Server is not running.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is not running.");
3053,3060d2838
<     zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
3062c2840
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &worker_id))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &worker_id) == FAILURE)
3075c2853,2857
<         if (!worker || swKill(worker->pid, SIGTERM) < 0)
---
>         if (worker == NULL)
>         {
>             RETURN_FALSE;
>         }
>         else if (kill(worker->pid, SIGTERM) < 0)
3081d2862
< 
3090,3120d2870
< PHP_METHOD(swoole_server, denyRequest)
< {
<     if (!SwooleGS->start)
<     {
<         swWarn("Server is not running.");
<         RETURN_FALSE;
<     }
< 
<     zval* zobject = getThis();
< 	swServer *serv = swoole_get_object(zobject);
< 	if (!serv)
< 	{
< 		swWarn("not create servers.");
< 		RETURN_FALSE;
< 	}
< 
<     long nWorkerId = -1;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &nWorkerId))
<     {
<         return;
<     }
< 
<     swServer_tcp_deny_request(serv, nWorkerId);
< }
< 
< PHP_METHOD(swoole_server, exit)
< {
<     SwooleG.running = 0;
<     SwooleG.main_reactor->running = 0;
< }
< 
3139a2890,2891
>     swConnection *conn;
> 
3143c2895,2896
<     	swConnection *conn = &SwooleG.serv->connection_list[fd];
---
>         conn = &SwooleG.serv->connection_list[fd];
> 
3181a2935,2943
> 
> /*
>  * Local variables:
>  * tab-width: 4
>  * c-basic-offset: 4
>  * End:
>  * vim600: noet sw=4 ts=4 fdm=marker
>  * vim<600: noet sw=4 ts=4
>  */
diff -r ./zan-extension/swoole_server_port.c ../swoole-1.8.5-stable/swoole_server_port.c
18,25d17
< #include "swBaseOperator.h"
< 
< static char *callback[PHP_SERVER_PORT_CALLBACK_NUM] = {
<         "Connect",
<         "Receive",
<         "Close",
<         "Packet",
< };
35,45d26
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_void, 0, 0, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_port_set, 0, 0, 1)
<     ZEND_ARG_ARRAY_INFO(0, set, 0)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_port_on, 0, 0, 2)
<     ZEND_ARG_INFO(0, name)
<     ZEND_ARG_INFO(0, callback)
< ZEND_END_ARG_INFO()
48,51c29,32
<     PHP_ME(swoole_server_port, __construct,     arginfo_swoole_void, ZEND_ACC_PRIVATE | ZEND_ACC_CTOR)
<     PHP_ME(swoole_server_port, __destruct,      arginfo_swoole_void, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
<     PHP_ME(swoole_server_port, set,             arginfo_swoole_server_port_set, ZEND_ACC_PUBLIC)
<     PHP_ME(swoole_server_port, on,              arginfo_swoole_server_port_on, ZEND_ACC_PUBLIC)
---
>     PHP_ME(swoole_server_port, __construct,     NULL, ZEND_ACC_PRIVATE | ZEND_ACC_CTOR)
>     PHP_ME(swoole_server_port, __destruct,      NULL, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
>     PHP_ME(swoole_server_port, set,             NULL, ZEND_ACC_PUBLIC)
>     PHP_ME(swoole_server_port, on,              NULL, ZEND_ACC_PUBLIC)
59,73d39
< 
<     zend_declare_property_null(swoole_server_port_class_entry_ptr,ZEND_STRL("setting"),ZEND_ACC_PUBLIC TSRMLS_CC);
< 
<     char property_name[128] = {0};
<     memcpy(property_name, "on", 2);
<     int index = 0;
<     for (index = 0; index < PHP_SERVER_PORT_CALLBACK_NUM; index++)
<     {
<     	int l_property_name = 2;
< 		int callbackLen = strlen(callback[index]);
< 		memcpy(property_name + l_property_name, callback[index],callbackLen);
< 		l_property_name += callbackLen;
< 		property_name[l_property_name] = '\0';
< 		zend_declare_property_null(swoole_server_port_class_entry_ptr,property_name,l_property_name,ZEND_ACC_PUBLIC TSRMLS_CC);
<     }
84,86c50,52
<     swoole_server_port_property *property = swoole_get_property(getThis(), swoole_property_common);
<     swoole_efree(property);
<     swoole_set_property(getThis(), swoole_property_common, NULL);
---
>     swoole_server_port_property *property = swoole_get_property(getThis(), 0);
>     efree(property);
>     swoole_set_property(getThis(), 0, NULL);
92,99d57
< 	swListenPort *port = swoole_get_object(getThis());
< 	swoole_server_port_property *property = swoole_get_property(getThis(), swoole_property_common);
< 	if (port == NULL || property == NULL)
< 	{
< 		swoole_php_fatal_error(E_ERROR, "Please use the swoole_server->listen method.");
< 		return;
< 	}
< 
101c59,71
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &zset))
---
>     HashTable *vht;
>     zval *v;
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "z", &zset) == FAILURE)
>     {
>         return;
>     }
> 
>     vht = Z_ARRVAL_P(zset);
>     swListenPort *port = swoole_get_object(getThis());
>     swoole_server_port_property *property = swoole_get_property(getThis(), 0);
> 
>     if (port == NULL || property == NULL)
102a73
>         swoole_php_fatal_error(E_ERROR, "Please use the swoole_server->listen method.");
107c78
<     HashTable *vht = Z_ARRVAL_P(zset);
---
> 
109,110c80
<     zval *value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("backlog"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("backlog"), (void **) &v) == SUCCESS)
112,113c82,83
<         convert_to_long(value);
<         port->backlog = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->backlog = (int) Z_LVAL_P(v);
116,117c86
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_tcp_nodelay"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_tcp_nodelay"), (void **) &v) == SUCCESS)
119,120c88,89
<         convert_to_boolean(value);
<         port->open_tcp_nodelay = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_tcp_nodelay = Z_BVAL_P(v);
123,124c92
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_defer_accept"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_defer_accept"), (void **) &v) == SUCCESS)
126,127c94,95
<         convert_to_long(value);
<         port->tcp_defer_accept = (uint8_t) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->tcp_defer_accept = (uint8_t) Z_LVAL_P(v);
130,131c98
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_tcp_keepalive"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_tcp_keepalive"), (void **) &v) == SUCCESS)
133,134c100,101
<         convert_to_boolean(value);
<         port->open_tcp_keepalive = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_tcp_keepalive = Z_BVAL_P(v);
137,138c104
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_eof_split"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_eof_split"), (void **) &v) == SUCCESS)
140,142c106,111
<         convert_to_boolean(value);
<         port->protocol.split_by_eof = Z_BVAL_P(value);
<         port->open_eof_check = (port->protocol.split_by_eof)? 1:port->open_eof_check;
---
>         convert_to_boolean(v);
>         port->protocol.split_by_eof = Z_BVAL_P(v);
>         if (port->protocol.split_by_eof)
>         {
>             port->open_eof_check = 1;
>         }
145,146c114
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_eof"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_eof"), (void **) &v) == SUCCESS)
148,149c116,117
<         convert_to_string(value);
<         port->protocol.package_eof_len = Z_STRLEN_P(value);
---
>         convert_to_string(v);
>         port->protocol.package_eof_len = Z_STRLEN_P(v);
155d122
< 
157c124
<         memcpy(port->protocol.package_eof, Z_STRVAL_P(value), Z_STRLEN_P(value));
---
>         memcpy(port->protocol.package_eof, Z_STRVAL_P(v), Z_STRLEN_P(v));
160,161c127
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_http_protocol"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_http_protocol"), (void **) &v) == SUCCESS)
163,164c129,130
<         convert_to_boolean(value);
<         port->open_http_protocol = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_http_protocol = Z_BVAL_P(v);
167,168c133
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_websocket_protocol"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_websocket_protocol"), (void **) &v) == SUCCESS)
170,171c135,136
<         convert_to_boolean(value);
<         port->open_websocket_protocol = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_websocket_protocol = Z_BVAL_P(v);
175,176c140
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_http2_protocol"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_http2_protocol"), (void **) &v) == SUCCESS)
178,179c142,143
<         convert_to_boolean(value);
<         port->open_http2_protocol = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_http2_protocol = Z_BVAL_P(v);
183,184c147
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_mqtt_protocol"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_mqtt_protocol"), (void **) &v) == SUCCESS)
186,187c149,150
<         convert_to_boolean(value);
<         port->open_mqtt_protocol = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_mqtt_protocol = Z_BVAL_P(v);
190,191c153
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_keepidle"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_keepidle"), (void **) &v) == SUCCESS)
193,194c155,156
<         convert_to_long(value);
<         port->tcp_keepidle = (uint16_t) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->tcp_keepidle = (uint16_t) Z_LVAL_P(v);
197,198c159
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_keepinterval"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_keepinterval"), (void **) &v) == SUCCESS)
200,201c161,162
<         convert_to_long(value);
<         port->tcp_keepinterval = (uint16_t) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->tcp_keepinterval = (uint16_t) Z_LVAL_P(v);
204,205c165
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_keepcount"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("tcp_keepcount"), (void **) &v) == SUCCESS)
207,208c167,168
<         convert_to_long(value);
<         port->tcp_keepcount = (uint16_t) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->tcp_keepcount = (uint16_t) Z_LVAL_P(v);
211,212c171
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("open_length_check"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("open_length_check"), (void **) &v) == SUCCESS)
214,215c173,174
<         convert_to_boolean(value);
<         port->open_length_check = Z_BVAL_P(value);
---
>         convert_to_boolean(v);
>         port->open_length_check = Z_BVAL_P(v);
218,219c177
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_type"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_type"), (void **) &v) == SUCCESS)
221,222c179,180
<         convert_to_string(value);
<         port->protocol.package_length_type = Z_STRVAL_P(value)[0];
---
>         convert_to_string(v);
>         port->protocol.package_length_type = Z_STRVAL_P(v)[0];
232,233c190
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_offset"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_length_offset"), (void **) &v) == SUCCESS)
235,236c192,193
<         convert_to_long(value);
<         port->protocol.package_length_offset = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->protocol.package_length_offset = (int) Z_LVAL_P(v);
239,249c196,197
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_body_offset"), (void **) &value) == SUCCESS
<             || sw_zend_hash_find(vht, ZEND_STRS("package_body_start"), (void **) &value) == SUCCESS)
<     {
<         convert_to_long(value);
<         port->protocol.package_body_offset = (int) Z_LVAL_P(value);
<     }
< 
<     /// package max length
<     value = NULL;
<     if (sw_zend_hash_find(vht, ZEND_STRS("package_max_length"), (void **) &value) == SUCCESS)
---
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_body_offset"), (void **) &v) == SUCCESS
>             || sw_zend_hash_find(vht, ZEND_STRS("package_body_start"), (void **) &v) == SUCCESS)
251,252c199,200
<         convert_to_long(value);
<         port->protocol.package_max_length = (int) Z_LVAL_P(value);
---
>         convert_to_long(v);
>         port->protocol.package_body_offset = (int) Z_LVAL_P(v);
254,255c202,212
< 
<     /// swoole_packet_mode
---
>     /**
>      * package max length
>      */
>     if (sw_zend_hash_find(vht, ZEND_STRS("package_max_length"), (void **) &v) == SUCCESS)
>     {
>         convert_to_long(v);
>         port->protocol.package_max_length = (int) Z_LVAL_P(v);
>     }
>     /**
>      * swoole_packet_mode
>      */
269,270c226
<     	value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_cert_file"), (void **) &value) == SUCCESS)
---
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_cert_file"), (void **) &v) == SUCCESS)
272,273c228,229
<             convert_to_string(value);
<             if (access(Z_STRVAL_P(value), R_OK) < 0)
---
>             convert_to_string(v);
>             if (access(Z_STRVAL_P(v), R_OK) < 0)
275c231
<                 swoole_php_fatal_error(E_ERROR, "ssl cert file[%s] not found.", Z_STRVAL_P(value));
---
>                 swoole_php_fatal_error(E_ERROR, "ssl cert file[%s] not found.", Z_STRVAL_P(v));
278c234
<             port->ssl_cert_file = strdup(Z_STRVAL_P(value));
---
>             port->ssl_cert_file = strdup(Z_STRVAL_P(v));
281,282c237
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_key_file"), (void **) &value) == SUCCESS)
---
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_key_file"), (void **) &v) == SUCCESS)
284,285c239,240
<             convert_to_string(value);
<             if (access(Z_STRVAL_P(value), R_OK) < 0)
---
>             convert_to_string(v);
>             if (access(Z_STRVAL_P(v), R_OK) < 0)
287c242
<                 swoole_php_fatal_error(E_ERROR, "ssl key file[%s] not found.", Z_STRVAL_P(value));
---
>                 swoole_php_fatal_error(E_ERROR, "ssl key file[%s] not found.", Z_STRVAL_P(v));
290c245
<             port->ssl_key_file = strdup(Z_STRVAL_P(value));
---
>             port->ssl_key_file = strdup(Z_STRVAL_P(v));
292,293c247
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_method"), (void **) &value) == SUCCESS)
---
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_method"), (void **) &v) == SUCCESS)
295,296c249,250
<             convert_to_long(value);
<             port->ssl_method = (int) Z_LVAL_P(value);
---
>             convert_to_long(v);
>             port->ssl_method = (int) Z_LVAL_P(v);
299,300c253
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_client_cert_file"), (void **) &value) == SUCCESS)
---
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_client_cert_file"), (void **) &v) == SUCCESS)
302,303c255,256
<             convert_to_string(value);
<             if (access(Z_STRVAL_P(value), R_OK) < 0)
---
>             convert_to_string(v);
>             if (access(Z_STRVAL_P(v), R_OK) < 0)
308c261
<             port->ssl_client_cert_file = strdup(Z_STRVAL_P(value));
---
>             port->ssl_client_cert_file = strdup(Z_STRVAL_P(v));
310,311c263
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_verify_depth"), (void **) &value) == SUCCESS)
---
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_verify_depth"), (void **) &v) == SUCCESS)
313,314c265,266
<             convert_to_long(value);
<             port->ssl_verify_depth = (int) Z_LVAL_P(value);
---
>             convert_to_long(v);
>             port->ssl_verify_depth = (int) Z_LVAL_P(v);
316d267
< 
322,335c273
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_prefer_server_ciphers"), (void **) &value) == SUCCESS)
<         {
<             convert_to_boolean(value);
<             port->ssl_config.prefer_server_ciphers = Z_BVAL_P(value);
<         }
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_ciphers"), (void **) &value) == SUCCESS)
<         {
<             convert_to_string(value);
<             port->ssl_config.ciphers = strdup(Z_STRVAL_P(value));
<         }
<         value = NULL;
<         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_ecdh_curve"), (void **) &value) == SUCCESS)
---
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_prefer_server_ciphers"), (void **) &v) == SUCCESS)
337,338c275,276
<             convert_to_string(value);
<             port->ssl_config.ecdh_curve = strdup(Z_STRVAL_P(value));
---
>             convert_to_boolean(v);
>             port->ssl_config.prefer_server_ciphers = Z_BVAL_P(v);
340c278,307
< 
---
>         //    if (sw_zend_hash_find(vht, ZEND_STRS("ssl_session_tickets"), (void **) &v) == SUCCESS)
>         //    {
>         //        convert_to_boolean(v);
>         //        port->ssl_config.session_tickets = Z_BVAL_P(v);
>         //    }
>         //    if (sw_zend_hash_find(vht, ZEND_STRS("ssl_stapling"), (void **) &v) == SUCCESS)
>         //    {
>         //        convert_to_boolean(v);
>         //        port->ssl_config.stapling = Z_BVAL_P(v);
>         //    }
>         //    if (sw_zend_hash_find(vht, ZEND_STRS("ssl_stapling_verify"), (void **) &v) == SUCCESS)
>         //    {
>         //        convert_to_boolean(v);
>         //        port->ssl_config.stapling_verify = Z_BVAL_P(v);
>         //    }
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_ciphers"), (void **) &v) == SUCCESS)
>         {
>             convert_to_string(v);
>             port->ssl_config.ciphers = strdup(Z_STRVAL_P(v));
>         }
>         if (sw_zend_hash_find(vht, ZEND_STRS("ssl_ecdh_curve"), (void **) &v) == SUCCESS)
>         {
>             convert_to_string(v);
>             port->ssl_config.ecdh_curve = strdup(Z_STRVAL_P(v));
>         }
>         //    if (sw_zend_hash_find(vht, ZEND_STRS("ssl_session_cache"), (void **) &v) == SUCCESS)
>         //    {
>         //        convert_to_string(v);
>         //        port->ssl_config.session_cache = strdup(Z_STRVAL_P(v));
>         //    }
348a316,319
>     char *name = NULL;
>     zend_size_t len, i;
>     zval *cb;
> 
351c322
<         swWarn("Server is running. Unable to set event callback now.");
---
>         swoole_php_fatal_error(E_WARNING, "Server is running. Unable to set event callback now.");
355,366c326
<     swListenPort *port = swoole_get_object(getThis());
< 	swoole_server_port_property *property = swoole_get_property(getThis(), swoole_property_common);
< 	if (port == NULL || property == NULL)
< 	{
< 		swoole_php_fatal_error(E_ERROR, "Please use the swoole_server->listen method.");
< 		return;
< 	}
< 
<     char *name = NULL;
< 	zend_size_t len = 0;
< 	zval *cb = NULL;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "sz", &name, &len, &cb))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS()TSRMLS_CC, "sz", &name, &len, &cb) == FAILURE)
371c331,333
<     if (!name || len <= 0)
---
> #ifdef PHP_SWOOLE_CHECK_CALLBACK
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(cb, 0, &func_name TSRMLS_CC))
373c335,337
<     	return;
---
>         swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
>         return;
374a339,340
>     efree(func_name);
> #endif
376,377c342,345
< #ifdef PHP_SWOOLE_CHECK_CALLBACK
<     if (swoole_check_callable(cb TSRMLS_CC) < 0)
---
>     swoole_server_port_property *property = swoole_get_property(getThis(), 0);
> 
>     swListenPort *port = swoole_get_object(getThis());
>     if (!port->ptr)
379c347
<     	return;
---
>         port->ptr = property;
381d348
< #endif
383c350,355
<     port->ptr = (!port->ptr)? property:port->ptr;
---
>     char *callback[PHP_SERVER_PORT_CALLBACK_NUM] = {
>         "Connect",
>         "Receive",
>         "Close",
>         "Packet",
>     };
385c357,358
<     char property_name[128] = {0};
---
>     char property_name[128];
>     int l_property_name = 0;
387d359
<     int l_property_name = 2;
389,390c361
<     int index = 0;
<     for (index = 0; index < PHP_SERVER_PORT_CALLBACK_NUM; index++)
---
>     for (i = 0; i < PHP_SERVER_PORT_CALLBACK_NUM; i++)
392c363
<         if (len == strlen(callback[index]) && strncasecmp(callback[index], name, len) == 0)
---
>         if (strncasecmp(callback[i], name, len) == 0)
394,395c365,366
<             memcpy(property_name + l_property_name, callback[index], len);
<             l_property_name += len;
---
>             memcpy(property_name + 2, callback[i], len);
>             l_property_name = len + 2;
398,399c369,370
<             property->callbacks[index] = sw_zend_read_property(swoole_server_port_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);
<             sw_copy_to_stack(property->callbacks[index], property->_callbacks[index]);
---
>             property->callbacks[i] = sw_zend_read_property(swoole_server_port_class_entry_ptr, getThis(), property_name, l_property_name, 0 TSRMLS_CC);
>             sw_copy_to_stack(property->callbacks[i], property->_callbacks[i]);
401c372
<             if (index == SW_SERVER_CB_onConnect && !SwooleG.serv->onConnect)
---
>             if (i == SW_SERVER_CB_onConnect && SwooleG.serv->onConnect == NULL)
405c376
<             else if (index == SW_SERVER_CB_onClose && !SwooleG.serv->onClose)
---
>             else if (i == SW_SERVER_CB_onClose && SwooleG.serv->onClose == NULL)
409d379
< 
414c384
<     if (index == PHP_SERVER_PORT_CALLBACK_NUM)
---
>     if (l_property_name == 0)
416c386
<         swWarn("Unknown event types[%s]", name);
---
>         swoole_php_error(E_WARNING, "Unknown event types[%s]", name);
419d388
< 
Only in ../swoole-1.8.5-stable/: swoole_table.c
diff -r ./zan-extension/swoole_timer.c ../swoole-1.8.5-stable/swoole_timer.c
20d19
< #include "swWork.h"
24,25c23
<     SW_TIMER_TICK,
<     SW_TIMER_AFTER,
---
>     SW_TIMER_TICK, SW_TIMER_AFTER,
30,33d27
< #if PHP_MAJOR_VERSION >= 7
< 	zval  _data;
< 	zval  _callback ;
< #endif
35a30,33
> #if PHP_MAJOR_VERSION >= 7
>     zval _callback;
>     zval _data;
> #endif
40,82c38
< static void swoole_php_onTimeout(swTimer *timer, swTimer_node *tnode);
< static void swoole_php_onInterval(swTimer *timer, swTimer_node *tnode);
< static int php_swoole_check_timer(int msec);
< 
< static long php_swoole_add_timer(long ms, zval *callback, zval *param, int is_tick TSRMLS_DC);
< static void php_swoole_del_timer(void* data);
< 
< static zend_class_entry swoole_timer_ce;
< zend_class_entry *swoole_timer_class_entry_ptr;
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_tick, 0, 0, 2)
<     ZEND_ARG_INFO(0, ms)
<     ZEND_ARG_INFO(0, callback)
<     ZEND_ARG_INFO(0, param)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_after, 0, 0, 2)
<     ZEND_ARG_INFO(0, ms)
<     ZEND_ARG_INFO(0, callback)
<     ZEND_ARG_INFO(0, param)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_clear, 0, 0, 1)
<     ZEND_ARG_INFO(0, timer_id)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_set, 0, 0, 1)
<     ZEND_ARG_INFO(0, settings)
< ZEND_END_ARG_INFO()
< 
< ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_timer_exists, 0, 0, 1)
<     ZEND_ARG_INFO(0, timer_id)
< ZEND_END_ARG_INFO()
< 
< static const zend_function_entry swoole_timer_methods[] =
< {
<     ZEND_FENTRY(tick, ZEND_FN(swoole_timer_tick), arginfo_swoole_timer_after, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     ZEND_FENTRY(after, ZEND_FN(swoole_timer_after), arginfo_swoole_timer_tick, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     ZEND_FENTRY(exists, ZEND_FN(swoole_timer_exists), arginfo_swoole_timer_exists, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     ZEND_FENTRY(clear, ZEND_FN(swoole_timer_clear), arginfo_swoole_timer_clear, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
< 	ZEND_FENTRY(set, ZEND_FN(swoole_timer_set), arginfo_swoole_timer_set, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
<     PHP_FE_END
< };
---
> static swHashMap *timer_map;
84,89c40,43
< void swoole_timer_init(int module_number TSRMLS_DC)
< {
< 	memset(&timer_cfg,0x00,sizeof(swTimer_cfg));
< 	SWOOLE_INIT_CLASS_ENTRY(swoole_timer_ce, "swoole_timer", "Swoole\\Timer", swoole_timer_methods);
< 	swoole_timer_class_entry_ptr = zend_register_internal_class(&swoole_timer_ce TSRMLS_CC);
< }
---
> static void php_swoole_onTimeout(swTimer *timer, swTimer_node *tnode);
> static void php_swoole_onInterval(swTimer *timer, swTimer_node *tnode);
> static long php_swoole_add_timer(int ms, zval *callback, zval *param, int is_tick TSRMLS_DC);
> static int php_swoole_del_timer(swTimer_node *tnode TSRMLS_DC);
91c45
< static long php_swoole_add_timer(long ms, zval *callback, zval *param, int is_tick TSRMLS_DC)
---
> static long php_swoole_add_timer(int ms, zval *callback, zval *param, int is_tick TSRMLS_DC)
95c49,59
<         swWarn("cannot use timer in master process.");
---
>         swoole_php_fatal_error(E_WARNING, "cannot use timer in master process.");
>         return SW_ERR;
>     }
>     if (ms > 86400000)
>     {
>         swoole_php_fatal_error(E_WARNING, "The given parameters is too big.");
>         return SW_ERR;
>     }
>     if (ms <= 0)
>     {
>         swoole_php_fatal_error(E_WARNING, "Timer must be greater than 0");
99c63,64
<     if (ms > 86400000 || ms <= 0)
---
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))
101c66,67
<         swWarn("The given parameters is too big and must be greater than 0.");
---
>         swoole_php_fatal_error(E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
103a70
>     efree(func_name);
110c77,84
<     if (php_swoole_check_timer(ms) < 0)
---
>     php_swoole_check_timer(ms);
>     swTimer_callback *cb = emalloc(sizeof(swTimer_callback));
> 
> #if PHP_MAJOR_VERSION >= 7
>     cb->data = &cb->_data;
>     cb->callback = &cb->_callback;
>     memcpy(cb->callback, callback, sizeof(zval));
>     if (param)
112c86
<     	return SW_ERR;
---
>         memcpy(cb->data, param, sizeof(zval));
113a88,95
>     else
>     {
>         cb->data = NULL;
>     }
> #else
>     cb->data = param;
>     cb->callback = callback;
> #endif
115,116c97,101
<     swTimer_callback *cb = emalloc(sizeof(swTimer_callback));
<     if (!cb)
---
>     if (is_tick)
>     {
>         cb->type = SW_TIMER_TICK;
>     }
>     else
118,119c103
<     	swWarn("alloc swTimer callback failed.");
<     	return SW_ERR;
---
>         cb->type = SW_TIMER_AFTER;
122,144c106,110
<     bzero(cb,sizeof(swTimer_callback));
<     cb->type = (is_tick)? SW_TIMER_TICK:SW_TIMER_AFTER;
< 	long id = swTimer_add(&SwooleG.timer, ms, is_tick, cb,PHPTIMER_USED);
< 	if (id < 0)
< 	{
< 		swWarn("addtimer failed.");
< 		swoole_efree(cb);
< 		return SW_ERR;
< 	}
< 
< 	if (param)
< 	{
< 		cb->data = param;
< 		sw_zval_add_ref(&param);
< 		sw_copy_to_stack(cb->data,cb->_data);
< 	}
< 
< 	if (callback)
< 	{
< 		cb->callback = callback;
< 		sw_zval_add_ref(&callback);
< 		sw_copy_to_stack(cb->callback,cb->_callback);
< 	}
---
>     sw_zval_add_ref(&cb->callback);
>     if (cb->data)
>     {
>         sw_zval_add_ref(&cb->data);
>     }
146c112,122
< 	return id;
---
>     swTimer_node *tnode = swTimer_add(&SwooleG.timer, ms, is_tick, cb);
>     if (tnode == NULL)
>     {
>         swoole_php_fatal_error(E_WARNING, "addtimer failed.");
>         return SW_ERR;
>     }
>     else
>     {
>         swHashMap_add_int(timer_map, tnode->id, tnode);
>         return tnode->id;
>     }
149c125
< static void php_swoole_del_timer(void* data)
---
> static int php_swoole_del_timer(swTimer_node *tnode TSRMLS_DC)
151,156c127,146
< 	swTimer_callback* cb = data;
<     if (cb && cb->callback) {sw_zval_ptr_dtor(&cb->callback);cb->callback = NULL;}
<     if (cb && cb->data)	{sw_zval_ptr_dtor(&cb->data);cb->data = NULL;}
<     if (cb) swoole_efree(cb);
< 
<     return;
---
>     if (swHashMap_del_int(timer_map, tnode->id) < 0)
>     {
>         return SW_ERR;
>     }
>     tnode->id = -1;
>     swTimer_callback *cb = tnode->data;
>     if (!cb)
>     {
>         return SW_ERR;
>     }
>     if (cb->callback)
>     {
>         sw_zval_ptr_dtor(&cb->callback);
>     }
>     if (cb->data)
>     {
>         sw_zval_ptr_dtor(&cb->data);
>     }
>     efree(cb);
>     return SW_OK;
159c149
< static void swoole_php_onTimeout(swTimer *timer, swTimer_node *tnode)
---
> static void php_swoole_onTimeout(swTimer *timer, swTimer_node *tnode)
161c151,153
<     SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
164,199c156,172
< 	if (!cb)
< 	{
< 		swWarn("swoole_timer_onTimeout: swTimer_callback is NULL");
< 		swTimer_del(timer,tnode->id);
< 		return;
< 	}
< 
< 	if (!cb->callback || PHPTIMER_USED != tnode->used_type)
< 	{
< 		swWarn("no callback or php_used flag not used.");
< 		swTimer_del(timer,tnode->id);
< 		return;
< 	}
< 
< 	zval **args[1];
< 	int argc = (cb->data)? 1:0;
< 	if (cb->data)
< 	{
< 		args[0] = &cb->data;
< 	}
< 
< 	zval *retval = NULL;
< 	if (sw_call_user_function_ex(EG(function_table), NULL, cb->callback, &retval, argc, args, 0, NULL TSRMLS_CC) == FAILURE)
< 	{
< 		swWarn("swoole_timer: onTimeout handler error");
< 	}
< 
< 	if (EG(exception))
< 	{
< 		zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
< 	}
< 
< 	if (retval)
< 	{
< 		sw_zval_ptr_dtor(&retval);
< 	}
---
>     zval *retval = NULL;
>     zval **args[1];
>     int argc = 0;
> 
>     if (cb->data)
>     {
>         args[0] = &cb->data;
>         argc = 1;
>     }
> 
>     timer->_current_id = tnode->id;
>     if (sw_call_user_function_ex(EG(function_table), NULL, cb->callback, &retval, argc, args, 0, NULL TSRMLS_CC) == FAILURE)
>     {
>         swoole_php_fatal_error(E_WARNING, "swoole_timer: onTimeout handler error");
>         return;
>     }
>     timer->_current_id = -1;
201c174,182
< 	swTimer_del(timer,tnode->id);
---
>     if (EG(exception))
>     {
>         zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
>     }
>     if (retval)
>     {
>         sw_zval_ptr_dtor(&retval);
>     }
>     php_swoole_del_timer(tnode TSRMLS_CC);
204c185
< static void swoole_php_onInterval(swTimer *timer, swTimer_node *tnode)
---
> static void php_swoole_onInterval(swTimer *timer, swTimer_node *tnode)
206,219c187,197
<     SWOOLE_FETCH_TSRMLS;
<     swTimer_callback *cb = tnode? tnode->data:NULL;
< 	if (!cb)
< 	{
< 		swWarn("php_swoole_onInterval: swTimer_callback is NULL");
< 		swTimer_del(timer,tnode->id);
< 		return;
< 	}
< 
< 	if (!cb->callback || PHPTIMER_USED != tnode->used_type)
< 	{
< 		swTimer_del(timer,tnode->id);
< 		return;
< 	}
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
> 
>     zval *retval = NULL;
>     zval **args[2];
>     int argc = 1;
> 
>     zval *ztimer_id;
> 
>     swTimer_callback *cb = tnode->data;
221d198
<     zval *ztimer_id = NULL;
225,228d201
<     zval **args[2];
<     args[0] = &ztimer_id;
< 
<     int argc = (cb->data)? 2:1;
230a204,205
>         argc = 2;
>         sw_zval_add_ref(&cb->data);
234,235c209,211
<     int needDel = 0;
<     zval *retval = NULL;
---
>     args[0] = &ztimer_id;
> 
>     timer->_current_id = tnode->id;
238,239c214,215
<         swWarn("swoole_timer: onTimerCallback handler error");
<         needDel = 1;
---
>         swoole_php_fatal_error(E_WARNING, "swoole_timer: onTimerCallback handler error");
>         return;
240a217
>     timer->_current_id = -1;
246,247c223
< 
<     if (!retval)
---
>     if (retval != NULL)
251d226
< 
254c229
<     if (needDel)
---
>     if (tnode->remove)
256c231
<         swTimer_del(timer,tnode->id);
---
>         php_swoole_del_timer(tnode TSRMLS_CC);
260c235
< static int php_swoole_check_timer(int msec)
---
> void php_swoole_check_timer(int msec)
262,270c237,244
< 	if (swTimer_init(&SwooleG.timer,msec) < 0)
< 	{
< 		return SW_ERR;
< 	}
< 
< 	register_after_cb(&SwooleG.timer,PHPTIMER_USED,swoole_php_onTimeout);
< 	register_tick_cb(&SwooleG.timer,PHPTIMER_USED,swoole_php_onInterval);
< 	register_dict_cb(&SwooleG.timer,PHPTIMER_USED,php_swoole_del_timer);
< 	return SW_OK;
---
>     if (SwooleG.timer.fd == 0)
>     {
>         swTimer_init(msec);
>         SwooleG.timer.onAfter = php_swoole_onTimeout;
>         SwooleG.timer.onTick = php_swoole_onInterval;
> 
>         timer_map = swHashMap_new(SW_HASHMAP_INIT_BUCKET_N, NULL);
>     }
273d246
< /// 周期定时器
276c249
<     long after_ms = 0;
---
>     long after_ms;
279,282d251
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz|z", &after_ms, &callback, &param))
<     {
<         return;
<     }
284c253
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz|z", &after_ms, &callback, &param) == FAILURE)
286c255
<     	RETURN_FALSE;
---
>         return;
294,295c263,266
< 
<     RETURN_LONG(timer_id);
---
>     else
>     {
>         RETURN_LONG(timer_id);
>     }
298d268
< /// 非周期定时器
301c271
<     long after_ms = 0;
---
>     long after_ms;
304c274,275
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz|z", &after_ms, &callback, &param))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz|z", &after_ms, &callback, &param) == FAILURE)
309,314d279
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
<     	swWarn("check callback error.");
< 		RETURN_FALSE;
< 	}
< 
318d282
<     	swWarn("add timer node failed.");
321,349c285,288
< 
<     RETURN_LONG(timer_id);
< }
< 
< PHP_FUNCTION(swoole_timer_set)
< {
< 	zval *zset = NULL;
< 	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &zset))
< 	{
< 		return;
< 	}
< 
< 	zval *value = NULL ;
< 	HashTable *vht = Z_ARRVAL_P(zset);
< 	timer_cfg.use_time_wheel = 1;
< 	if (php_swoole_array_get_value(vht, "use_time_wheel", value))
< 	{
< 		convert_to_long(value);
< 		timer_cfg.use_time_wheel = (uint8_t) Z_LVAL_P(value);
< 	}
< 
< 	value = NULL;
< 	timer_cfg.precision = 100;
< 	if (php_swoole_array_get_value(vht, "time_wheel_precision", value))
< 	{
< 		convert_to_long(value);
< 		int precision = (int)Z_LVAL_P(value);
< 		timer_cfg.precision =  precision < 10? 10:precision;
< 	}
---
>     else
>     {
>         RETURN_LONG(timer_id);
>     }
356c295
<         swWarn("no timer");
---
>         swoole_php_error(E_WARNING, "no timer");
361c300
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &id))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &id) == FAILURE)
366,373c305,306
<     swTimer_del(&SwooleG.timer,id);
< 
< 	RETURN_TRUE;
< }
< 
< PHP_FUNCTION(swoole_timer_exists)
< {
<     if (!SwooleG.timer.set)
---
>     swTimer_node *tnode = swHashMap_find_int(timer_map, id);
>     if (tnode == NULL)
375c308
<         swoole_php_error(E_WARNING, "no timer");
---
>         swoole_php_error(E_WARNING, "timer#%ld is not found.", id);
379,380c312,313
<     long id;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &id))
---
>     //current timer, cannot remove here.
>     if (tnode->id == SwooleG.timer._current_id)
382c315,316
<         return;
---
>         tnode->remove = 1;
>         RETURN_TRUE;
385c319
<     if (!swTimer_exist(&SwooleG.timer,id))
---
>     if (php_swoole_del_timer(tnode TSRMLS_CC) < 0)
387c321,326
<        RETURN_FALSE;
---
>         RETURN_FALSE;
>     }
>     else
>     {
>         swTimer_del(&SwooleG.timer, tnode);
>         RETURN_TRUE;
389,390d327
< 
<     RETURN_TRUE;
diff -r ./zan-extension/swoole_websocket_server.c ../swoole-1.8.5-stable/swoole_websocket_server.c
27,30c27,29
< #include "swError.h"
< #include "swProtocol/websocket.h"
< #include "swConnection.h"
< #include "swProtocol/base64.h"
---
> #include "websocket.h"
> #include "Connection.h"
> #include "base64.h"
33c32
< static zend_class_entry swoole_websocket_server_ce;
---
> zend_class_entry swoole_websocket_server_ce;
36c35
< static zend_class_entry swoole_websocket_frame_ce;
---
> zend_class_entry swoole_websocket_frame_ce;
39c38,44
< static int websocket_handshake(swListenPort *, http_context *);
---
> static int websocket_handshake(swoole_http_client *client);
> static void sha1(const char *str, int _len, unsigned char *digest);
> static zval* websocket_callbacks[2];
> 
> #if PHP_MAJOR_VERSION >= 7
> static zval _websocket_callbacks[2];
> #endif
84c89
< void swoole_websocket_onOpen(http_context *ctx)
---
> int swoole_websocket_isset_onMessage(void)
86c91,98
< 	SWOOLE_FETCH_TSRMLS;
---
>     return (websocket_callbacks[WEBSOCKET_CALLBACK_onMessage] != NULL);
> }
> 
> void swoole_websocket_onOpen(swoole_http_client *client)
> {
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
88c100
<     int fd = ctx->fd;
---
>     int fd = client->fd;
98,99c110
<     zval *zcallback = php_swoole_server_get_callback(SwooleG.serv, conn->from_fd, SW_SERVER_CB_onOpen);
<     if (zcallback)
---
>     if (websocket_callbacks[WEBSOCKET_CALLBACK_onOpen])
104c115
<         zval *zrequest_object = ctx->request.zobject;
---
>         zval *zrequest_object = client->context.request.zrequest_object;
106a118,122
> #ifdef __CYGWIN__
>         //TODO: memory error on cygwin.
>         sw_zval_add_ref(&zrequest_object);
> #endif
> 
110c126
<         if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0,  NULL TSRMLS_CC) == FAILURE)
---
>         if (sw_call_user_function_ex(EG(function_table), NULL, websocket_callbacks[WEBSOCKET_CALLBACK_onOpen], &retval, 2, args, 0,  NULL TSRMLS_CC) == FAILURE)
128c144
< void swoole_websocket_onRequest(http_context *ctx)
---
> void swoole_websocket_onReuqest(swoole_http_client *client)
137c153
<     char buf[512] = {0};
---
>     char buf[512];
140c156,158
<     swServer_tcp_send(SwooleG.serv, ctx->fd, buf, n);
---
>     swServer_tcp_send(SwooleG.serv, client->fd, buf, n);
>     SwooleG.serv->factory.end(&SwooleG.serv->factory, client->fd);
> }
142,144c160,165
<     ctx->end = 1;
<     SwooleG.serv->factory.end(&SwooleG.serv->factory, ctx->fd);
<     ctx->response.release = 1;
---
> static void sha1(const char *str, int _len, unsigned char *digest)
> {
>     PHP_SHA1_CTX context;
>     PHP_SHA1Init(&context);
>     PHP_SHA1Update(&context, (unsigned char *) str, _len);
>     PHP_SHA1Final(digest, &context);
147c168
< static int websocket_handshake(swListenPort *port, http_context *ctx)
---
> static int websocket_handshake(swoole_http_client *client)
149c170,172
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
151c174
<     zval *header = ctx->request.zheader;
---
>     zval *header = client->context.request.zheader;
166c189
<     char sec_websocket_accept[128] = {0};
---
>     char sec_websocket_accept[128];
170c193
<     char sha1_str[20] = {0};
---
>     char sha1_str[20];
172c195
<     php_swoole_sha1(sec_websocket_accept, Z_STRLEN_P(pData) + sizeof(SW_WEBSOCKET_GUID) - 1, (unsigned char *) sha1_str);
---
>     sha1(sec_websocket_accept, Z_STRLEN_P(pData) + sizeof(SW_WEBSOCKET_GUID) - 1, (unsigned char *) sha1_str);
174c197
<     char encoded_str[50] = {0};
---
>     char encoded_str[50];
178c201
<     char _buf[128] = {0};
---
>     char _buf[128];
180d202
<     n = n > 128?128:n;
184,190d205
< //    if (port->websocket_subprotocol)
< //    {
< //        swString_append_ptr(swoole_http_buffer, ZEND_STRL("Sec-WebSocket-Protocol: "));
< //        swString_append_ptr(swoole_http_buffer, port->websocket_subprotocol, port->websocket_subprotocol_length);
< //        swString_append_ptr(swoole_http_buffer, ZEND_STRL("\r\n"));
< //    }
< 
195c210
<     return swServer_tcp_send(SwooleG.serv, ctx->fd, swoole_http_buffer->str, swoole_http_buffer->length);
---
>     return swServer_tcp_send(SwooleG.serv, client->fd, swoole_http_buffer->str, swoole_http_buffer->length);
200c215,217
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
203d219
< 
205a222
>     zdata = php_swoole_get_recv_data(zdata, req TSRMLS_CC);
207,211c224,226
<     char frame_header[2];
<     php_swoole_get_recv_data(zdata, req, frame_header, 2);
< 
<     long finish = frame_header[0] ? 1 : 0;
<     long opcode = frame_header[1];
---
>     char *buf = Z_STRVAL_P(zdata);
>     long finish = buf[0] ? 1 : 0;
>     long opcode = buf[1];
220c235,243
<     zend_update_property(swoole_websocket_frame_class_entry_ptr, zframe, ZEND_STRL("data"), zdata TSRMLS_CC);
---
> 
>     if (Z_STRLEN_P(zdata) == 2)
>     {
>         zend_update_property_stringl(swoole_websocket_frame_class_entry_ptr, zframe, ZEND_STRL("data"), "", 0 TSRMLS_CC);
>     }
>     else
>     {
>         zend_update_property_stringl(swoole_websocket_frame_class_entry_ptr, zframe, ZEND_STRL("data"), buf + 2, (Z_STRLEN_P(zdata) - 2) TSRMLS_CC);
>     }
231,233c254,255
< 
<     zval *zcallback = php_swoole_server_get_callback(serv, req->info.from_fd, SW_SERVER_CB_onMessage);
<     if (sw_call_user_function_ex(EG(function_table), NULL, zcallback, &retval, 2, args, 0, NULL TSRMLS_CC) == FAILURE)
---
>     if (sw_call_user_function_ex(EG(function_table), NULL, websocket_callbacks[WEBSOCKET_CALLBACK_onMessage], &retval, 2,
>             args, 0, NULL TSRMLS_CC) == FAILURE)
235c257
<         swoole_php_error(E_WARNING, "onMessage handler error");
---
>         php_error_docref(NULL TSRMLS_CC, E_WARNING, "onMessage handler error");
254c276
< int swoole_websocket_onHandshake(swListenPort *port, http_context *ctx)
---
> int swoole_websocket_onHandshake(swoole_http_client *client)
256c278,280
< 	SWOOLE_FETCH_TSRMLS;
---
> #if PHP_MAJOR_VERSION < 7
>     TSRMLS_FETCH_FROM_CTX(sw_thread_ctx ? sw_thread_ctx : NULL);
> #endif
258,259c282,283
<     int fd = ctx->fd;
<     int ret = websocket_handshake(port, ctx);
---
>     int fd = client->fd;
>     int ret = websocket_handshake(client);
266c290
<         swoole_websocket_onOpen(ctx);
---
>         swoole_websocket_onOpen(client);
269c293,294
<     if (!ctx->end)
---
>     //free client data
>     if (!client->context.end)
271,272c296
<     	//free client data
<     	ctx->response.release = 1;
---
>         swoole_http_context_free(&client->context TSRMLS_CC);
322c346
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &event_name, &callback))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &event_name, &callback) == FAILURE)
329,333c353,360
<     if (swoole_check_callable(callback TSRMLS_CC) < 0)
< 	{
< 		swoole_php_fatal_error(E_WARNING,"user must set callback.");
< 		RETURN_FALSE;
< 	}
---
>     char *func_name = NULL;
>     if (!sw_zend_is_callable(callback, 0, &func_name TSRMLS_CC))
>     {
>         php_error_docref(NULL TSRMLS_CC, E_ERROR, "Function '%s' is not callable", func_name);
>         efree(func_name);
>         RETURN_FALSE;
>     }
>     efree(func_name);
337c364
<     if (Z_STRLEN_P(event_name) == strlen("open") && strncasecmp("open", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)
---
>     if (strncasecmp("open", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)
340,341c367,368
<         php_sw_server_callbacks[SW_SERVER_CB_onOpen] = sw_zend_read_property(swoole_websocket_server_class_entry_ptr, getThis(), ZEND_STRL("onOpen"), 0 TSRMLS_CC);
<         sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onOpen], _php_sw_server_callbacks[SW_SERVER_CB_onOpen]);
---
>         websocket_callbacks[0] = sw_zend_read_property(swoole_websocket_server_class_entry_ptr, getThis(), ZEND_STRL("onOpen"), 0 TSRMLS_CC);
>         sw_copy_to_stack(websocket_callbacks[0], _websocket_callbacks[0]);
343c370
<     else if (Z_STRLEN_P(event_name) == strlen("message") && strncasecmp("message", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)
---
>     else if (strncasecmp("message", Z_STRVAL_P(event_name), Z_STRLEN_P(event_name)) == 0)
346,347c373,374
<         php_sw_server_callbacks[SW_SERVER_CB_onMessage] = sw_zend_read_property(swoole_websocket_server_class_entry_ptr, getThis(), ZEND_STRL("onMessage"), 0 TSRMLS_CC);
<         sw_copy_to_stack(php_sw_server_callbacks[SW_SERVER_CB_onMessage], _php_sw_server_callbacks[SW_SERVER_CB_onMessage]);
---
>         websocket_callbacks[1] = sw_zend_read_property(swoole_websocket_server_class_entry_ptr, getThis(), ZEND_STRL("onMessage"), 0 TSRMLS_CC);
>         sw_copy_to_stack(websocket_callbacks[1], _websocket_callbacks[1]);
362c389,390
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz|lb", &fd, &zdata, &opcode, &fin))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "lz|lb", &fd, &zdata, &opcode, &fin) == FAILURE)
369c397
<         swWarn("fd[%d] is invalid.", (int )fd);
---
>         swoole_php_fatal_error(E_WARNING, "fd[%d] is invalid.", (int )fd);
375c403
<         swWarn("opcode max 10");
---
>         swoole_php_fatal_error(E_WARNING, "opcode max 10");
395c423
<         swWarn("connection[%d] is not a websocket client.", (int ) fd);
---
>         swoole_php_fatal_error(E_WARNING, "connection[%d] is not a websocket client.", (int ) fd);
410c438,439
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|lbb", &data, &length, &opcode, &finish, &mask))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|lbb", &data, &length, &opcode, &finish, &mask) == FAILURE)
417c446
<         swWarn("opcode max 10");
---
>         swoole_php_fatal_error(E_WARNING, "opcode max 10");
423c452
<         swWarn("data is empty.");
---
>         swoole_php_fatal_error(E_WARNING, "data is empty.");
445c474,475
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &buffer.str, &buffer.length))
---
> 
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &buffer.str, &buffer.length) == FAILURE)
455a486,488
>     zval *zobject = getThis();
>     long fd;
> 
462,463c495
<     long fd;
<     if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &fd))
---
>     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &fd) == FAILURE)
468d499
<     zval *zobject = getThis();
480,489d510
<     swConnection *server_sock = swServer_connection_get(serv, conn->from_fd);
<     if (server_sock)
<     {
<         swListenPort *port = server_sock->object;
<         //not websocket port
<         if (port && !port->open_websocket_protocol)
<         {
<             RETURN_TRUE;
<         }
<     }
diff -r ./zan-extension/tests/aio.c ../swoole-1.8.5-stable/tests/aio.c
26c26
< 	char *outbuf = sw_malloc(BUF_SIZE);
---
> 	char *outbuf = malloc(BUF_SIZE);
diff -r ./zan-extension/tests/client.c ../swoole-1.8.5-stable/tests/client.c
44c44
< 	ret = cli.send(&cli, SW_STRL("TCP: hello world"));
---
> 	ret = cli.send(&cli, SW_STRL("TCP: hello world"), 0);
73c73
< 	ret = cli2.send(&cli2, SW_STRL("UDP: hello world"));
---
> 	ret = cli2.send(&cli2, SW_STRL("UDP: hello world"), 0);
diff -r ./zan-extension/tests/ds.c ../swoole-1.8.5-stable/tests/ds.c
27,32c27,32
< 	swHashMap_add(hm, SW_STRL("hello")-1, (void *)199, NULL);
< 	swHashMap_add(hm, SW_STRL("swoole22")-1, (void *)8877, NULL);
< 	swHashMap_add(hm, SW_STRL("hello2")-1, (void *)200, NULL);
< 	swHashMap_add(hm, SW_STRL("willdel")-1, (void *)888, NULL);
< 	swHashMap_add(hm, SW_STRL("willupadte")-1, (void *)9999, NULL);
< 	swHashMap_add(hm, SW_STRL("hello3")-1, (void *)78978, NULL);
---
> 	swHashMap_add(hm, SW_STRL("hello")-1, (void *)199);
> 	swHashMap_add(hm, SW_STRL("swoole22")-1, (void *)8877);
> 	swHashMap_add(hm, SW_STRL("hello2")-1, (void *)200);
> 	swHashMap_add(hm, SW_STRL("willdel")-1, (void *)888);
> 	swHashMap_add(hm, SW_STRL("willupadte")-1, (void *)9999);
> 	swHashMap_add(hm, SW_STRL("hello3")-1, (void *)78978);
155c155
< 		pkt = (swFdInfo *) sw_malloc(sizeof(swFdInfo));
---
> 		pkt = (swFdInfo *) malloc(sizeof(swFdInfo));
158c158
< 		swHashMap_add_int(ht, i, pkt, NULL);
---
> 		swHashMap_add_int(ht, i, pkt);
181a182,229
> 
> static void linkedlist_pop(swLinkedList *ll, int i)
> {
>     swLinkedList_node *node = swLinkedList_pop_node(ll);
>     if (node)
>     {
>         printf("#%d\tpriority=%ld, value=%d\n", i, node->priority, *(int *) (node->data));
>     }
>     else
>     {
>         printf("#%d\tNULL\n", i);
>     }
> }
> 
> swUnitTest(linkedlist_test)
> {
>     swLinkedList *ll = swLinkedList_new(1, NULL);
>     uint32_t key;
>     int i, j, n;
> #define Q_N   2000
>     int data[Q_N];
>     int *value;
> 
>     for (i = 1; i < Q_N; i++)
>     {
>         data[i] = i;
>         swLinkedList_insert(ll, rand() % 10000, & data[i]);
> 
>         if (i % 200 == 150 && ll->num > 150)
>         {
>             n = rand() % 150 + 10;
>             printf("count=%d, pop n=%d\n", ll->num,  n);
> 
>             for (j = 0; j < n; j++)
>             {
>                 linkedlist_pop(ll, j);
>             }
>         }
>     }
> 
>     printf("\n-----------------------------------\nnum=%d, pop all\n-----------------------------------\n", ll->num);
> 
>     for (j = ll->num; j > 0; j--)
>     {
>         linkedlist_pop(ll, j);
>     }
>     return 0;
> }
diff -r ./zan-extension/tests/heap_test.c ../swoole-1.8.5-stable/tests/heap_test.c
45c45
<         ns = sw_malloc(sizeof(node_t));
---
>         ns = malloc(sizeof(node_t));
48c48
<         swHeap_insert(pq, pri, ns);
---
>         swHeap_push(pq, pri, ns);
Only in ../swoole-1.8.5-stable/tests: hpack
Only in ../swoole-1.8.5-stable/tests: int
diff -r ./zan-extension/tests/main.c ../swoole-1.8.5-stable/tests/main.c
34a35
> 	swUnitTest_steup(linkedlist_test, 1, "linkedlist data struct test");
diff -r ./zan-extension/tests/pool.c ../swoole-1.8.5-stable/tests/pool.c
24c24
< 	int *workingnum = (int *) sw_malloc(sizeof(int) * n);
---
> 	int *workingnum = (int *) malloc(sizeof(int) * n);
diff -r ./zan-extension/tests/server.c ../swoole-1.8.5-stable/tests/server.c
8,10c8,9
< void my_onConnect(swServer *serv, int fd, int from_id);
< void my_onClose(swServer *serv, int fd, int from_id);
< void my_onTimer(swServer *serv, int interval);
---
> void my_onConnect(swServer *serv, swDataHead *info);
> void my_onClose(swServer *serv, swDataHead *info);
43d41
< 	serv.backlog = 128;
46a45,46
> 	serv.open_cpu_affinity = 1;
> 	serv.daemonize = 1;
48,51c48,54
< 	//serv.open_cpu_affinity = 1;
< 	//serv.open_tcp_nodelay = 1;
< 	//serv.daemonize = 1;
< 	//serv.open_eof_check = 1;
---
>     //create Server
>     ret = swServer_create(&serv);
>     if (ret < 0)
>     {
>         swTrace("create server fail[error=%d].\n", ret);
>         exit(0);
>     }
54c57,61
< 	swServer_add_listener(&serv, SW_SOCK_TCP, "127.0.0.1", 9501);
---
>     swListenPort *port = swServer_add_port(&serv, SW_SOCK_TCP, "127.0.0.1", 9501);
>     port->backlog = 128;
>     port->open_tcp_nodelay = 1;
>     port->open_eof_check = 1;
> 
58,60d64
< 	//swServer_addTimer(&serv, 2);
< 	//swServer_addTimer(&serv, 4);
< 
66d69
< 	serv.onTimer = my_onTimer;
68,74d70
< 	//create Server
< 	ret = swServer_create(&serv);
< 	if (ret < 0)
< 	{
< 		swTrace("create server fail[error=%d].\n", ret);
< 		exit(0);
< 	}
84,88d79
< void my_onTimer(swServer *serv, int interval)
< {
< 	printf("Timer Interval=[%d]\n", interval);
< }
< 
120c111
< 	printf("Server is shutdown\n");
---
>     printf("Server is shutdown\n");
123c114
< void my_onConnect(swServer *serv, int fd, int from_id)
---
> void my_onConnect(swServer *serv, swDataHead *info)
125c116
< 	printf("Connect fd=%d|from_id=%d\n", fd, from_id);
---
>     printf("PID=%d\tConnect fd=%d|from_id=%d\n", getpid(), info->fd, info->from_id);
128c119
< void my_onClose(swServer *serv, int fd, int from_id)
---
> void my_onClose(swServer *serv, swDataHead *info)
130c121
< 	printf("Close fd=%d|from_id=%d\n", fd, from_id);
---
>     printf("PID=%d\tClose fd=%d|from_id=%d\n", getpid(), info->fd, info->from_id);
diff -r ./zan-extension/tests/u2.c ../swoole-1.8.5-stable/tests/u2.c
54c54
<     test_node *node = sw_malloc(sizeof(test_node));
---
>     test_node *node = malloc(sizeof(test_node));
diff -r ./zan-extension/travis/compile.sh ../swoole-1.8.5-stable/travis/compile.sh
2c2
< phpize && ./configure && make clean && make
---
> phpize && ./configure --enable-async-httpclient && make clean && make
